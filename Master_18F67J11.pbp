'************************************************************************
'Copyright (c) 2014 - OpenMotics <info@openmotics.com>

'This file is part of OpenMotics.

'OpenMotics is free software: you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation, either version 3 of the License, or
'(at your option) any later version.

'OpenMotics is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.

'You should have received a copy of the GNU General Public License
'along with OpenMotics.  If not, see <http://www.gnu.org/licenses/>.
'************************************************************************

'Firmware to be used with the OpenMotics Gateway Module and programmed on the Microchip PIC18F67J11

'Written in Pic Basic Pro 2.6 however it should be compatible with Pic Basic Pro 3.0 but this is not yet tested
'Interrupt system of Darrel Taylor is used see http://darreltaylor.com/DT_INTS-18/home.html
                           
'---------------------------------------------------------------------------------------------------------------
'For more information, schematics etc see 
'   http://wiki.openmotics.com
'For details regarding the implemented Master RS232 CLI instructions see
'   http://wiki.openmotics.com/index.php/CLI_Reference_Guide 
'For details regarding the implemented Master RS232 API instructions see
'   http://wiki.openmotics.com/index.php/API_Reference_Guide
'For details regarding the used RS485 communication protocol see
'   http://wiki.openmotics.com/index.php/Master_RS485_Cummunication_Protocol
'For details regarding the used memory layout of the eeprom see
'   http://wiki.openmotics.com/index.php/Memory_Model
'For more information regarding the different implemented action types and basic actions see
'   http://wiki.openmotics.com/index.php/Action_Types
'For more information regarding the implemented error codes see
'   http://wiki.openmotics.com/index.php/Error_Codes
'For the release notes since V3.140.104 see
'   http://wiki.openmotics.com/index.php/Master_Release_Notes
'---------------------------------------------------------------------------------------------------------------


INCLUDE "DT_INTS-18.bas"                    ; Base Interrupt System
INCLUDE "ReEnterPBP-18.bas"                 ; Include if using PBP interrupts

DEFINE OSC 40

version con 3
firmware con 143
built con 26

hardware con 4

'1-> 18F2620 20Mhz + co-processor 18F1220 for Rs232 communication
'2-> 18F67J11 20Mhz + co-processor 18F1220 for Rs232 communication
'3-> 18F67J11 20Mhz (full interrupt based)
'4-> 18F67J11 40Mhz (full interrupt based)

startup var bit
startup=1                                   'processor is in startup mode
OSCCON.0=0                                  'external oscillator
OSCCON.1=0
OSCTUNE.6=1                                 'PLL enabled
RS485_mode  var    PORTC.0                  'Mode for RS485 chip (send or receive)
Button2     var    PORTB.1
PowerSlaves var    PORTD.3                  'Relay to drive power on the RS485 Bus
DPIN2 var PORTD.5                           'i2c pins - SDA
CPIN2 var PORTD.6                           'i2c pins - SCL
Low PowerSlaves                             'Switch ON PowerSlaves
led_red var PORTC.3
high led_red

TRISG = %11111111
TRISF = %11111111
TRISE = %10111111
TRISD = %11111111
TRISC = %11111110
TRISB = %11111111
TRISA = %11111111

'uart--------------------------------------------------------------------------
BAUDCON1 = %01001000
BAUDCON2 = %01001000
SPBRGH1 = 0                                 '115200 baud
SPBRG1 = 86
SPBRGH2 = 0                                 '115200 baud
SPBRG2 = 86
RCSTA1 = %10010000
RCSTA2 = %10010000
TXSTA1 = %00100110
TXSTA2 = %00100110
RCSTA2.4=0                                  'disable serial 2 receiver
RCSTA1.4=0                                  'disable serial 1 receiver
'------------------------------------------------------------------------------

NrOutputsOn var byte
NrOutputsOn=0
RecSer1 var bit
RecSer1=0
PointerSer1 var byte
PointerSer1=0
RecSer1Temp1 var byte
RecSer1Temp2 var byte
InterpreteSer1 var bit
InterpreteSer1=0
RecSer2 var bit
InstrOk var bit
RecSer2=0
PointerSer2 var byte
PointerSer2=0
MaxChar var byte
MaxChar=18
RecSer2Temp1 var byte          
RecSer2Temp2 var byte
RecSer2Temp3 var byte
TimeOutSer1 var bit
TimeOutSer1=0
OdCode var byte                             'Output Debug Code
OdOutputNr var byte                         'Output Debug Output Nr
InputDebug var bit
InputEnable var bit[240]
InputDebug=0
ApiExit var bit
ApiExit=0
InputFilter var byte
UpDwn var bit
UpDir var bit
GroupDimValue var byte
GroupNr var byte
GroupOn var bit

indicate var byte
indicate=255
IndicateInput var bit
IndicateTemperature var bit
IndividualTempOn var bit

poll var bit
poll=1
pollNr var byte
pollNr=0
pollNrOut var byte
pollNrOutRS var byte
pollNrOut=0
pollNrOutRS=0

INTCON=%00000000 

'------------------------------------------------------------------------------
'Variables and constants
'------------------------------------------------------------------------------
        
command var     byte                        ' Storage for command
i       var     byte                        ' Storage for loop counter
i_bit   VAR     BIT
i_bit2  VAR     BIT
ic      var     byte
temp    var     word                        ' Storage for temperature
EchoOnBit var bit
Buffer_size con 132                         ' Number of bytes received from serial buffer
SerString VAR Byte[Buffer_size]
nr_of_cmd con 160                           ' nr of commands (command line instructions)
test var byte
'TestMode var bit
'TestMode=0
'TestPhase var byte
'TestPhase=0
'TestOn var bit
'TestOn=0
cmd var byte
instruction var byte
TestChar var bit[nr_of_cmd]
k var byte
digit var byte[5]                           ' max 5 digits
CharPointer var Byte
DigitTotal var word[9]
DigitCount var byte
length var byte
s var byte
vi var byte
t_word var word
t_word2 var word
DebugMode var bit
AutResponse var bit
AutResponseOL var bit
AutResponseIL var bit
AutResponseSO var bit
AllOff var bit
DuplicateID var bit
ok var bit                                  'if =1 -> "OK" message on console in CLI mode
LastDimmer var byte                         'last light switched on with "ON" instruction
RS9600 con 84
RS19200 con 32
pause_value con 5                           'pause between putting RS485 in send mode and effectively sending data
RecChar var byte[buffer_size]               'Received command line characters
RecCounter var byte                         '# of received character
char var byte
j var byte
Buffer2 con 21                              'Number of bytes receices from RS485 bus
RS485string var byte[Buffer2]
i2ccont var byte                            'chip address
i2caddr var byte                            'address within the chip to select data
i2cdata var byte                            'data to read or write
i2cMode var byte
i2cAck var bit
i2cInt var bit
i2cMode=0
i2cInt=0
i2creadbit var bit
i2cClock var bit
i2cClock=0
i2cError var word
i2cError=0
i2cError2 var word
i2cError2=0
i2cTimeScan var byte
i2cTimeScan=0
ResetI2c var bit
ResetI2c=0
tp var byte
err var bit
mode var byte                               'mode="L"-> live mode, mode="I"-> Initialization mode
mode_com var bit                            'mode_com=1 -> advanced mode, =0 Simple mode (command line)
broad1 var byte
broad2 var byte
broadID var byte
broadData var byte
x var byte
y var byte
z var byte
a var byte
b var byte
c var byte
d var byte
t var byte
ti var byte
q var byte
u var byte                                  'loop counter used in all_lights_off funtion
v var byte
w var byte
f var byte
g var byte
r var byte
m var byte
n var byte
cid var byte
CIDused var bit
CIDused=0
write_yes var bit
write_yes_RS var bit
write_yes_mod var bit[30]
write_yes_modRS var bit[30]
press var bit
input_pressed var byte
eep_addr var word                           'memory address in eeprom
Fcommand var byte
e_word var word                             'temp variable
z1     var byte
CurrentInput var byte                       'This byte will hold the current switch being pressed
CurrentInput=255
IfInstr var byte
IfInstr=255
inp var byte[30]                            'Input that has been read from the different input controllers
inp_invert var byte[30]
led_button var byte[30]                     'Leds on input button module
inp_old var byte[30]                        'Last input that has been read from the different input controllers
out var byte[30]                            'Output that has written to the output controllers
out_update var bit[240]
outRs var byte[30]
sel_output var byte[240]                    'link between input and selected output (<240 -> toggle selected output, >239 -> perform group action list)
controller_in var byte                      'number of input controllers
controller_out var byte                     'number of output controllers
controller_out_RS var byte                  'number of Roller/Shutter controllers when Large installation is enabled
LargeInstallation var bit                   'When Large Installation is enabled, Roller/Shutter modules will be placed in the Roller/Shutter list
Temperature var byte[32]                    'Temperature on input module or Temperature Module
TempCor var bit
VirtualSensor var bit[32]
PermanentManual var bit[48]
TempOffset var byte[32]
TemperatureCount var byte
ldr var byte[32]                            'light intensity measured on input module
humidity var byte[32]
CheckTemp var bit
TempCom var byte
TempCom=0
textstart var byte
textlength var byte
text var bit
p var byte
f0 var byte
f1 var byte
AddToQueue var bit
Mod_ID0 var byte[60]
Mod_ID1 var byte[60]
Mod_ID2 var byte[60]
Mod_ID3 var byte[60]
cmi var byte                                'Loop counter to calculate Module_ID         
timer_cd var word[240]                      'Timer Count Down
switch_type var bit[240]
timer var word                              'Timer set value
TimerSet var bit[240]
error_code var byte                         'used in the subroutine "send_error"
error_ID var byte[4]
ErrorTmp var byte
ErrorBit var BIT[62]
ErrorCount var word[62]
ErrorMax var word
press_time var byte[240]                    'length of time (number of cycles) a button has been pressed
dimmer_value var byte[240]                  'dimmer value (240 x 6bits value)
dim_direction var bit[240]                  'Dimmer direction (1 bit per light), 1 dimming up, 0 dimming down
dimmer_action var bit[240]
dim_minimum var byte
dim_step var byte
dim_cycle var byte
dimmer_mem var Byte 
queue_max con 105
queue_type var byte[queue_max]              'type of intelligent action (simple action, group action, simple decision or group decision)
queue_action var byte[queue_max]            'action number
queue_pointer var byte                      'number of actions in the queue
action var byte[8]
queue_module_nr var byte
queue_input_nr var byte
queue_counter var byte
queue_bit var byte
queue_temp var byte
decision_old var bit
decision_new var bit
val_bit var BIT[256]
Sched_queue_counter var byte
Sched_queue_max con 70
Sched_bit var bit
Sched_Hour var byte[Sched_queue_max]
Sched_Minute var byte[Sched_queue_max]
Sched_Day var Byte[Sched_queue_max]
Sched_Type var byte[Sched_queue_max]
Sched_Action var byte[Sched_queue_max]
timer_queue con 50                          'Timer queue for decision that measure the time of an input before taking an action
timer_action var byte[timer_queue]          'Action (that will be copied in the action queue when true)
timer_type var byte[timer_queue]            'Action type (decision or simple action or group action)
timer_input var byte[timer_queue]           'Input (that remains active) that is measured
timer_seconds var byte[timer_queue]         'Seconds that an input must remains pressed before the action is activated (copied in the action queue)
timer_queue_pointer var byte                'Number of timer actions in the queue
timer_queue_last var bit
WaitTimeInput var byte
WaitTimeOutput var byte
PollTimeInput var byte
PollTimeInput=0
PollTimeOutput var byte
PollTimeOutput=0
PollTimeMain var byte
RS485busy var bit
RS485busy=0
RS485message var byte
hours var byte
minutes var byte
seconds var byte
seconds_old var byte
days var byte
NumberOfChar var byte
PowerSafe var bit
Spaces var bit 
Nrcontrollers con 32                        'put at 24 because RAM of DS1307, maximum 32 !!! 
Controllers var byte
Controllers=24                              'See also Eeprom Page0 Byte 59
SetPt var byte[Nrcontrollers]                 'temperature setpoint
Integral var byte[Nrcontrollers]
last var byte[Nrcontrollers]
Thermostat var byte[Nrcontrollers]
Thermostat2 var byte[Nrcontrollers]
ThermostatSensor var byte[Nrcontrollers]
ThermostatUpdate var bit
ThermostatMode var byte
ThermostatOn var bit
ThermostatCooling var bit
ThermostatAuto var bit[Nrcontrollers]
'ThermostatManualB0 var bit[Nrcontrollers]
'ThermostatManualB1 var bit[Nrcontrollers]
Airco var bit[Nrcontrollers]                  'Enable/disable Airco when using RTD-10
pid var byte  
actual var byte
ErrorPid var word
Psign var bit
Isign var bit
Dsign var bit
Xword var word
Xbyte var byte
Kp var byte
Ki var byte
Kd var byte
Drive var word
DriveOutput var byte
IntThresh var byte
Dr var byte
PidMode var bit
PidMode=0                                   'Pid Debug off
pump var bit
pump_delay var byte
Temp_Mod_Installed var bit
Temp_Threshold var byte
Outside_sensor var byte
Tt var byte                                 'Thermostat timing
T_timing var byte[4]
level var byte                              'which floor level that needs to be switched off
jf var byte                                 'variables for All_lights_off function
xf var byte
yf var byte
zf var byte
af var byte
bf var byte
cf var byte
CRC var word
CRC2 var word
ForceCRC var bit                            'if 1, message from input modules without CRC will be ignored and dropped
c1 var byte
x1 var byte
y1 var byte
e var byte[20]
ToggleFollowON var bit
ToggleFollowActive var bit
ToggleFollowData var bit
ToggleFollowON=0
ToggleFollowActive=0
TimerQueueEn var bit
TimerQueueEn=0
DelayedTime var byte
DelayedTime=0
ActionButtonRelease var bit
ActionButtonRelease=0
PumpCheckNow var bit
PumpCheckNow=0
PumpCheckCounter var byte
PumpCheckCounter=0
PumpOn var bit[8]
PumpOn[0]=0
PumpOn[1]=0
PumpOn[2]=0
PumpOn[3]=0
PumpOn[4]=0
PumpOn[5]=0
PumpOn[6]=0
PumpOn[7]=0
CheckTimerQueue var bit
PidCalcNow var bit
PidCalcNow=0
PidCalcCheck var bit
PidCalcCheck=0
PidCalcCounter var byte
PidCalcCounter=0
InputDelayAction var bit[241]
StoreMove var bit
SetAuto var bit
SetAuto=0
CleanTimerQueue var bit
CleanTimerQueue=1             'always check for double BA's in the timer queue qnd remove doubles, see also BA 79

RescueCounter var byte[8]
RescueCounter[0]=0
RescueCounter[1]=0
RescueCounter[2]=0
RescueCounter[3]=0
RescueCounter[4]=0
RescueCounter[5]=0
RescueCounter[6]=0
RescueCounter[7]=0

SSP2ADD=124                                 'i2c at 80kHz
SSP2STAT=%10000000
SSP2CON1=%00101000

i2cdata=255
EepPage0 var bit
EepPage0=0
OledEeprom var word
OledEeprom=0
OledEepromBit var bit
OledEepromBit=0
Oleddata var byte
OledDataOk var bit
OledDataOk=0
SyncDebug var bit
SyncDebug=0
SyncEnable var bit
SyncEnable=1
ThermostatCounter var byte
ThermostatCounter=0
TemperatureCounter var byte
TemperatureCounter=0
OledActionType var byte
OledActionNumber var Byte
OledActionType2 var byte
OledActionNumber2 var Byte
OledInstr0 var byte
OledInstr1 var byte
OledInstr0=255
OledInstr1=255
OledActionType=255
OledActionNumber=255
FreeVar var byte[32]

NumberPulseCounters con 24
PulseCounter var word[NumberPulseCounters]
PulseInput var byte[NumberPulseCounters]

RecBytesSer1 var byte
RecBytesSer1=14
CatchAll var bit
CatchAll=0
CatchAllByte var byte
CatchAllByte=6
ScanTime var bit
ScanTimeCounter var byte
BootLoaderMode var bit
BootLoaderMode=0                            'Normal mode
PollCheck var byte
PollCheck=0

'-----------------------------------------------------------------------------
' Interrupt definition
'-----------------------------------------------------------------------------

;----[High Priority Interrupts]-----------------------------------------------
ASM
INT_LIST  macro      ; IntSource,      Label,     Type, ResetFlag?
        INT_Handler     RX1_INT,     _Receive1,    PBP,  no 
        INT_Handler     RX2_INT,     _Receive2,    PBP,  no 
        INT_Handler     TMR0_INT,    _Timer0,      PBP,  yes
        INT_Handler     TMR2_INT,    _Timer2,      PBP,  yes        
        INT_Handler     TMR3_INT,    _Timer3,      PBP,  yes     
        INT_Handler     SSP2_INT,    _SSP2,        PBP,  no                      
    endm
    INT_CREATE                              ; Creates the High Priority interrupt processor
ENDASM

T0CON = %00000100                           ; Timer 0 setting, prescaler 16, 16 bits, overflow after +/- 100 ms
T2CON = %00000011                           ; T2 = 8-bit, no prescaler and 16 postscaler (interrupt every 0,4ms)
T3CON = %00101000                           ; T3 = 16-bit, 1:4 prescaler, interrupt every 26ms
 
@    INT_ENABLE  RX1_INT                    ; Enable USART Receive interrupts
@    INT_ENABLE  RX2_INT                    ; Enable USART Receive interrupts
@    INT_ENABLE  TMR0_INT                   ; enable Timer 0 interrupts
@    INT_ENABLE  TMR2_INT                   ; enable Timer 2 interrupts
@    INT_ENABLE  TMR3_INT                   ; enable Timer 3 interrupts for i2c timeout
@    INT_ENABLE  SSP2_INT                   ; enable SPI 2 interrupt (i2c)

RCSTA1.4=1                                  'enable serial 1 receiver
RCSTA2.4=1                                  'enable serial 2 receiver
PIE2.1=1                                    'Timer 3 interrupt enable
PIR2.1=0                                    'Clear timer3 interrupt flag
T3CON.0=0                                   'stop timer3
PIE1.1=1                                    'timer 2 interrupt enabled
T2CON.2=1                                   'timer2 started                
                            
'------------------------------------------------------------------------------
'Initialization
'------------------------------------------------------------------------------

pause 80
mode_com=0                                  'simple communication mode
ok=1
input_pressed=255
write_yes = 0
i2cdata = 255
i2caddr = 255
x = 0
y = 0
z = 0
temp.byte0 = 0
temp.byte1 = 128                            'We don't know yet if the sensor is connected or working
timer_queue_pointer = 0                     'nothing in the queue
mode="L"                                    'Live mode
gosub reset_error

for i=0 to 239
  timer_cd[i]=0
  TimerSet[i]=0
  press_time[i]=0
  dimmer_value[i]=63
  dimmer_action[i]=0
  queue_type[i]=255
  queue_action[i]=255
  InputDelayAction[i]=0
  InputEnable[i]=1
  switch_type[i]=1
  out_update[i]=0
next i

InputDelayAction[240]=0
timer_queue_pointer = 0                     'nothing in the queue
for i=0 to (timer_queue-1)                  'put timerqueue correctly
  timer_action[i]=255
  timer_type[i]=255
  timer_input[i]=255
  timer_seconds[i]=255
next i
queue_pointer=0                             'nothing in the queue

for i=0 to (Sched_queue_max-1)
  Sched_hour[i]=255
  Sched_minute[i]=255
  Sched_day[i]=255
  Sched_type[i]=255
  Sched_action[i]=255
next i
for i=0 to 29
  led_button[i]=0
  e_word.byte0=255
  e_word.byte1=255
  ErrorCount[i]=0
  ErrorCount[i+30]=0
  inp_invert[i]=255
next i
for i=0 to 31
  ldr[i]=255
  temperature[i]=255
  humidity[i]=255
  FreeVar[i]=0  
next i
for i=0 to (controllers-1)
  Thermostat[i]=255
  Airco[i]=0
next i
for i=0 to (NumberPulseCounters-1)
  PulseCounter[i]=0
next i
Sched_queue_counter=0                       'scheduled queue is empty
level=255
OledInstalled var bit
OledInstalled=0

'delete
pause 2000

Gosub Check_Thermostat_values               'Check if night temperature values are correctly programmed
Gosub activate_eeprom                       'Copy eeprom values into RAM
gosub Read_ThermostatMode
gosub Check_LIM                             'Check if Large installation mode can be enabled
Gosub find_clock                            'Find DS1307 and check if out(x) is available in RAM DS1307
for i=1 to controller_out                   'Put timervalues of activated outputs
  for t=0 to 7
    x=out[i-1]>>t
    y=((i-1)*8)+t
    if x.bit0=1 then
      timer=y
      gosub Timer_value_read                'Retreive timer value
      timer_cd[y]=timer  
    else
      timer_cd[y]=0
    endif
  next t
next i
mode="L"                                    'Bus in Live mode
broad1="L"
broad2="L"
BroadID=0
gosub send_broad
pause 10
gosub send_broad
for i=1 to controller_out                   'write output to all modules
  write_yes_mod[i-1]=1
next i
write_yes=1
if controller_out_RS>0 then
  for i=1 to controller_out_RS                'write output to all modules
    write_yes_modRS[i-1]=1
  next i
  write_yes_RS=1
else
  write_yes_RS=0
endif    
pause 20
gosub rs485_output
ok=0
gosub low_Powerstate                        'switch off leds of all modules
pause 50
gosub startup_activate                      'copy actions in startup page to the action queue
ok=1               
PIE3.7=1                                    'enable interrupt

gosub thermostat_timing                     'set all thermostats in the right mode conform to the programmed timings
gosub Thermostat_Multi_tenant               'Set all the correct setpt when in Multi-tenancy mode
gosub correct_setpt

'delete         Problem with Clock RAM must be solved first
gosub all_outputs_off  
startup=0                                   'startup is finished 

'delete

'hserout2 ["Startup Done",13,10]
  

'------------------------------------------------------------------------------
' Start Main Routine
'------------------------------------------------------------------------------
 
MainLoop:
  if pollcheck>2 then pollcheck=0
  gosub communication_error                 'Resolve communication errors, rs232 and i2c
  gosub reset_i2c
  gosub rs232_interprete
  gosub rs485_interprete    
  if mode="L" and bootloadermode=0 then     'normal operation
    high led_red
'    if TestMode=0 then 
      gosub check_button                    'check buttons
'    else
'      gosub Test_module                     'testing script
'    endif    
    gosub read_clock                        'check time and timer
    gosub Pid_Calc                          'Check if Thermostat PID calculation needs to be done
    gosub Pump_Check                        'Check If Pumps needs to be checked
    gosub rs485_poll                        'poll input modules
    gosub RS485_output                      'write outputs
    gosub RS485_outputRS                    'Write Roller/Shutter in Large installation
    gosub RS485_fault                       'check if errors occured
    gosub check_queue
    gosub check_timer_queue
  endif
goto MainLoop


'----------------------------------------------------------------------------
' Interrupt routines
'----------------------------------------------------------------------------

Receive1:                                   'RS485
  recser1temp1=recser1temp2                 'Keep previous character also
  recser1temp2=RCREG1
  if recser1=1 then                         'Receiving? 
    RS485string[PointerSer1]=recser1temp2
    if PointerSer1<(Buffer2-1) then 
      pointerser1=pointerser1+1
    else
      RecSer1=0                             'stop receiving ser1 and buffering/interpreting
      InterpreteSer1=1
      RCSTA1.4=0                            'disable receiving serial 1
    endif
    if recser1temp1=13 and recser1temp2=10 then
      RecSer1=0                             'stop receiving ser1 and buffering/interpreting
      InterpreteSer1=1 
      RCSTA1.4=0                            'disable receiving serial 1
      T0CON.7=0                             'timer 0 disabled
    endif
    if Rs485message="O" then
      if PointerSer1>RecBytesSer1 then      'Output message (Dimmer, output or Store module)
        RecSer1=0                           'stop receiving ser1 and buffering/interpreting
        InterpreteSer1=1
        RCSTA1.4=0                          'disable receiving serial 1
        T0CON.7=0                           'timer 0 disabled
      endif  
    endif       
  else 
    if recser1temp1="R" and recser1temp2="C" then
      Pointerser1=0
      recser1=1                             'start receiving ser1
      interpreteser1=0
    endif
    if recser1temp1="G" and recser1temp2="M" then
      Pointerser1=0
      recser1=1                             'start receiving ser1
      interpreteser1=0
    endif
  endif    
@ INT_RETURN

Receive2:                                   'RS232
  recser2temp1=recser2temp2                 'Keep previous character also
  recser2temp2=recser2temp3
  recser2temp3=RCREG2
  if Mode_com=0 then                        'CLI Mode
    SerString[PointerSer2]=recser2temp3
    if (recser2temp3=13) or (PointerSer2>(Buffer_size-2)) then    
      RecSer2=0                             'stop receiving ser2 and buffering/interpreting
      RCSTA2.4=0                            'disable receiving serial 2
    else
      if RecSer2Temp3=8 or RecSer2Temp3=27 or RecSer2Temp3=127 then
        if PointerSer2>0 then pointerser2=pointerser2-1
      else
        pointerser2=pointerser2+1 
      endif  
    endif
    if EchoOnBit=1 then
      TXREG2=recser2temp3
    endif
  else                                      'API Mode
    if RecSer2=1 then                       'in Buffering mode
      if PointerSer2>(MaxChar-2) then       'stop when MaxChar characters are received   
        RecSer2=0                           'stop receiving ser2 and buffering/interpreting
        RCSTA2.4=0                          'disable receiving serial 2
      else
        SerString[PointerSer2]=recser2temp3
        pointerser2=pointerser2+1
      endif  
    else                                    'Not in buffering mode
      if recser2temp1="S" and recser2temp2="T" and recser2temp3="R" then 'start message 
        RecSer2=1                           'Start receiveing
      endif    
    endif  
  endif
@ INT_RETURN

SSP2:
  PIE3.7=0                                  'disable interrupt
  if i2cmode>0 then i2cMode=i2cMode+1
  i2cInt=1

  PIR3.7=0                                  'clear interrupt flag
  PIE3.7=1                                  'enable interrupt   
@ INT_RETURN

Timer0: 
  'This timer is enabled and will wait max 100 ms for the remote modules to answer
  T0CON.7=0                                 'timer 0 disabled
  TMR0L=0                                   'reset value
  TMR0H=0
    if Interpreteser1=0 then
      TimeOutSer1=1
      RCSTA1.4=0                            'disable receiving serial 1
    endif   
@ INT_RETURN

Timer2:                                     'interrupt every 0.4096ms for communication
  T2CON.2=0                                 'timer 2 disabled
  TMR2=0                                    'reset value 
  if pollTimeInput>0 then pollTimeInput=pollTimeInput-1
  if pollTimeOutput>0 then pollTimeOutput=pollTimeOutput-1
  if ScanTimeCounter=0 then 
    ScanTime=1                              'Only check clock every 104ms
    CheckTimerQueue=1                       'Only check timer queue every 104ms
  endif  
  ScanTimeCounter=ScanTimeCounter+1
  PIR1.1=0                                  'interrupt flag cleared
  T2CON.2=1                                 'timer 2 enabled
@ INT_RETURN

Timer3:                                     'Timer used for i2c
  PIR2.1=0                                  'clear timer3 interrupt flag
  T3CON.0=0                                 'stop timer3 
  SSP2CON2.2=1                              'sent i2c stop
  i2cmode=0                                 'stop
  err=1                                     'error
  if i2cError2<65535 then i2cError2=i2cError2+1  
@ INT_RETURN

'------------------------------------------------------------------------------
'Subroutines
'------------------------------------------------------------------------------ 

Communication_Error:
  if RCSTA1.2=1 then                        'framing error
    x1=RCREG1
  endif
  if RCSTA2.2=1 then                        'framing error
    x1=RCREG2
  endif    
  If RCSTA1.1=1 then                        'overrun error bit
    RCSTA1.4=0                              'disable reception
    RCSTA1.1=0                              'Clear overrun
    RCSTA1.4=1                              'enable again receiving if error occured    
  endif 
  If RCSTA2.1=1 then                        'overrun error bit
    RCSTA2.4=0                              'disable reception
    RCSTA2.1=0                              'Clear overrun
    RCSTA2.4=1                              'enable again receiving if error occured    
  endif    
return

Reset_i2c:
  if ResetI2c=1 and i2cMode=0 then
    ResetI2c=0 
    PIE3.7=0                                'disable interrupt  
    SSP2CON1.5=0                            'disable i2c    
    output DPIN2                            'SDA
    output CPIN2                            'SCL
    high DPIN2
    high CPIN2
    pauseus 10
    for i=0 to 8
      pauseus 10
      low DPIN2
      pauseus 10
      low CPIN2
      pauseus 10
      high DPIN2
      pauseus 10
      high CPIN2    
    next i
    input DPIN2
    input CPIN2 
    SSP2ADD=124                             'i2c at 80kHz
    SSP2STAT=%10000000
    SSP2CON1=%00101000
    PIR3.7=0                                'clear interrupt flag  
    PIE3.7=1                                'enable interrupt
    i2cmode=0  
    i2cInt=0
  endif  
return

pump_check:
  if PumpCheckNow=1 then
    if PumpCheckCounter<8 then
      eep_addr.byte1=144+(59*thermostatCooling)                    'page 144 or 203
      eep_addr.byte0=PumpCheckCounter  
      gosub read_eeprom
      'delete
      'if debugmode=1 then
      '  hserout2 ["PumpChkCnt=",dec pumpcheckcounter," output=",dec i2cdata," (",dec eep_addr.byte1,"/",dec eep_addr.byte0,") ",bin8 thermostatMode,13,10]
      'endif
      a=i2cdata                             'Pump output 
      if a<240 then                         'Output exists
        pump=0
        for j=0 to 31                       'check list of outputs
          eep_addr.byte1=143+(59*thermostatCooling)                'page 143 or 202
          eep_addr.byte0=(PumpCheckCounter*32)+j
          gosub read_eeprom
          ;delete
          'if debugmode=1 then
          '  hserout2 ["Pump Outp chk: ",dec j," ",dec i2cdata," (",dec eep_addr.byte1,"/",dec eep_addr.byte0,") "]
          'endif  
          if i2cdata<240 then
            x=i2cdata//8
            y=i2cdata/8
            z=out[y]>>x
            pump=pump|z.bit0
            'delete
            'if debugmode=1 then
            '  hserout2 [dec x," ",dec y," ",bin8 out[y]," ",dec z," ",dec z.bit0," ",dec pump,13,10]
            'endif    
          else
            j=31                            'exit 
          endif      
        next j
        x=a//8
        y=a/8
        z=%00000001
        z=z<<x      
        if pump=1 then                      'output on
          'delete
          'if debugmode=1 then
          '  hserout2 ["Pump ON: ",dec PumpOn[PumpCheckCounter]," ",dec pump_delay,13,10]
          'endif 
          if PumpOn[PumpCheckCounter]=0 then
            PumpOn[PumpCheckCounter]=1                  'Pump output is switched on or will be switched on with a delay
            if pump_delay>0 and pump_delay<249 then     'output delay is active
              action[4]=161
              action[5]=a
              action[3]=pump_delay
              action[6]=240
              gosub add_timer_queue2
              'delete
              'if debugmode=1 then
              '  hserout2 ["Pump on ",dec a," delay ",dec pump_delay,13,10]
              'endif 
            else                                        'no output delay
              gosub Increase_queue_pointer
              queue_type[queue_pointer]=161             'output on
              queue_action[queue_pointer]=a
              'delete
              'if debugmode=1 then
              '  hserout2 ["Pump on ",dec a,13,10]
              'endif 
            endif
            OdCode=0                                    'output debug code
            OdOutputNr=a
            gosub Output_debug
          else
            gosub pump_rescue
          endif       
        else
          'delete
          'if debugmode=1 then
          '  hserout2 ["Pump off ",dec a,13,10]
          'endif                                         'output off
          RescueCounter[PumpCheckCounter]=0
          PumpOn[PumpCheckCounter]=0                    'Pump output is switched off
          gosub Increase_queue_pointer
          queue_type[queue_pointer]=160                 'output off
          queue_action[queue_pointer]=a
          OdCode=1                                      'output debug code
          OdOutputNr=a
          action[4]=161
          action[5]=a
          gosub Remove_timer_queue
          gosub Output_debug             
        endif
      endif
      PumpCheckCounter=PumpCheckCounter+1
    else
      PumpCheckCounter=0
      PumpCheckNow=0                                    'Check is done
    endif   
  endif
return

pump_rescue:
  u=out[y]>>x
  'delete
  'if debugmode=1 then
  '  hserout2 ["--Rescue ",dec a," ",dec y," ",dec x," ",bin8 out[y]," ",dec u.bit0," RC=",dec RescueCounter[PumpCheckCounter]," ",dec pump_delay," ",dec PumpCheckCounter,13,10]
  'endif   
  if u.bit0=0 then        'Pump output is not ON
    RescueCounter[PumpCheckCounter]=RescueCounter[PumpCheckCounter]+1
    'delete
    'if debugmode=1 then
    '  hserout2 [" -- RC=",dec RescueCounter[PumpCheckCounter]," ",dec PumpCheckCounter,13,10]
    'endif     
    if pump_delay=0 then  'pump_delay=0 so output should be on
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=161             'output on
      queue_action[queue_pointer]=a 
      'if debugmode=1 then
      '  hserout2 [" - Rescue Pump on ",dec a,13,10]
      'endif     
    else
      if RescueCounter[PumpCheckCounter]>5 then
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=161             'output on
        queue_action[queue_pointer]=a 
        'if debugmode=1 then
        '  hserout2 [" - Rescue Time Pump on ",dec a,13,10]
        'endif              
      endif
    endif
  endif  
return

Write_ThermostatMode:
  i2cdata=ThermostatMode
  eep_addr.byte0=14                         'address
  eep_addr.byte1=0                          'page
  gosub write_eeprom
  gosub Thermostat_multi_tenant  
return

Thermostat_Multi_tenant:
  If thermostatMode.bit6=1 then               'Thermostat Multi-tenancy is enabled
    for a=0 to (controllers-1)
      eep_addr.byte1=199                      'page
      eep_addr.byte0=a+32                     'Read multi-tenant configuration byte
      gosub read_eeprom
      if i2cdata.bit3=1 then                  'Auto mode  
        ThermostatAuto[a]=1
        q=a
        gosub thermostat_timing_sub           'Load the correct setpt for automatic mode
      else                                    'Manual mode
        ThermostatAuto[a]=0
        'if i2cdata.bit2=1 and i2cdata.bit1=0 and i2cdata.bit0=1 then      'Party
        '  ThermostatManualB1[a]=1
        '  ThermostatManualB0[a]=0
        'elseif i2cdata.bit2=1 and i2cdata.bit1=0 and i2cdata.bit0=0 then  'Vacation
        '  ThermostatManualB1[a]=0
        '  ThermostatManualB0[a]=1        
        'else                                                              'Away
        '  ThermostatManualB1[a]=0
        '  ThermostatManualB0[a]=0        
        'endif
        b=(4*i2cdata.bit2)+(2*i2cdata.bit1)+i2cdata.bit0
        gosub read_setpt                     'Load the correct setpt for manual mode
      endif   
    next a
  else                                       'Multi-tenancy mode is not enabled
    for a=0 to (controllers-1)
      ThermostatAuto[a]=ThermostatMode.bit3
    next a 
  endif
return


PID_read:
  eep_addr.byte0=pid*4                      'address
  eep_addr.byte1=141+(59*thermostatCooling)                        'page 141 or 200
  gosub read_eeprom 
  Kp=i2cdata 
  eep_addr.byte0=(pid*4)+1                  'address
  gosub read_eeprom 
  Ki=i2cdata 
  eep_addr.byte0=(pid*4)+2                  'address
  gosub read_eeprom 
  Kd=i2cdata   
  eep_addr.byte0=(pid*4)+3                  'address
  gosub read_eeprom 
  IntThresh=i2cdata
return

'For more information about PID, see http://wiki.openmotics.com/index.php/PID
PID_calc:
  if PidCalcNow=1 then
    if PidCalcCounter<controllers then 
      if ThermostatOn=1 then         'Thermostat function is ON  
        if Thermostat[PidCalcCounter]<241 and ThermostatSensor[pidCalcCounter]<32 then  'Thermostat is linked to output and Temperature sensor
          low led_red
          drive=0
          pid=PidCalcCounter
          gosub PID_read
          if PidMode=1 then
            gosub read_CH
            hserout2 [c,": ",dec days," ",dec2 hours,":",dec2 minutes," PID:",dec2 pidCalcCounter," "]
          endif      
          x=ThermostatSensor[pidCalcCounter]
          actual=temperature[x]
          if actual>40 and actual<175 then  'sensor is giving valid temperatures
          '--------P calculation---------------------------------        
            if ThermostatCooling=0 then   'Heating
              ErrorPid=SetPt[pidCalcCounter]-Actual
            else                            'Cooling
              ErrorPid=Actual-SetPt[pidCalcCounter]
            endif  
            Psign=ErrorPid.15               'remember sign
            Xword=(abs ErrorPid)*Kp
            if Psign=1 then                 'error is negative
              drive=drive-Xword
              gosub PrintModeMin        
            else
              drive=drive+Xword
              gosub PrintModePlus
            endif 
          '--------I calculation---------------------------------
            if (abs ErrorPid) < IntThresh then
              Integral[pidCalcCounter]=Integral[pidCalcCounter]+ErrorPid
            else
              Integral[pidCalcCounter]=0  
            endif
            Xbyte=Integral[pidCalcCounter]
            Isign=Xbyte.7
            If Xbyte>63 and xbyte<235 then
              if Isign=1 then
                Integral[pidCalcCounter]=235'-20
              else
                Integral[pidCalcCounter]=63 '63
              endif
              Xbyte=Integral[pidCalcCounter]        
            endif      
            Xword=(abs (Integral[pidCalcCounter]))*Ki
            if Isign=1 then
              drive=drive-Xword
              gosub PrintModeMin
            else
              drive=drive+Xword
              gosub PrintModePlus
            endif
           '--------D calculation---------------------------------
            if ThermostatCooling=0 then   'Heating
              Dr=last[pidCalcCounter]-Actual
            else                            'Cooling
              Dr=Actual-last[pidCalcCounter]
            endif
            Dsign=Dr.7                      'remember sign
            Xword=(abs Dr)*Kd
            if Dsign=1 then                 'negative
              drive=drive-Xword
              gosub PrintModeMin
            else
              drive=drive+Xword
              gosub PrintModePlus
            endif
            last[pidCalcCounter]=actual  
           '--------Correction values-----------------------------
            if drive.15 then drive=0
            drive=drive/2  
            if PidMode=1 then
              hserout2 [dec drive]
            endif
            if drive>126 then drive=126
            if drive>63 then                '2 outputs must be driven
              DriveOutput=63
              a=thermostat[pidCalcCounter]
              gosub SetThermostatOutput
              DriveOutput=Drive-63
              a=thermostat2[pidCalcCounter]
              gosub SetThermostatOutput        
            else
              DriveOutput=drive.byte0
              a=thermostat[pidCalcCounter]
              gosub SetThermostatOutput
              DriveOutput=0
              a=thermostat2[pidCalcCounter]
              gosub SetThermostatOutput         
            endif
          else                             'Switch off Outputs 
            DriveOutput=0
            a=thermostat[pidCalcCounter]
            gosub SetThermostatOutput
            DriveOutput=0
            a=thermostat2[pidCalcCounter]
            gosub SetThermostatOutput             
          endif
          if PidMode=1 then
            gosub display_LF_CR
          endif                  
        else                                'Time Based Switching
          q=pidCalcCounter
          gosub Set_TBS_Output
        endif
      else                                  'Thermostats are OFF        
        if ThermostatSensor[pidCalcCounter]<32 then   'Don't switch off for TBS
          a=thermostat[pidCalcCounter]
          DriveOutput=0
          gosub SetThermostatOutput
          a=thermostat2[pidCalcCounter]
          DriveOutput=0
          gosub SetThermostatOutput
        else                                          'Time Based Switching
          q=pidCalcCounter
          gosub Set_TBS_Output        
        endif           
      endif
      PidCalcCounter=PidCalcCounter+1
      PidCalcNow=0
    else
      PidCalcCheck=0
      PidCalcNow=0
      PidCalcCounter=0
    endif 
  endif     
return

SetThermostatOutput:
  'delete: In PidCalcCounter zit de thermostat nr
  if a<240 then
    timer_cd[a]=0
    dimmer_value[a]=DriveOutput
    x=a//8
    y=a/8
    z=%00000001
    z=z<<x
    out_update[a]=1
    if DriveOutput>0 then                   'switch on output
      out[y]=out[y]|z
      OdCode=2
      OdOutputNr=a      
      gosub Output_debug 
      tp=q
      q=a
      gosub dimmer_follow
      q=tp           
    else                                    'switch off output
      z=~z
      out[y]=out[y]&z
      OdCode=3
      OdOutputNr=a
      gosub Output_debug
      tp=q
      q=a
      gosub dimmer_follow
      q=tp                  
    endif
    write_yes=1
    write_yes_mod[y]=1
  elseif a=240 then                         'RTD-10 Temperature setting
    gosub RTD10
  endif    
return

RTD10:                                      'PidCalcCounter is used for thermostat Nr
  if Airco[PidCalcCounter]=1 then           'Airco must be ON
    u=1                                     'Output ON
    gosub Set_OnOff_output
    v=214                                   'Ventilation speed
    gosub Set_MVP                           'Mode, ventilation speed, poke angle
    v=215                                   'Mode
    gosub Set_MVP                           'Mode, ventilation speed, poke angle 
    v=216                                   'Poke Angle
    gosub Set_MVP                           'Mode, ventilation speed, poke angle
    gosub Set_Setpoint                      'Calculate and set Setpoint
  else                                      'Airco must be OFF
    u=0                                     'Output OFF
    gosub Set_OnOff_output                  
  endif
return

Set_Setpoint:
  eep_addr.byte0=PidCalcCounter+200           'address
  eep_addr.byte1=213+(4*thermostatCooling)    'page 213 or 217
  gosub read_eeprom                           'Output to be used
  if i2cdata<240 then                         'valid output
    digittotal[0]=i2cdata                     'output
    if SetPt[pidCalcCounter]<96 then          'below 16 degree
      x=96
    elseif SetPt[pidCalcCounter]>112 then     'Above 24 degree
      x=112
    else                                      'in range
      x=SetPt[pidCalcCounter]
    endif      
    x=x-96
    eep_addr.byte0=24+x                       'address
    eep_addr.byte1=213+(4*thermostatCooling)'page 213 or 217
    gosub read_eeprom                         'Output to be used 
    digitcount=2
    digittotal[1]=i2cdata
    gosub output_on
  endif  
return

Set_MVP:                                    'Set Mode, ventilation speed, poke angle
  eep_addr.byte0=PidCalcCounter             'address
  eep_addr.byte1=v+(4*thermostatCooling)  'page v or v+4
  gosub read_eeprom
  if i2cdata<240 then
    digittotal[0]=i2cdata                   'output    
    eep_addr.byte0=PidCalcCounter+64        'address
    eep_addr.byte1=v+(4*thermostatCooling) 'page 215 or 219, 216 or 220, ...
    gosub read_eeprom    
    if i2cdata>0 and i2cdata<63 then        'output ON
      digitcount=2
      digittotal[1]=i2cdata
      gosub output_on         
    else                                    'output OFF
      digitcount=1
      gosub output_off          
    endif
  endif
return

Set_OnOff_output:
  eep_addr.byte0=PidCalcCounter+100         'address
  eep_addr.byte1=215+(4*thermostatCooling)'page 215 or 219
  gosub read_eeprom
  if i2cdata<240 then
    digittotal[0]=i2cdata
    if u=1 then         'Switch output ON
      digitcount=2
      digittotal[1]=63
      gosub output_on     
    else                'Switch output OFF
      digitcount=1
      gosub output_off           
    endif
  endif       
Return

PrintModePlus:
  if PidMode=1 then
    hserout2 ["+",dec3 Xword," "]    
  endif
return

PrintModeMin:
  if PidMode=1 then 
    hserout2 ["-",dec3 Xword," "]    
  endif
return

WE:
  eep_addr.byte1 = 2
  gosub write_eeprom
return

reset_error:
  for ic=0 to 61
    ErrorBit[ic]=0                          'inputs nor outputs have an error
    ErrorCount[ic]=0
  next ic
  ErrorTmp=60
return
  
'------------------------------------------------------------------------------
' RS485
' For RS485 communication protocol, see http://wiki.openmotics.com/index.php/Master_RS485_Cummunication_Protocol
'------------------------------------------------------------------------------

Rs485_interprete:
  if interpreteSer1=1 then 
    RS485busy=0
    InterpreteSer1=0
    'delete
    'hserout2 ["Instr type:",RS485Message," ",RS485string[0],".",dec RS485string[1],".",dec RS485string[2],".",dec RS485string[3]," ",RS485string[4],13,10]
    if RS485Message="I" then                'Response Input (input, temp etc) modules
      i=pollNr
      if rs485string[0]="I" then            'Input
        gosub Communicate_input
      else                                  'Temp & oled
        if rs485string[0]="T" then          'Temperature (ADC value)
          gosub check_response_temp_module  'Input module
        elseif rs485string[0]="C" then      'CAN Control
          gosub Communicate_CAN
        elseif rs485string[0]="L" then      'Oled         
          gosub Communicate_oled
        endif  
      endif
      pollTimeInput=WaitTimeInput
    'endif
    elseif RS485Message="O" then                'Response Output modules
      if rs485string[0]="D" or rs485string[0]="R" or rs485string[0]="O" then
        i=pollNrOut
        if RS485string[4]="K" and RS485string[0]=Mod_ID0[29+i] and RS485string[1]=Mod_ID1[29+i] and RS485string[2]=Mod_ID2[29+i] and RS485string[3]=Mod_ID3[29+i] then   'Received OK from output Module
          i2caddr = 8+i
          if RS485string[0]="R" then 
            out[i-1]=RS485string[5]         'Retricted output module (curtains) will refuse to switch on output0 and 1 for example so the output module must give back the new state of the outputs
          endif
          i2cdata = out[i-1]                'put out(i) in clock ram
          gosub write_i2c_2
          pollTimeOutput=WaitTimeOutput
          ic=pollNrOut
          gosub sent_output
          i=pollNrOut
          gosub timer_value                 'set all timer values correctly  
        else
          i=pollNrOut
          error_ID[0]= Mod_ID0[29+i]        'Device is not responding with OK or wrong module is responding
          error_ID[1]= Mod_ID1[29+i]
          error_ID[2]= Mod_ID2[29+i]
          error_ID[3]= Mod_ID3[29+i]
          ErrorTmp=29+i
          error_code = 9
          Gosub Add_ErrorCount
          gosub send_error   
        endif        
      endif           
    'endif
    elseif RS485Message="R" then                'Roller/shutter in Large Installation Mode
      if rs485string[0]="R" then
        i=pollNrOutRS
        gosub Get_ID  
        if RS485string[4]="K" and RS485string[0]=Digit[0] and RS485string[1]=Digit[1] and RS485string[2]=Digit[2] and RS485string[3]=Digit[3] then   'Received OK from output Module
          outRS[i-1]=RS485string[5]         'Retricted output module (curtains) will refuse to switch on output0 and 1 for example so the output module must give back the new state of the outputs
          pollTimeOutput=WaitTimeOutput
          ic=pollNrOutRS
          if mode_com=1 and AutResponseSO=1 then  'only in API mode and when Auto Response Output List bit is set
            cid=0
            gosub SO_linux2                    'Send SO instruction to Master controller
          endif 
          write_yes_modRS[pollNrOutRS-1]=0 
        else
          i=pollNrOutRS
          error_ID[0]= Mod_ID0[29+i]        'Device is not responding with OK or wrong module is responding
          error_ID[1]= Mod_ID1[29+i]
          error_ID[2]= Mod_ID2[29+i]
          error_ID[3]= Mod_ID3[29+i]
          error_code = 28
          gosub send_error   
        endif        
      endif              
    elseif RS485Message="F" then                'Response Firmware instruction
    'elseif rs485string[4]="F" then
      'if rs485string[4]="F" then            'Firmware info came in
        e[0]=rs485string[4]
        e[1]=rs485string[5]
        e[2]=cid
        e[3]=rs485string[0]
        e[4]=rs485string[1]
        e[5]=rs485string[2]
        e[6]=rs485string[3]
        e[7]=rs485string[6]
        e[8]=rs485string[7]
        e[9]=rs485string[8]
        e[10]=rs485string[9]
        e[11]=rs485string[10]
        e[12]=rs485string[11]
        e[13]=rs485string[12]
        e[14]=rs485string[13]
        e[15]=rs485string[14]                        
        gosub send_API
      '  hserout2 ["Firmware instruction sent",13,10]   
      'endif 
    elseif RS485Message="t" then                'Response 16 ports Temp module (old version) 
      if Rs485string[0]="T" and rs485string[1]="0" and rs485string[2]="0" and rs485string[3]="0" then
        for ic=0 to 15
          a=ic+14
          gosub Set_Temperature
          gosub Temperature_Offset
        next ic  
      endif
    'endif      
    elseif RS485Message="B" then                'Broadcast message received
      if mode="I" then
        gosub rs485_receive_init
      endif  
    endif
    pointerser1=0
  endif  
return

Sent_output:
  if mode_com=1 and AutResponse=1 then    'only in API mode and when Auto Response Output "RO" bit is set
    cid=0
    gosub RO_linux2                       'Send RO instruction to Master controller
  endif            
  if mode_com=1 and AutResponseOL=1 then  'only in API mode and when Auto Response Output "OL" List bit is set
    cid=0
    gosub send_OL
  endif
  write_yes_mod[ic-1]=0  
return

RS485_Fault:
  if TimeOutSer1=1 then                     'Time out error in module response
    TimeOutSer1=0
    If CatchAll=1 then                      'Please also interprete not fully received messages
      if pointerser1>CatchAllByte then
        Interpreteser1=1                    'Check if the message can be interpreted undough not enough characters came in
      else 
        gosub RS485_Fault_Sub
      endif
    else
      gosub RS485_Fault_Sub
    endif                    
  endif 
return

RS485_Fault_Sub:
  pointerser1=0
  RS485busy=0
  T0CON.7=0                                 'timer 0 disabled
  if Rs485message="I" then                  'Last message was input
    i=pollNr
    error_ID[0]= Mod_ID0[i-1]               'Input device is not responding
    error_ID[1]= Mod_ID1[i-1]
    error_ID[2]= Mod_ID2[i-1]
    error_ID[3]= Mod_ID3[i-1]
    ErrorTmp=i-1
    error_code = 7
    cid=0
    Gosub Add_ErrorCount
    gosub send_error           
  endif
  if Rs485message="O" then                  'Last message was an output
    i=pollNrOut
    error_ID[0]= Mod_ID0[29+i]              'Device is not responding
    error_ID[1]= Mod_ID1[29+i]
    error_ID[2]= Mod_ID2[29+i]
    error_ID[3]= Mod_ID3[29+i]
    ErrorTmp=29+i
    error_code = 8
    Gosub Add_ErrorCount
    gosub send_error              
  endif    
  'if Rs485message="F" then                  'Last message was a Firmware message
  '            
  'endif
Return

prepare_rs485_receive:
  'pauseus 100
  if Rs485message="F" then
    T0CON = %00000111
  else
    T0CON = %00000100
  endif   
  low RS485_mode                            'Receive mode
  RS485busy=1 
  RCSTA1.4=1                                'enable receiving serial 1
  TMR0L=0                                   'reset value
  TMR0H=0
  T0CON.7=1                                 'timer 0 enabled
  TimeOutSer1=0
Return

Read_eeprom_data:
  if syncEnable=1 then
    'if OledDataOk=1 then
    'delete
    'hserout2 [dec OledEeprom.byte1," ",dec OledEeprom.byte0," ",dec OledEepromBit,13,10]
    if OledEepromBit=0 then
      OledEeprom.byte0 = OledEeprom.byte0 + 1
    else
      OledEepromBit=0
      OledEeprom.byte0 = 0
      if EepPage0=1 and OledEeprom.byte1=0 then
        EepPage0=0       
        OledEeprom.byte1 = 33       'First do the output pages so the CAN control leds works almost immeadiatly          
      else
        OledEeprom.byte1 = OledEeprom.byte1 + 1
      endif
      'delete
      'hserout2 ["P",dec OledEeprom.byte1," ",dec OledEepromBit," ",dec EepPage0,13,10] 
    endif
    'endif
    eep_addr.byte1 = OledEeprom.byte1 'page
    eep_addr.byte0 = OledEeprom.byte0 'byte
    Gosub read_eeprom
    oleddata=i2cdata
    OledDataOk=1                      'Data is OK
    if mode_com=0 and syncdebug=1 then
      hserout2 ["Sync P",dec3 OledEeprom.byte1,"/",dec3 OledEeprom.byte0,"=",dec oleddata,13,10]
    endif
    if OledEeprom.byte0 = 255 then 
      OledEepromBit=1
    endif
  else
    OledDataOk=0
  endif      
return  

'For more information regarding the implemented RS485 protocol see http://wiki.openmotics.com/index.php/Master_RS485_Cummunication_Protocol
RS485_poll:
  'if BootLoaderMode=0 then
    if PollCheck=0 then
      if RS485busy=0 and controller_in>0 then  'Bus is not busy
      'if RS485busy=0 then  'Bus is not busy
        if pollTimeInput=0 then             'No need to wait for next input module instruction?
          pollTimeInput=WaitTimeInput
          pollNr=pollNr+1
          if pollNr>controller_in then 
            pollNr=1
            TemperatureCount=0              'If temperature module are spread between input modules
            CheckTemp=1                     'make sure the temperature number is from 0 to 31
            gosub Read_eeprom_data          'Read new byte from eeprom and sent it to the input modules (CAN) and Oled module
            PollCheck=1                     'Check IF No Outputs needs communication
          endif    
          RS485Message="I"
          i=pollNr
          if ErrorBit[i-1]=0 then             'Number of module errors are not yet achieved
            if Mod_ID0[i-1]="I" then          'Input Module
              Gosub sent_input    
            elseif Mod_ID0[i-1]="T" then      'Temperature module, measure ADC
              high RS485_mode                 'Send mode
              z=2
              gosub calc_indicate
              if CheckTemp=1 then
                TempCom=TempCom+1
                CheckTemp=0
              endif  
              if TempCom>2 then TempCom=0
              if TempCom=0 then u="A"
              If TempCom=1 then u="T"
              if TempCom=2 then u="H"
              e[0]=Mod_ID0[i-1]
              e[1]=Mod_ID1[i-1]
              e[2]=Mod_ID2[i-1]
              e[3]=Mod_ID3[i-1]
              e[4]=u
              e[5]=y
              e[6]=0
              e[7]=0
              e[8]=0
              gosub send_rs485_short
              gosub prepare_rs485_receive
            elseif Mod_ID0[i-1]="C" then      'CAN Module 
              gosub sent_input               
            elseif Mod_ID0[i-1]="L" then      'Remote Oled display
              high RS485_mode
              e[0]=Mod_ID0[i-1]
              e[1]=Mod_ID1[i-1]
              e[2]=Mod_ID2[i-1]
              e[3]=Mod_ID3[i-1]
              e[4]="I"
              e[5]=OledEeprom.byte1
              e[6]=OledEeprom.byte0
              e[7]=oleddata
              e[8]=ThermostatCounter
              e[9]=Setpt[ThermostatCounter]
              e[10]=ThermostatMode
              e[11]=TemperatureCounter
              e[12]=Temperature[TemperatureCounter]
              e[13]=OledActionType
              e[14]=OledActionNumber
              e[15]=hours
              e[16]=minutes
              e[17]=days
              gosub send_rs485_long
              gosub prepare_rs485_receive                    
            endif
          endif  
        endif 
      endif 
    endif
  'endif      
return

sent_input:
  z=1                             'Calculate Indicate for Input
  high RS485_mode     
  gosub Calc_indicate
  e[0]=Mod_ID0[i-1]
  e[1]=Mod_ID1[i-1]
  e[2]=Mod_ID2[i-1]
  e[3]=Mod_ID3[i-1]
  e[4]="I"
  e[5]=y
  e[6]="F"
  e[7]=InputFilter
  if OledDataOk=1 then
    e[8]="E"
    e[9]=OledEeprom.byte1           'page
    e[10]=OledEeprom.byte0          'byte
    e[11]=oleddata
  endif  
  gosub send_rs485_long
  gosub prepare_rs485_receive
return                       

RS485_output:
  'if BootLoaderMode=0 then
  if PollCheck=1 then
    if write_yes=1 and controller_out>0 then  
      if RS485busy=0 then   'Bus is not busy 
        if pollTimeOutput=0 then            'No need to wait for next output module instruction?
          pollNrOut=pollNrOut+1
          if pollNrOut>controller_out then 
            pollNrOut=1
            PollCheck=2                     'First check outputRS modules
          endif  
          i=pollNrOut       
          if Mod_ID0[29+i]="O" or Mod_ID0[29+i]="D" or Mod_ID0[29+i]="R" then          
            if ErrorBit[29+i]=0 then             'Number of module errors are not yet achieved    
              if write_yes_mod[i-1]=1 then     
                RS485Message="O"
                pollTimeOutput=WaitTimeOutput      
                z=0                             'Calculate Indicate for Output
                gosub Calc_indicate
                CRC2=out[i-1]+y+dimmer_value[(i-1)*8]+dimmer_value[((i-1)*8)+1]+dimmer_value[((i-1)*8)+2]+dimmer_value[((i-1)*8)+3]
                CRC2=CRC2+dimmer_value[((i-1)*8)+4]+dimmer_value[((i-1)*8)+5]+dimmer_value[((i-1)*8)+6]+dimmer_value[((i-1)*8)+7]
                high RS485_mode                 'Send mode
                e[0]=Mod_ID0[29+i]
                e[1]=Mod_ID1[29+i]
                e[2]=Mod_ID2[29+i]
                e[3]=Mod_ID3[29+i]
                e[4]=out[i-1]
                e[5]=y
                e[6]=dimmer_value[(i-1)*8]
                e[7]=dimmer_value[((i-1)*8)+1]
                e[8]=dimmer_value[((i-1)*8)+2]
                e[9]=dimmer_value[((i-1)*8)+3]
                e[10]=dimmer_value[((i-1)*8)+4]
                e[11]=dimmer_value[((i-1)*8)+5]
                e[12]=dimmer_value[((i-1)*8)+6]
                e[13]=dimmer_value[((i-1)*8)+7]
                e[14]="C"
                e[15]=CRC2.byte1
                e[16]=CRC2.byte0
                gosub send_rs485_long
                gosub prepare_rs485_receive
                'gosub check_write_yes
                'hserout2 [" ",dec i]
              endif  
            endif
          else
            if write_yes_mod[i-1]=1 then        
              gosub send_virtual_output
            endif  
          endif   
        endif
        'hserout2 [" ",dec i,13,10]
        gosub check_write_yes   
      endif
    else           'No Outputs to Check
      PollCheck=2  'Check OutputRS
    endif
  endif    
return

check_write_yes:
  i_bit=0
  for t=1 to controller_out             'check if any output still needs to be addressed
    i_bit=i_bit|write_yes_mod[t-1]
  next t
  write_yes=i_bit
  if write_yes=0 then PollCheck=2 
return


send_virtual_output:
  if Mod_ID0[29+i]="o" or Mod_ID0[29+i]="d" or Mod_ID0[29+i]="r" then
    ic=i
    gosub sent_output
    i2caddr = 8+i
    i2cdata = out[i-1]                'put out(i) in clock ram
    gosub write_i2c_2
    'gosub check_write_yes
    RS485Message="O"
    pollTimeOutput=WaitTimeOutput      
    CRC2=out[i-1]+y+dimmer_value[(i-1)*8]+dimmer_value[((i-1)*8)+1]+dimmer_value[((i-1)*8)+2]+dimmer_value[((i-1)*8)+3]
    CRC2=CRC2+dimmer_value[((i-1)*8)+4]+dimmer_value[((i-1)*8)+5]+dimmer_value[((i-1)*8)+6]+dimmer_value[((i-1)*8)+7]
    high RS485_mode                 'Send mode
    e[0]=Mod_ID0[29+i]
    e[1]=Mod_ID1[29+i]
    e[2]=Mod_ID2[29+i]
    e[3]=Mod_ID3[29+i]
    e[4]=out[i-1]
    e[5]=y
    e[6]=dimmer_value[(i-1)*8]
    e[7]=dimmer_value[((i-1)*8)+1]
    e[8]=dimmer_value[((i-1)*8)+2]
    e[9]=dimmer_value[((i-1)*8)+3]
    e[10]=dimmer_value[((i-1)*8)+4]
    e[11]=dimmer_value[((i-1)*8)+5]
    e[12]=dimmer_value[((i-1)*8)+6]
    e[13]=dimmer_value[((i-1)*8)+7]
    e[14]="C"
    e[15]=CRC2.byte1
    e[16]=CRC2.byte0
    gosub send_rs485_long
    'gosub prepare_rs485_receive   -> No feedback expected, this message is only to be sent out for the CAN Control modules
    'gosub check_write_yes
    gosub check_group
    'hier
    pause 5
  endif
return

'hier
Check_group:
  for m=0 to 7
    n=((i-1)*8)+m
    if out_update[n]=1 then
      out_update[n]=0
      eep_addr.byte1=112                    'page 112
      eep_addr.byte0=n                      'Output Nr
      gosub read_eeprom
      'hserout2 ["Update Output ",dec n,"->",dec i2cdata," dim_value=",dec dimmer_value[n],13,10]
      if i2cdata<32 then                    'Valid group
        broad1="G"                          'Group message broadcast
        broad2=i2cdata                      'Group Number
        GroupNr=i2cdata
        x=out[i-1]>>m
        if x.bit0=1 then                    'Output is ON
          broadData=4*dimmer_value[n]       'Dim Value
          GroupDimValue=4*dimmer_value[n]
          GroupOn=1
          'hserout2 [" Output ON ",dec dimmer_value[n],13,10]
        else                                'Output if OFF
          broadData=0                       'Dim Value
          GroupDimValue=0
          GroupOn=0
          'hserout2 [" Output OFF",13,10]
        endif        
        broadId="C"                         'CAN modules only
        gosub send_broad 
        gosub Set_Dali_outputs
      endif  
    endif
  next m    
return

Get_ID:
  for x=0 to 3
    eep_addr.byte1 = 32+i         'page
    eep_addr.byte0 = 173+x
    gosub read_eeprom
    digit[x]=i2cdata
  next x
Return

RS485_outputRS:
  'if BootLoaderMode=0 then
  if PollCheck=2 then
    if write_yes_RS=1 then
      if RS485busy=0 then   'Bus is not busy 
        if pollTimeOutput=0 then            'No need to wait for next output module instruction?
          pollNrOutRS=pollNrOutRS+1
          if pollNrOutRS>controller_out_RS then pollNrOutRS=1
          i=pollNrOutRS    
          if write_yes_modRS[i-1]=1 then      
            RS485Message="R"
            pollTimeOutput=WaitTimeOutput      
            z=0                             'Calculate Indicate for Output
            gosub Calc_indicate
            CRC2=outRS[i-1]+y
            gosub Get_ID                        
            high RS485_mode                 'Send mode
            e[0]=digit[0]
            e[1]=digit[1]
            e[2]=digit[2]
            e[3]=digit[3]
            e[4]=outRS[i-1]
            e[5]=y
            e[6]=0
            e[7]=0
            e[8]=0
            e[9]=0
            e[10]=0
            e[11]=0
            e[12]=0
            e[13]=0
            e[14]="C"
            e[15]=CRC2.byte1
            e[16]=CRC2.byte0
            gosub send_rs485_long
            gosub prepare_rs485_receive
            write_yes_modRS[i-1]=0      'Disable 
          endif  
        endif 
      endif
      i_bit=0
      for i=1 to controller_out_RS             'check if any output still needs to be addressed
        i_bit=i_bit|write_yes_modRS[i-1]
      next i
      write_yes_RS=i_bit  
      if write_yes_RS=0 then PollCheck=0
    else                                       'No Outputs to check
      PollCheck=0                              'Check inputs
    endif
  endif  
return

Communicate_Oled:
  if rs485string[0]=Mod_ID0[i-1] and rs485string[1]=Mod_ID1[i-1] and rs485string[2]=Mod_ID2[i-1] and rs485string[3]=Mod_ID3[i-1] then
    if rs485string[6]<>255 and Pointerser1>7 then  'Action type is valid 
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=rs485string[6]
      queue_action[queue_pointer]=rs485string[7]
      OledInstr0=rs485string[8]
      OledInstr1=rs485string[9]  
    endif  
  else
    error_ID[0]= Mod_ID0[i-1]               'Input device is not responding
    error_ID[1]= Mod_ID1[i-1]
    error_ID[2]= Mod_ID2[i-1]
    error_ID[3]= Mod_ID3[i-1]
    ErrorTmp=i-1
    error_code = 7
    cid=0
    Gosub Add_ErrorCount
    gosub send_error  
  endif
return


Communicate_CAN:
  if rs485string[1]<>Mod_ID1[i-1] or rs485string[2]<>Mod_ID2[i-1] or rs485string[3]<>Mod_ID3[i-1] then  'wrong device responded
    Gosub Error_10       
  endif
return

Communicate_input:
  if rs485string[1]=Mod_ID1[i-1] and rs485string[2]=Mod_ID2[i-1] and rs485string[3]=Mod_ID3[i-1] then
    if ForceCRC=1 then                      'CRC check is active at input slave module
      CRC2=rs485string[4]+rs485string[5]+rs485string[6]+rs485string[7]+rs485string[8]+rs485string[9]
      if CRC2.byte1=rs485string[10] and CRC2.byte0=rs485string[11] then  'CRC is correct
        gosub Analyse_input
      else                                  'CRC is wrong
        error_ID[0]= Mod_ID0[i-1]           'Input device is responding but with wrong CRC
        error_ID[1]= Mod_ID1[i-1]
        error_ID[2]= Mod_ID2[i-1]
        error_ID[3]= Mod_ID3[i-1]
        ErrorTmp=i-1
        error_code = 27                     'Wrong CRC or CRC information is missing
        cid = 0
        Gosub Add_ErrorCount
        gosub send_error  
      endif  
    else
      gosub Analyse_input
    endif
  else                                      'wrong device responded
    Gosub Error_10   
  endif                                                            
return

Error_10:
    error_ID[0]= Mod_ID0[i-1]               'Input device is not responding
    error_ID[1]= Mod_ID1[i-1]
    error_ID[2]= Mod_ID2[i-1]
    error_ID[3]= Mod_ID3[i-1]
    ErrorTmp=i-1
    error_code = 10
    cid = 0
    Gosub Add_ErrorCount
    gosub send_error 
return

Analyse_Input:
  inp[i-1]=~Rs485string[4]
  inp[i-1]=inp[i-1]^~inp_invert[i-1]        'When inverted inputs are used, set inp[i-1] right and invert
  x=inp[i-1]^inp_old[i-1] 
  if x<>0 then                              'Input has changed
    for t=0 to 7                            'Check which input is activated
      v=((i-1)*8)+t
      q=sel_output[v]     
      if InputEnable[v]=1 then              'input enabled?
        m=inp[i-1]>>t                       'Check current input state
        n=inp_old[i-1]>>t                   'Check old input state   
        if m.bit0=1 and n.bit0=0 then       'Button pressed                 
          gosub Rs232_message
          if Switch_type[v]=1 then          'switch type normal
            if mod_ID0[30+(q/8)]<>"D" and mod_ID0[30+(q/8)]<>"d" then  'Only for Non dimmers                       
              input_pressed=v
              gosub input_action
            else                            'Switch on Dimmer output at button release            
              press_time[v]=1                
            endif
          else                              'switch type toggle          
            input_pressed=v
            gosub input_action
          endif              
        elseif m.bit0=0 and n.bit0=1 then   'Button released
          if Switch_type[v]=1 then          'Switch type normal
            if press_time[v]>0 and press_time[v]<dim_cycle then
              if dimmer_mem=0 then          'No memory function
                dimmer_value[q]=63          'Light at maximum
                out_update[q]=1
              endif
              gosub input_action            
            endif
          else                              'switch type toggle
            gosub Rs232_message
            input_pressed=v
            gosub input_action
          endif            
        endif            
      endif
    next t   
  else                                      'Input has not changed
    for t=0 to 7                            'Check which input is activated
      v=((i-1)*8)+t
      q=sel_output[v]     
      if InputEnable[v]=1 then              'input enabled?
        if switch_type[v]=1 then            'Only for push button switches
          m=inp[i-1]>>t                     'Check current input state
          if m.bit0=1 then                  'Button remains pressed
            gosub Input_dimmer_action 
          endif
        endif  
      endif    
    next t
  endif
  inp_old[i-1]=inp[i-1]
  gosub check_pulsecounter    
return

RS232_message:
  if InputDebug=1 then
    hserout2 ["Input pressed=",dec v," selected output=",dec q,13,10]
  endif
  if mode_com=1 and AutResponseIL=1 then    'only in API mode and when Auto Response Output List bit is set
    gosub send_IL
  endif 
return

Input_action:
  press_time[v]=0
  if q<240 then                             'Input toggle or dim must be activated
    gosub Increase_queue_pointer
    queue_type[queue_pointer]=162           'toggle
    queue_action[queue_pointer]=q        
  else
    if q=240 then                           'Input action list must be loaded
      CurrentInput=v
      queue_module_nr=i
      queue_input_nr=t
      gosub fill_queue         
    endif
    if q=241 then                           'All outputs including lights off
      gosub all_outputs_off
    endif
    if q=242 then                           'All lights off
      level=255
      gosub all_lights_off     
    endif
  endif
return

Input_Dimmer_action:
  if ((mod_ID0[30+(q/8)]="D" or mod_ID0[30+(q/8)]="d")and q<240) then   'For dimmer outputs with toggle function only
    if press_time[v]<dim_cycle then         'Not yet start dimming
      press_time[v]=press_time[v]+1
      if press_time[v]=dim_cycle then
        dim_direction[q]=~dim_direction[q]  'Toggle dim direction
        if dimmer_value[q]=63 then
          dim_direction[q]=0                'dim down
        endif
        if dimmer_value[q]<=dim_minimum then
          dim_direction[q]=1                'dim up
        endif        
      endif                       
    else                                    'Start dimming
      if dim_direction[q]=1 then            'dim up
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=154+dim_step-1    'dim up
        queue_action[queue_pointer]=q 
      else                                  'dim down
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=157+dim_step-1    'dim down
        queue_action[queue_pointer]=q       
      endif
    endif   
  endif
return

Check_PulseCounter:
  if rs485string[5]="P" then                'PulseCounter Information is available
    x=rs485string[6]                        'Which input counter information is sent over
    if x<8 then
      y=((i-1)*8)+x
      for t=0 to (NumberPulseCounters-1)
        if PulseInput[t]=y then
          t_word.byte1=rs485string[7]
          t_word.byte0=rs485string[8]
          PulseCounter[t]=t_word
          t=NumberPulseCounters-1
        endif  
      next t
    endif
  endif
return

Add_ErrorCount:
  If ErrorCount[ErrorTmp]<64999 then ErrorCount[ErrorTmp]=ErrorCount[ErrorTmp]+1
return

empty_e:
  for ti=0 to 19
    e[ti]=0
  next ti
return

rs485_receive_init:                         'Routine used when in initialization mode (mode="I")
  if mode_com=1 then                        'advanced mode
    if rs485string[4]="E" and rs485string[5]="I" then    'Erase ID
      gosub empty_e
      e[0]="E"
      e[1]="I"
      e[2]=0
      e[3]=RS485string[0]
      e[4]=RS485string[1]
      e[5]=RS485string[2]
      e[6]=RS485string[3]
      gosub send_api
    endif
  endif
  gosub Check_duplicates
  gosub Add_modules
  InterpreteSer1=0
  RCSTA1.4=1                                'enable receiving serial 1
  gosub bus_init                            'Generate new ID's for non-initialized modules  
return  

Check_duplicates:
  if LargeInstallation=1 and RS485string[0]="R" then                            'Shutter in a large installation
    a=controller_out_rs
    b=33                   'start page in eeprom
    c=173                  'start byte (ID0) in eeprom
    d=0                    'controller_out_rs used
  elseif RS485string[0]="D" or RS485string[0]="O" or RS485string[0]="R" then    'Output module 
    a=controller_out
    b=33                   'start page in eeprom
    c=0                    'start byte (ID0) in eeprom 
    d=1                    'controller_out used   
  else                                                                           'Input module
    a=controller_in
    b=2                    'start page in eeprom
    c=0                    'start byte (ID0) in eeprom
    d=2                    'controller_in used    
  endif
  DuplicateID=0
  if a>0 and a<30 then     'Max 30 modules
    for ic=1 to a
      DuplicateID=1
      for x=0 to 3
        eep_addr.byte1 = b+ic-1     'page
        eep_addr.byte0 = c+x
        Gosub read_eeprom
        if i2cdata<>RS485string[x] then
          DuplicateID=0
        endif
      next x
      if duplicateID=1 then 
        z=ic
        ic=a     'exit
      endif 
    next ic
  else
    if a>29 then a=0
  endif  
return

Add_modules:                'uses variable a, b, c and d from sub check_duplicates
  if DuplicateID=0 then     'No duplicate
    gosub add_m        
  else                      'duplicate
    if rs485string[5]="N" then    
      if mode_com=0 then
        hserout2 ["New module with duplicate ID found, generating new ID, please press button again",13,10]
      else
        gosub empty_e
        e[7]="D"                               'instruction
        gosub MI_linux
      endif
      error_code = 26
      gosub send_error
      gosub bus_init                        'initialize bus again, all non programmed ID's are generated again
    else
      if mode_com=0 then                    'CLI mode
        gosub existing_module_CLI
      else
        gosub existing_module
      endif  
    endif
  endif
return

existing_module_CLI:
  a=~rs485string[4]
  if RS485string[0]="D" or RS485string[0]="O" or RS485string[0]="R" then 
    hserout2 ["output ",RS485string[0],dec z-1," ",dec (z-1)*8,"->",dec ((z-1)*8)+7,13,10]
  elseif RS485string[0]="I" or RS485string[0]="B" then 
    hserout2 ["input ",RS485string[0],dec z-1," ",dec (c*8)+b," "]
    a=(c*8)+b
    length=8
    Spaces=0 
    gosub eeprom_input_address
    gosub display_name
    gosub display_LF_CR
  elseif RS485string[0]="L" then 
    hserout2 ["OLED screen ",RS485string[0],dec z-1,13,10] 
  elseif RS485string[0]="T" then
    hserout2 ["Temp/Hum/ADC ",RS485string[0],dec z-1,13,10]                
  elseif RS485string[0]="C" then
    hserout2 ["CAN Control ",RS485string[0],dec z-1,13,10]
  endif   
return

add_m:                      'uses variable a, b, c and d from sub check_duplicates
  if a<29 then              'Module can still be added
    e=RS485string[0]
    'or e="i" or e="o" or e="d"
    if RS485string[0]="I" or RS485string[0]="T" or RS485string[0]="L" or RS485string[0]="O" or RS485string[0]="D" or RS485string[0]="R" then
      gosub add_m_sub
    endif
    if RS485string[0]="i" or RS485string[0]="o" or RS485string[0]="d" or RS485string[0]="C"  then    'Virtual modules
      gosub add_m_sub
    endif    
  else                      'Maximum number of modules is reached
    if mode_com=0 then                      'CLI mode
      hserout2 ["Max # of modules reached on the bus, module not added",13,10]
    endif
  endif   
return

add_m_sub:
  for x=0 to 3
    eep_addr.byte1 = b+a  'page
    eep_addr.byte0 = c+x
    i2cdata = RS485string[x]
    gosub write_eeprom
  next x
  eep_addr.byte1 = 0      'page
  i2cdata = a+1
  if d=0 then             'program controller_out_rs in eeprom
    eep_addr.byte0 = 3  
  elseif d=1 then         'program controller_out in eeprom
    eep_addr.byte0 = 2  
  else                    'program controller_in in eeprom
    eep_addr.byte0 = 1  
  endif
  gosub write_eeprom
  eep_addr.byte1 = b+a          'page
  eep_addr.byte0 = 252  
  if RS485string[6]="T" then      'Type is also received in the message
    if RS485string[7]<>255 then   'different type then std input or temp module is received
      i2cdata = RS485string[7]
    endif  
  else
    i2cdata = 255     
  endif
  gosub write_eeprom  
  Gosub Read_Controller_InOut     'Copy eeprom values into RAM
  gosub add_m_comm        'send message about module add
return

add_m_comm:
  a=~rs485string[4]
  if mode_com=0 then                    'CLI mode 
    hserout2 ["New module found with ID:",dec RS485string[0],".",dec rs485string[1],".",dec rs485string[2],".",dec rs485string[3]," LI ",dec d,13,10] 
    hserout2 ["Type ",RS485string[0],dec v," ",bin8 a,13,10]
  else                                  'API mode
    gosub empty_e
    e[7]="N"                               'instruction
    gosub MI_linux
    pause 100
    gosub empty_e
    e[7]="E"                               'instruction
    e[8]=controller_in                     'module number
    e[9]=a                                 'data
    gosub MI_linux      
  endif
  serstring[3]=rs485string[0]
  serstring[4]=rs485string[1]
  serstring[5]=rs485string[2]
  serstring[6]=rs485string[3]
  gosub activate_device
return

Existing_module:
  gosub empty_e  
  e[7]="E"                                     'instruction
  e[8]=c                                       'module number
  e[9]=a                                       'data
  gosub MI_linux 
return

MI_linux:
  pause 10
  e[0]="M"
  e[1]="I"
  e[2]=0
  e[3]=RS485string[0]
  e[4]=RS485string[1]
  e[5]=RS485string[2]
  e[6]=RS485string[3]
  e[10]=d
  gosub send_api
return

Calc_indicate:     
  x=indicate/8
  if IndicateTemperature=0 then             'do the calc for non temperature modules
    if (i-1)=x then                         'led needs indication
      y=indicate//8
      gosub all_leds_off
    else
      y=255
    endif
  else                                      'do the calc for temperature modules
    if temperaturecount=x then              'led needs indication
      y=indicate//8
      gosub all_leds_off
    else
      y=255
    endif  
  endif  
  if (IndicateInput=1 or IndicateTemperature=1) and z=0 then y=255
  if (IndicateInput=0 or IndicateTemperature=1) and z=1 then y=255 
  if IndicateTemperature=0 and z=2 then y=255 
  if y<>255 then indicate=255  
return

All_leds_off:
    broad1="l"                              'Led
    broad2="O"                              'On/Off
    BroadID="C"                             'For CAN modules only
    broadData=0                             '0=All leds off
    gosub send_broad 
return

Output_debug:
  if debugmode=1 then
    q=OdOutputNr
    gosub check_output                      'check if output is on, q must contain output nr  
    Hserout2 [dec days," ",dec2 hours,":",dec2 minutes," OD Information",13,10,"OD Code:",dec OdCode," Output Nr:",dec OdOutputNr]
    if z.bit0=0 then
      hserout2 [" OFF",13,10]
    else
      hserout2 [" ON",13,10]
    endif     
    hserout2 ["Timer Value:",dec Timer_cd[odOutputNr]," Dimmer Value:",dec dimmer_value[odoutputNr],13,10]
  endif
return

'------------------------------------------------------------------------------
' Intelligent functions
' See http://wiki.openmotics.com/index.php/Action_Types
'------------------------------------------------------------------------------

' Fill Queue ------------------------------------------------------------------

fill_queue:                                 'read all the intelligent actions from the input page and put them in the action queue
  gosub Increase_queue_pointer
  queue_type[queue_pointer]=4               'Indicate in the queue which input has triggered the actions, to be used to activate group actions when input is pressed for x seconds 
  queue_action[queue_pointer]=CurrentInput 
  AddToQueue=1
  gosub input_action_eeprom   
return

Input_action_eeprom:
eep_addr.byte1 = queue_module_nr+1          'start from page 2
  for queue_counter=0 to 14                 'max 15 intelligent functions to read
    eep_addr.byte0 = (queue_input_nr*30)+(queue_counter*2)+12
    Gosub read_eeprom  
    f0=i2cdata
    eep_addr.byte0 = eep_addr.byte0 + 1
    gosub read_eeprom
    f1=i2cdata    
    if AddToQueue=1 then
      if f0<>255 then
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=f0
        queue_action[queue_pointer]=f1 
      else
        queue_counter=14                    'abort routine
      endif
    else                                    'when used by API instruction "ri"
      Hserout2 [f0,f1]
      CRC=CRC+f0+f1
    endif
  next queue_counter    
return

' Check Queue -----------------------------------------------------------------

check_queue:
  if queue_pointer>0 then                   'something in the queue
    low led_red
    CurrentInput=255  
    for i=1 to queue_pointer                'check all queue entries
      queue_bit=queue_type[i]
      queue_temp=queue_action[i]
      if debugmode=1 then                   'Debug info 
        Hserout2 ["Execute queue action ",dec i,"/",dec queue_pointer, ": ",dec queue_bit," ",dec queue_temp,13,10]
      endif
      if queue_type[i]=235 then             'execute delayed action                                                              
        DelayedTime=queue_action[i]
      endif
      if queue_type[i]=236 then             'execute action at button release state
        if queue_action[i]=0 then
          ActionButtonRelease=1
        else
          ActionButtonRelease=0
        endif
      endif          
      if queue_type[i]=240 then             'IF THEN ELSE Instructions
        IfInstr=Queue_action[i]
      endif        
      if (queue_type[i]=1 or queue_type[i]=9 or queue_type[i]=17) and (IfInstr<10) then         'call simple decision
        gosub simple_decision 
      elseif queue_type[i]=4 then           'Remember which input has triggered the current actions
        CurrentInput=Queue_Action[i]                                                 
      elseif (queue_type[i]=25 or queue_type[i]=49 or queue_type[i]=57) and (IfInstr<10) then   'call simple decision
        gosub simple_decision   
      elseif queue_type[i]>240 and queue_type[i]<245 and queue_action[i]<240 then               'Check Input/output
        gosub Check_InpOutp      
      elseif queue_type[i]>244 and queue_type[i]<248 then                                       'Check Validation Bit, temperature, humidity, setpoint etc
        gosub Check_InpOutp                                                                                 
      endif
      if (IfInstr=255) or (IfInstr=10 and decision_new=1) or (IfInstr=20 and decision_new=0) then  'execute these instruction only when IF THEN is not active OR when "then" is valid OR when "else" is valid        
        if ActionButtonRelease=0 then       'check if action must be performed immeadiatly or at button release
          if DelayedTime>0 and DelayedTime<250 and queue_type[i]<>235 and queue_type[i]<>236 then              
            gosub add_timer_queue           'Delayed action
          else
            gosub check_queue_sub           'immeadiate action
          endif  
        else
          if queue_type[i]<>235 and queue_type[i]<>236 then           
            gosub add_timer_queue           'action at button release -> copy to the timer_queue
          endif
        endif  
      endif  
      if queue_pointer>(queue_max-2) then   'queue overflow -> exit
        i=queue_pointer                     'exit loop
        error_ID[0]= 0                      'Error code for queue overflow
        error_ID[1]= 0
        error_ID[2]= 0
        error_ID[3]= 0
        error_code = 13
        gosub send_error 
      endif                
    next i
  queue_pointer=0                           'empty queue
  ToggleFollowON=0                          'Toggle follow function off
  ToggleFollowActive=0
  endif
return

check_queue_sub:
  if queue_type[i]=4 then                   'Remember which input has triggered the current actions
    CurrentInput=Queue_Action[i]    
  elseif queue_type[i]>159 and queue_type[i]<174 then 'Output ON/OFF/Toggle/All light off/all off function
    Gosub output_OnOff
  elseif queue_type[i]>206 and queue_type[i]<212 then 'Execute group action when input is pressed longer than x seconds
    Gosub Timer_group         
  elseif queue_type[i]>127 and queue_type[i]<144 then 'Thermostat function        
    gosub Thermostat_action  
  elseif queue_type[i]>144 and queue_type[i]<150 then 'Thermostat function        
    gosub Thermostat_action
  elseif queue_type[i]>89 and queue_type[i]<94 then  'Thermostat function Multi-Tenant        
    gosub Thermostat_action    
  elseif queue_type[i]=68 then              'Virtual input press
    gosub Virtual_input_press
  elseif queue_type[i]=69 then              'Virtual input release
    gosub Virtual_input_release             
  elseif queue_type[i]=0 then               'call simple action
    gosub simple_action 
  elseif queue_type[i]=2 then               'call group action
    gosub group_action
  elseif queue_type[i]=174 then             'Toggle Follow ON
    ToggleFollowOn=1
    ToggleFollowActive=0 
  elseif queue_type[i]=175 then             'Toggle Follow OFF
    ToggleFollowOn=0
    ToggleFollowActive=0 
  elseif queue_type[i]>175 and queue_type[i]<207 then                   'Output ON/Toggle function at 10%-100% dimmer value or timer value
    Gosub output_OnOff
  elseif queue_type[i]>153 and queue_type[i]<160 then                   'Dim output (up or down) with 1, 2 or 3 steps
    Gosub output_dim         
  elseif queue_type[i]=1 or queue_type[i]=9 or queue_type[i]=17 then    'call simple decision
    gosub simple_decision                         
  elseif queue_type[i]=25 or queue_type[i]=49 or queue_type[i]=57 then  'call simple decision
    gosub simple_decision    
  elseif queue_type[i]=3 or queue_type[i]=7 then                        'call scheduled action
    if queue_type[i]=3 then
      gosub scheduled_action
    else
      digitcount=1
      digittotal[0]=queue_temp
      ok=0
      gosub schedule_queue_delete
      ok=1
    endif                                             
  elseif queue_type[i]=64 then              'Switch on/off leds
    if queue_action[i]=0 then
      gosub low_Powerstate
    endif
    if queue_action[i]=1 then
      gosub normal_Powerstate
    endif
    if queue_action[i]=2 then
      gosub normal_Powerstate_2
    endif
  elseif queue_type[i]>99 and queue_type[i]<112 then 'Store/Shutter action in Large Installations
    Gosub StoreShutter_action    
  elseif queue_type[i]=65 then              'Output indicate
    gosub Queue_output_indicate
  elseif queue_type[i]=66 then              'Input indicate
    gosub Queue_input_indicate
  elseif queue_type[i]=67 then              'Sensor indicate
    gosub Queue_sensor_indicate    
  elseif queue_type[i]=116 then             'Disable Input x
    if Queue_temp<240 then InputEnable[Queue_temp]=0        
  elseif queue_type[i]=117 then             'Enable Input x
    if Queue_temp<240 then InputEnable[Queue_temp]=1            
  elseif queue_type[i]=118 then             'reset PulseCounter x
    gosub reset_pulsecounter         
  elseif queue_type[i]>119 and queue_type[i]<127 then   'Set Free variables        
    gosub Set_Free_Variables             
  elseif queue_type[i]>231 and queue_type[i]<235 then   'Switch On/Off Oled (234), enable/disable touchscreen (233), set time out (232)
    OledActionType=queue_type[i]
    OledActionNumber=queue_action[i]
  elseif queue_type[i]>211 and queue_type[i]<220 then
    gosub CAN_Leds    
  elseif queue_type[i]=237 then             'Set Validation Bit
    Val_bit[Queue_temp]=1
  elseif queue_type[i]=238 then             'Clear Validation Bit
    Val_bit[Queue_temp]=0
  elseif queue_type[i]=239 then             'Toggle Validation Bit   
    i_bit2=Val_bit[Queue_temp]
    toggle i_bit2
    Val_bit[Queue_temp]=i_bit2
  elseif queue_type[i]=70 then              'Switch OFF 5V All Sensor Modules (will switch automatically after 1 minute)
    broad1="P"                              'Power message broadcast
    broad2="F"
    BroadID=0
    gosub send_broad                        'send broadcast on RS485 network 
  elseif queue_type[i]=71 then              'Swicth ON 5V All sensor Modules
    broad1="P"                              'Power message broadcast
    broad2="N"
    BroadID=0
    gosub send_broad                        'send broadcast on RS485 network 
  elseif queue_type[i]=72 then              'Reset Power of all slave modules
    high PowerSlaves                        'Switch off power of all slaves
    pause 4000
    low PowerSlaves                         'Switch on power of all slaves
    for u=1 to controller_out
      write_yes_mod[u-1]=1
    next u
    write_yes=1
    pause 1000
  elseif queue_type[i]=73 then              'Switch DALI group ON
    if queue_action[i]<32 then              'Max 32 groups (0..31)
      broad1="G"                            'Group message broadcast
      broad2=queue_action[i]                'Group Number
      broadData=254                         'Dim Value
      GroupDimValue=254
      broadId="C"                           'CAN modules only
      gosub send_broad
      GroupNr=queue_action[i]
      GroupDimValue=BroadData
      GroupOn=1     
      gosub Set_Dali_outputs
    endif   
    'hier
  elseif queue_type[i]=74 then              'Switch DALI Group OFF
    if queue_action[i]<32 then              'Max 32 groups (0..31)
      broad1="G"                            'Group message broadcast
      broad2=queue_action[i]                'Group Number
      broadData=0                           'Dim Value
      broadId="C"                           'CAN modules only
      gosub send_broad
      GroupNr=queue_action[i]
      GroupDimValue=BroadData
      GroupOn=0
      gosub Set_Dali_outputs
    endif
  elseif queue_type[i]=75 then              'Switch ON power micro CAN modules
    broad1="P"                              'Power message broadcast
    broad2="n"
    BroadID=0
    gosub send_broad                        'send broadcast on RS485 network 
  elseif queue_type[i]=76 then              'Swicth OFF power micro CAN modules
    broad1="P"                              'Power message broadcast
    broad2="f"
    BroadID=0
    gosub send_broad           
  elseif queue_type[i]=79 then              'Is Clean-up of doubles in the Timer Queue enabled or disabled for every new BA added in the timer queue
    if queue_action[i]=0 then               'Clean-up disabled
      CleanTimerQueue=0
    else
      CleanTimerQueue=1  
    endif             
  elseif queue_type[i]=60 then              'Sent Event
    gosub Send_EV    
  elseif queue_type[i]=80 then              'Cooling mode?
    gosub Set_Cooling 
  elseif queue_type[i]=81 then              'Enable/Disable Airco (RTD-10)
    gosub Set_Airco 
  elseif queue_type[i]=82 then              'Set Permanent Manual Mode
    u=0
    gosub SetClear_PermanentManual
  elseif queue_type[i]=83 then              'Clear Permanent Manual Mode
    u=1
    gosub SetClear_PermanentManual        
  elseif queue_type[i]=8 then               'Reset all errors and bring modules that are offline back online
    gosub Reset_error                     
  elseif queue_type[i]=254 then             'reset processor
    asm
      reset
    endasm                                                                   
  endif  
return

'hier
Set_Dali_Outputs:
  for ic=0 to 63                                             'Switch On/Off outputs
    eep_addr.byte1=104+(GroupNr/4)                           'page 104 till 107
    eep_addr.byte0=ic+(64*(GroupNr//4))                      'Maximum 64 outputs per group
    gosub read_eeprom
    'Hserout2 ["Group eep ",dec eep_addr.byte1," ",dec eep_addr.byte0, ": ",dec i2cdata,13,10]
    if i2cdata<240 then                                      'group output
      digittotal[0]=i2cdata
      digittotal[1]=GroupDimValue/4
      if GroupOn=1 then                                         
        digitcount=2
        ok=0
        gosub output_on
        ok=1
      else
        digitcount=1
        ok=0
        gosub output_off
        ok=1
      endif  
    else      
      ic=63                                                  'exit
    endif              
  next ic
return

CAN_Leds:
  if queue_type[i]=218 then                 'Set Minimum brightness 
    broad1="l"                              'Led
    broad2="L"                              'Low
    BroadID="C"                             'For CAN modules only
    broadData=queue_action[i]               'Led value
    gosub send_broad 
  elseif queue_type[i]=219 then             'Set Maximum brightness 
    broad1="l"                              'Led
    broad2="H"                              'High
    BroadID="C"                             'For CAN modules only
    broadData=queue_action[i]               'Led value
    gosub send_broad                        'Set Led
  else                                      'Led
    broad1="l"  
    broad2=queue_type[i]-212
    broadID="C"                             'For CAN modules only
    broadData=queue_action[i]               'Led Nr
    gosub send_broad
  endif  
return

SetClear_PermanentManual:
  a=queue_action[i]
  if (a<24 or (a>31 and a<56)) then        
    eep_addr.byte0=32+a                      'address
    eep_addr.byte1=195                       'page
    i2cdata=u*255
    gosub write_eeprom
    if u=0 then 
      b=1 
    else 
      b=0 
    endif
    if a>31 then 
      c=a-8 
    else 
      c=a 
    endif                      
    PermanentManual[c]=b
  endif
  CID=0
  if mode_com=1 then
    gosub instr_pL
  endif        
return

Check_InpOutp:
  if IfInstr<10 then                        'u will indicate which operator (u=0 -> no operator, u=1 -> AND, u=2 -> OR etc) must be applied
    u=IfInstr
  else
    u=0
  endif
  if queue_type[i]=241 then                 'check if input is on
    v=1                                     'check if input is ON
    w=1                                     'check input
    gosub Set_Decision_new
  elseif queue_type[i]=242 then             'check if input is off
    v=0                                     'check if input is OFF
    w=1                                     'check input
    gosub Set_Decision_new
  elseif queue_type[i]=243 then             'check if output is on
    v=1                                     'check if output is ON
    w=0                                     'check output
    gosub Set_Decision_new 
  elseif queue_type[i]=244 then             'check if output is off
    v=0                                     'check if output is OFF
    w=0                                     'check output
    gosub Set_Decision_new  
  elseif queue_type[i]=245 then             'check if validation bit is on
    v=1                                     'check if output is ON
    w=2                                     'check Validation bit
    gosub Set_Decision_new
  elseif queue_type[i]=246 then             'check if validation bit is off
    v=0                                     'check if output is OFF
    w=2                                     'check Validation bit
    gosub Set_Decision_new
  elseif queue_type[i]=247 and queue_type[i+1]>247 and queue_type[i+1]<251 then  'check temperature or light sensor or humidity or setpoint or time etc
    gosub Set_Decision_new2
  endif          
return

Set_Decision_New:
  x=queue_temp//8
  y=queue_temp/8
  if w=0 then                               'output
    z=out[y]>>x
  endif  
  if w=1 then                               'input
    z=inp[y]>>x
  endif
  if w=2 then                               'validation bit
    z=val_bit[queue_temp]
  endif
  if z.bit0=v then                          'true
    decision_new=1
  else                                      'false
    decision_new=0
  endif 
  gosub test_IfInstr       
return

Set_Decision_New2:  
  x=queue_action[i]
  y=queue_action[i+1]
  if queue_action[i]<32 then                                'temperature sensor
    z=temperature[x]
  elseif queue_action[i]>31 and queue_action[i]<64 then     'Humidity sensor
    z=humidity[x-32]
  elseif queue_action[i]>63 and queue_action[i]<96 then     'Light sensor
    z=ldr[x-64]
  elseif queue_action[i]>95 and queue_action[i]<128 then    'Temperature setpoint
    z=setpt[x-96]
  elseif queue_action[i]>127 and queue_action[i]<160 then   'Free Variable
    z=FreeVar[x-128]    
  elseif queue_action[i]=228 then                           'Hour
    z=hours
  elseif queue_action[i]=229 then                           'Minute
    z=minutes
  elseif queue_action[i]=230 then                           'Day
    z=days
  elseif queue_action[i]=235 then                           'Thermostat mode
    z=ThermostatMode     
  endif
  
  if queue_type[i+1]=248 then               '=
    if z=y then
      decision_new=1
    else
      decision_new=0
    endif
  elseif queue_type[i+1]=249 then           '>
    if z>y then
      decision_new=1
    else
      decision_new=0
    endif  
  elseif queue_type[i+1]=250 then           '<
    if z<y then
      decision_new=1
    else
      decision_new=0
    endif  
  endif
  gosub test_IfInstr
  i=i+1                                     'done 2 instruction from the queue         
return

test_IfInstr:
  if IfInstr=1 then                         'perform AND
    decision_new=decision_new&Decision_old
  endif  
  if IfInstr=2 then                         'perform OR
    decision_new=decision_new|Decision_old
  endif 
  if IfInstr=3 then                         'perform XOR
    decision_new=decision_new^Decision_old
  endif 
  if IfInstr=4 then                         'perform NAND
    decision_new=decision_new&/Decision_old
  endif 
  if IfInstr=5 then                         'perform NOR
    decision_new=decision_new|/Decision_old
  endif 
  if IfInstr=6 then                         'perform NXOR
    decision_new=decision_new^/Decision_old
  endif       
  decision_old=decision_new 
return

Timer_group:
  if CurrentInput<240 and timer_queue_pointer<(timer_queue-1) then  'only execute when valid input is used AND when Timer_queue is not full
    'add action to the timer queue
    action[5]=Queue_action[i]
    action[4]=2                               'Execute group action in timer queue if input is pressed more than x seconds
    action[6]=CurrentInput
    action[3]=Queue_Type[i]-205
    gosub add_timer_queue2     
  endif
return

correct_setpt:
  for pid=0 to (controllers-1)
     if setpt[pid]>150 then setpt[pid]=88   '12 degree celcius
  next pid
  PidCalcCheck=1 
return

Set_Free_Variables:
  if queue_action[i]<32 then                'only free variable 0-31 can be used
    a=queue_action[i]
    if queue_type[i]=120 then
      FreeVar[a]=0
    elseif queue_type[i]=121 then
      FreeVar[a]=FreeVar[a]-1
    elseif queue_type[i]=122 then
      FreeVar[a]=FreeVar[a]+1
    elseif queue_type[i]=123 then
      FreeVar[a]=FreeVar[a]-2
    elseif queue_type[i]=124 then
      FreeVar[a]=FreeVar[a]+2
    elseif queue_type[i]=125 then
      FreeVar[a]=FreeVar[a]-3
    elseif queue_type[i]=126 then
      FreeVar[a]=FreeVar[a]+3
    endif  
  endif
return

reset_pulsecounter:
  broad1="C"                                'Clear Pulse counters of all modules
  broad2="C"
  BroadID=0
  gosub send_broad
  pause 20
  gosub send_broad  
return

' Thermostat action -----------------------------------------------------------

Thermostat_action:
  if queue_type[i]>127 and queue_type[i]<134 then       'copy individual programmed setpoint into current setpoint
    a=queue_action[i]                       'a=0..23
    b=queue_type[i]-128                     'b=0..5
    if a<controllers then
      gosub Thermostat_action_sub    
      gosub correct_setpt
      if ThermostatMode.Bit6=1 then                     'Multi-tenancy is enabled so set the Multi-tenant configuration byte
        eep_addr.byte1=199                                'page 199
        eep_addr.byte0=a+32
        gosub read_eeprom                               'byte
        i2cdata=i2cdata & %11111000
        i2cdata=i2cdata+b
        gosub write_eeprom      
      endif
    endif   
  elseif queue_type[i]>133 and queue_type[i]<140 then   'copy full series of programmed setpoint into current setpoint
    if ThermostatMode.bit6=0 then                         'Multi tenancy is not enabled
      b=queue_type[i]-134 'b=0..5
      ThermostatMode=ThermostatMode & %11111000
      ThermostatMode=ThermostatMode | b
      gosub Write_ThermostatMode
      for a=0 to (controllers-1)
        if PermanentManual[a+(24*thermostatCooling)]=0 then
          gosub Thermostat_action_sub
        endif
      next a  
      gosub correct_setpt
    else
      gosub Set_all_thermostats
    endif
  elseif queue_type[i]>89 and queue_type[i]<92 then   'Multi-Tenant mode instructions
    if ThermostatMode.bit6=1 then           'Multi-tenant is enabled
      a=queue_action[i]                     'Thermostat Number
      if a<controllers then
        gosub Thermostat_action_MultiT
      endif
    endif  
  elseif queue_type[i]=145 then             'set day1 temperature of that day for thermostat x
    a=queue_action[i]                       'Thermostat Number
    b=0                                     'Day1
    if a<controllers then
      c=days
      gosub Thermostat_action_sub2
    endif
    gosub correct_setpt     
  elseif queue_type[i]=146 then             'set day2 temperature of that day for thermostat x
    a=queue_action[i]                       'Thermostat Number
    b=1                                     'Day2
    if a<controllers then
      c=days
      gosub Thermostat_action_sub2
    endif
    gosub correct_setpt
  elseif queue_type[i]=147 then             'set Night temperature of that day for thermostat x
    a=queue_action[i]                       'Thermostat Number
    b=2                                     'Night
    if a<controllers then
      c=days
      gosub Thermostat_action_sub2
    endif
    gosub correct_setpt
  elseif queue_type[i]=148 then             'Setpoint at 16 degree
    a=queue_action[i]
    if a<controllers then
      setpt[a]=96
      gosub check_setpoint
      i2caddr = 40+a
      i2cdata = setpt[a]
      gosub write_i2c_2
    endif
  elseif queue_type[i]=149 then             'Setpoint at 22.5 degree
    a=queue_action[i]
    if a<controllers then
      setpt[a]=109
      gosub check_setpoint
      i2caddr = 40+a
      i2cdata = setpt[a]
      gosub write_i2c_2
    endif             
  elseif queue_type[i]=140 then             'write ThermostatMode and copy series of programmed setpoint into current setpoint
    ThermostatMode=queue_action[i] 
    gosub Write_ThermostatMode
    b=queue_action[i]
    b=b & %00000111
    if b<6 then                           'b=0..5
      for a=0 to (controllers-1)
        if PermanentManual[a+(24*thermostatCooling)]=0 then
          gosub Thermostat_action_sub
        endif  
      next a    
    endif
    gosub correct_setpt
    gosub thermostat_timing               'set all thermostats in the right mode conform to the programmed timings  
  elseif queue_type[i]=141 then             'set thermostat mode to Manual or automatic
    if ThermostatMode.bit6=0 then           'Multi tenancy is not enabled
      if queue_action[i]=0 then
        ThermostatMode.bit3=0                 'Manual mode, ignore automatic settings
      else
        ThermostatMode.bit3=1                 'Autmatic mode
        gosub thermostat_timing               'set all thermostats in the right mode conform to the programmed timings
      endif
      gosub Write_ThermostatMode
      gosub correct_setpt
    else                                    'Multi-tenancy is enabled, set this change for all thermostats
      gosub Set_all_thermostats
    endif    
  elseif queue_type[i]=142 then             'Decrease current setpoint
    a=queue_action[i]
    if a<controllers then
      setpt[a]=setpt[a]-1
      gosub check_setpoint
      i2caddr = 40+a
      i2cdata = setpt[a]
      gosub write_i2c_2
    endif          
  elseif queue_type[i]=143 then             'Increase current setpoint
    a=queue_action[i]
    if a<controllers then
      setpt[a]=setpt[a]+1
      gosub check_setpoint
      i2caddr = 40+a
      i2cdata = setpt[a]
      gosub write_i2c_2     
    endif
  elseif queue_type[i]=144 then             'Instruction received from Oled
    a=queue_action[i]
    if a<controllers then
      digittotal[0]=queue_action[i]         'Thermostat number
      digittotal[1]=OledInstr0              'Config parameter
      digittotal[2]=OledInstr1              'Data
      digitcount=3
      gosub interprete_thermostat_instr    
    endif    
  endif    
return

Set_all_Thermostats:
  'hier
  for q=0 to (Controllers-1)
    if queue_type[i]=141 then    'Change between Auto and Manual for all thermostats
      if queue_action[i]=0 then  'Manual Mode for all thermostats
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=91  'Thermostat in Manual Mode
        queue_action[queue_pointer]=q 
      else                            'Automatic mode for all thermostats
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=90  'Thermostat in Manual Mode
        queue_action[queue_pointer]=q       
      endif
    endif
    if queue_type[i]>136 and queue_type[i]<140 then
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=queue_type[i]-6  'Copy Away, VAC or Party setpoint (BA131,132 or 133)
        queue_action[queue_pointer]=q     
    endif
  next q
return

check_setpoint:
  if setpt[a]>170 or setpt[a]<44 then 
    setpt[a]=94   'temperature too low or high -> set 15 degree
    SetAuto=1     'Something is not normal, if thermostat is in auto mode, reload auto temperatures
  endif  
  if setpt[a]<76 then setpt[a]=76                   'Minimum 6 degree
  if setpt[a]>128 then setpt[a]=128                 'Maximum 32 degree
return
  
Read_Setpt:
  'if thermostatAuto[a]=0 then                         'Thermostat in Manual mode
    eep_addr.byte1=142+(59*thermostatCooling)         'page 142 or 201
    eep_addr.byte0=(b*32)+a+32
    gosub read_eeprom  
    setpt[a]=i2cdata
    gosub check_setpoint
  'endif  
return

Thermostat_action_sub:
  Gosub Read_Setpt
  'if thermostatMode.byte6=0 then                      'Thermostat in Normal mode (not multi-tenant mode)
    i2caddr = 40+a
    gosub write_i2c_2
  'endif  
return

Thermostat_action_MultiT:                             'Thermostat in multi-tenant mode
  if queue_type[i]=90 then                            'Set Thermostat in Auto mode
    ThermostatAuto[a]=1
    i2cdata=%00001000
    eep_addr.byte1=199                                'page 199
    eep_addr.byte0=a+32                               'byte
    gosub write_eeprom
    q=a
    gosub thermostat_timing_sub    
  endif
  if queue_type[i]=91 then                            'Set thermostat in Manual mode
    ThermostatAuto[a]=0
    eep_addr.byte1=199                                'page 199
    eep_addr.byte0=a+32                               'byte
    gosub read_eeprom
    i2cdata=i2cdata & %11110111
    gosub write_eeprom
    'b=queue_type[i]-91
    'ThermostatManualB1[a]=b.bit1
    'ThermostatManualB0[a]=b.bit0
  endif                    
return

Thermostat_action_sub2:
  gosub Thermostat_day1_day2 
  setpt[a]=i2cdata
  gosub check_setpoint
  i2caddr = 40+a
  gosub write_i2c_2
return

Thermostat_day1_day2:
  eep_addr.byte0=((c-1)*32)+a
  if b=0 then                               'day1
    eep_addr.byte1=196+(14*thermostatCooling)        'page 196 or 210
  elseif b=1 then                           'day2
    eep_addr.byte1=197+(14*thermostatCooling)        'page 197 or 211
  else                                      'night
    eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212  
  endif  
  gosub read_eeprom 
return


output_dim:
  q=queue_action[i]
  write_yes=1                               'write to output modules
  write_yes_mod[q/8]=1                      'but only to selected module
  out_update[q]=1  
  if queue_type[i]<157 then                 'dim up
    v=queue_type[i]-153
    dimmer_value[q]=dimmer_value[q]+v
    if dimmer_value[q]>63 then dimmer_value[q]=63
  else                                      'dim down
    v=queue_type[i]-156
    dimmer_value[q]=dimmer_value[q]-v
    if dimmer_value[q]>63 or dimmer_value[q]<dim_minimum then dimmer_value[q]=dim_minimum  
  endif
  gosub dimmer_follow
return

' Store/Shutter actions when LargeInstallation is enabled ---------------------

StoreShutter_action:
if queue_action[i]<120 then
  if queue_type[i]=100 then                 'Store x up
    x=queue_action[i]//4
    y=queue_action[i]/4
    gosub Store_Up
    action[4]=102                           'Stop Individual Store
    gosub Remove_timer                      'Erase
    i_bit=1                                 'up
    gosub add_timer                         'Add
  elseif queue_type[i]=101 then             'Store x down
    x=queue_action[i]//4
    y=queue_action[i]/4
    gosub Store_down
    action[4]=102                           'Stop Individual Store
    gosub Remove_timer                      'Erase
    i_bit=0                                 'down
    gosub add_timer                         'Add
  elseif queue_type[i]=102 then             'Store x stop
    x=queue_action[i]//4
    y=queue_action[i]/4
    gosub Store_Stop
    action[4]=102                           'Stop Individual Store
    gosub Remove_timer                      'Erase
  elseif queue_type[i]=103 then             'Store up/stop/down/stop
    UpDwn=1                                 'Up/Dwn function enabled
    gosub Prep_Store_action
  elseif queue_type[i]=104 then             'Group x Up
    c=2
    gosub Store_group
    action[4]=106                           'Stop group Store
    gosub Remove_timer                      'Erase
    i_bit=1                                 'Up
    gosub add_timer                         'Add
  elseif queue_type[i]=105 then             'Group x down
    c=1
    gosub Store_group
    action[4]=106                           'Stop group Store
    gosub Remove_timer                      'Erase
    i_bit=0                                 'Down
    gosub add_timer                         'Add
  elseif queue_type[i]=106 then             'Group x Stop               
    c=0
    gosub Store_group
    action[4]=106                           'Erase group Store from queue
    gosub Remove_timer                      'Erase
  elseif queue_type[i]=107 then             'Group x up/stop/down/stop               
    UpDwn=1
    gosub Prep_Group_Action
  elseif queue_type[i]=108 then             'Store up/stop/up/stop
    UpDwn=0                                 'Up/Dwn function disabled
    UpDir=1                                 'Up
    gosub Prep_Store_action
  elseif queue_type[i]=109 then             'Store down/stop/down/stop
    UpDwn=0                                 'Up/Dwn function disabled
    UpDir=0                                 'Down
    gosub Prep_Store_action
  elseif queue_type[i]=110 then             'Group x up/stop/up/stop               
    UpDwn=0
    UpDir=1
    gosub Prep_Group_Action
  elseif queue_type[i]=111 then             'Group x down/stop/down/stop               
    UpDwn=0
    UpDir=0
    gosub Prep_Group_Action                   
  endif
endif  
return

Prep_Group_Action:
  c=3
  w=0
  StoreMove=0
  gosub Store_group                       'Check if any stores are moving
  c=3
  w=1
  gosub Store_group                       'Execute Stop or Up or Down
  action[4]=106                           'Erase group Store from queue
  gosub Remove_timer                      'Erase
  if StoreMove=0 then gosub add_timer     'Add 
Return

Prep_Store_action:
  c=4
  gosub Store_1Action
  action[4]=102                           'Stop Individual Store
  gosub Remove_timer                      'Erase
  if StoreMove=0 then gosub add_timer     'Add
return    

Remove_timer:
  action[5]=queue_action[i]
  gosub remove_timer_queue 
return

Remove_timer_queue:                         'Remove item from timer queue, action[4] and action[5] used
  if timer_queue_pointer>0 then
    for t=timer_queue_pointer+1 to 1 step -1
      if action[4]=timer_type[t-1] and action[5]=timer_action[t-1] then     'Already exist?
        timer_action[t-1]=255                                             'Remove from queue
        timer_type[t-1]=255
        timer_input[t-1]=255
        timer_seconds[t-1]=255
      endif
    next t    
  endif
return

Add_timer:
  a=queue_action[i]
  b=queue_action[i]/4
  c=queue_action[i]//4
  if action[4]=102 then                     'Individual store
    eep_addr.byte1 = 33+b                   'page    
    if i_bit=1 then                         'Up
      eep_addr.byte0 = 177+(c*2)  
    else                                    'down
      eep_addr.byte0 = 178+(c*2)
    endif      
  else                                      'Group store
    eep_addr.byte1 = 64                     'page
    if i_bit=1 then                         'Up
      eep_addr.byte0 = a*2
    else
      eep_addr.byte0 = (a*2)+1
    endif     
  endif
  gosub read_eeprom
  if i2cdata<250 then
    action[3]=i2cdata                       'set seconds
  else
    action[3]=239  
  endif
  action[6]=240  
  gosub add_timer_queue2
return

Store_group:
  if controller_out_RS>0 then
    for ic=1 to controller_out_RS           'Check all Shutter/Store controllers in Large Installation mode
      for a=0 to 3                          'Check all stores per module
        for b=0 to 1                        'Check the 2 groups per store
          eep_addr.byte1 = 63                   'page
          eep_addr.byte0 = ((ic-1)*8)+(a*2)+b
          Gosub read_eeprom
          if i2cdata=queue_action[i] then       'Group found, execute Up for that store
            x=(((ic-1)*4)+a)//4
            y=(((ic-1)*4)+a)/4
            if c=2 then
              gosub Store_up
            elseif c=1 then
              gosub Store_down
            elseif c=3 then
              gosub store_1action 
            else
              gosub Store_Stop
            endif      
          endif
        next b
      next a
    next ic
    if c=3 and w=1 then                         'group up/stop/down/stop has been performed
      if StoreMove=0 then
        v=queue_action[i]
        if val_bit[90+v]=0 then
          val_bit[90+v]=1
        else
          val_bit[90+v]=0
        endif    
      endif
    endif
    c=0
  endif  
return

Store_1Action:
  z=%00000011
  z=z<<(x*2)
  u=outRS[y]&z
  v=queue_action[i]
  if c=3 and w=0 then                       'Check if any store is moving (group only)
    if u<>0 then                            'Store is moving
      StoreMove=1
    endif
  elseif c=3 and w=1 then                   'Execute action (stop, or up or down)(group only)
    if StoreMove=1 then
      gosub Store_Stop
    else
      if UpDwn=1 then
        if val_bit[90+v]=0 then      
          gosub Store_Up
        else
          gosub store_down
        endif
      else
        if UpDir=1 then
          gosub Store_Up
        else
          gosub store_down
        endif
      endif    
    endif
  else                                      'Execute action (stop, or up or down)(Non group)
    x=queue_action[i]//4
    y=queue_action[i]/4
    z=%00000011
    z=z<<(x*2)    
    u=outRS[y]&z
    if u=0 then                             'Store is not moving
      StoreMove=0
      if UpDwn=1 then
        if val_bit[120+v]=0 then                              
          gosub Store_Up
          val_bit[120+v]=1
        else
          gosub store_down
          val_bit[120+v]=0
        endif
      else
        if UpDir=1 then
          gosub Store_Up
        else
          gosub store_down
        endif     
      endif    
    else                                      'Store is moving
      StoreMove=1
      gosub Store_Stop
    endif
  endif   
return

Get_UpDownConfig:
  eep_addr.byte1 = 33+y     'page
  eep_addr.byte0 = 185+x
  Gosub read_eeprom
  if i2cdata.bit0=i_bit then
    z=z<<(x*2)
  else
    z=z<<((x*2)+1)
  endif  
return

Store_Up:
    i_bit=1
    z=%00000001
    gosub Get_UpDownConfig  
    outRS[y]=outRS[y]|z
    write_yes_rs=1
    write_yes_modRS[y]=1
return

Store_Down:
    i_bit=0
    z=%00000001
    gosub Get_UpDownConfig  
    outRS[y]=outRS[y]|z
    write_yes_rs=1
    write_yes_modRS[y]=1
return

Store_Stop:
    'gosub Get_UpDownConfig
    z=%00000011
    z=z<<(x*2)
    z=~z
    outRS[y]=outRS[y]&z    
    write_yes_rs=1
    write_yes_modRS[y]=1
return

Set_Cooling:
  gosub Thermostat_output_off       'Switch off all thermostat and pump outputs in the current mode (cooling or heating)
  if queue_action[i]=0 then         'Cooling Disabled, Heating enabled
    thermostatCooling=0
    thermostatmode.bit4=0
  elseif queue_action[i]=1 then     'Cooling Enabled (Heating disabled) but Cooling OFF
    thermostatCooling=1
    thermostatmode.bit4=1
    thermostatmode.bit7=0
    thermostatOn=0
    for u=0 to (Controllers-1)      'Also switch OFF RTD-10 Airco units
      Airco[u]=0
    next u
    gosub OnOffAirco  
  else                              'Cooling Enabled (Heating disabled) and Cooling ON
    thermostatCooling=1
    thermostatmode.bit4=1
    thermostatOn=1
    thermostatmode.bit7=1    
  endif
  gosub write_thermostatmode
  gosub read_thermostat_par
  gosub Set_CoolingHeating
return

Set_airco:
  u=queue_action[i]  
  if queue_action[i]<24 then        'Enable Airco
    Airco[u]=1
    PidCalcCounter=u    
    gosub RTD10    
  endif
  if queue_action[i]>99 and queue_action[i]<124 then        'Disable Airco
    Airco[u-100]=0
    PidCalcCounter=u-100   
    gosub RTD10    
  endif   
return

OnOffAirco:        'Switch ON or OFF Airco RTD-10 when changing mode
  for PidCalcCounter=0 to (Controllers-1)
    gosub RTD10
  next PidCalcCounter
return

Set_CoolingHeating:
  ok=0
  for b=0 to 3
    a=(thermostatCooling)*8
    eep_addr.byte1 = 199            'page
    eep_addr.byte0 = a+(b*2)
    Gosub read_eeprom
    if i2cdata<>255 then
      digittotal[0]=i2cdata
      eep_addr.byte0 = a+(b*2)+1
      Gosub read_eeprom
      if i2cdata=0 then             'Output off
        digitcount=1
        gosub output_off
      else                          'Output on
        digitcount=2
        digittotal[1]=i2cdata
        gosub output_on
      endif  
    endif
  next b
  ok=1  
return

' OUTPUT On/OFF action --------------------------------------------------------

Output_OnOff:
  Digitcount=1
  Digittotal[0]=queue_action[i]
  digittotal[1]=0
  q=queue_action[i]
  if queue_type[i]=160 then                 'output off
    gosub output_off
  elseif queue_type[i]=161 then             'output On
    gosub output_on
  elseif queue_type[i]=162 and q<240 then   'output toggle
    gosub Toggle_lights      
  elseif queue_type[i]=163 then             'all lights off
    level=255
    gosub all_lights_off 
  elseif queue_type[i]=164 then             'all outputs off
    gosub all_outputs_off
  elseif queue_type[i]=165 and q<240 then   'Light on at minimum dimmer level
    dimmer_value[q]=dim_minimum
    gosub output_on
  elseif queue_type[i]=166 and q<240 then   'Light on at maximum dimmer level
    dimmer_value[q]=63
    gosub output_on
  elseif queue_type[i]=167 and q<240 then   'Light on, decrease dimmer value with 5
    dimmer_value[q]=dimmer_value[q]+5
    if dimmer_value[q]>63 then
      dimmer_value[q]=63
    endif
    gosub output_on
  elseif queue_type[i]=168 and q<240 then   'Light on, increase dimmer value with 5
    if dimmer_value[q]<10 or (dimmer_value[q]-5)<dim_minimum then
      dimmer_value[q]=dim_minimum
    else
      dimmer_value[q]=dimmer_value[q]-5
    endif
    gosub output_on
  elseif queue_type[i]=169 and q<240 then   'set dimmer value at minimum
    dimmer_value[q]=dim_minimum               
  elseif queue_type[i]=170 and q<240 then   'set dimmer value at maximum
    dimmer_value[q]=63
  elseif queue_type[i]=171 then             'all lights off of a certain floor level or group
    level=q
    gosub all_lights_off      
  elseif queue_type[i]=172 then             'all lights on of a certain floor level or group
    level=q
    gosub all_lights_on 
  elseif queue_type[i]=173 then             'toggle all lights of a certain floor level or group
    level=q
    gosub all_lights_toggle 
  elseif queue_type[i]>175 and queue_type[i]<185 and q<240 then  'Light on at 10%-90%
    dimmer_value[q]=(queue_type[i]-175)*6
    gosub output_on 
  elseif queue_type[i]>184 and queue_type[i]<195 and q<240 then  'Toggle Light at 10%-100%
    dimmer_value[q]=(queue_type[i]-184)*6
    gosub Toggle_lights
  elseif queue_type[i]>194 and queue_type[i]<201 and q<240 then  'Switch on light with timer setting between 2m30 and 1h20
    gosub set_output_on    
  elseif queue_type[i]>200 and queue_type[i]<207 and q<240 then  'Switch on light with timer setting between 2m30 and 1h20 but doesn't overule when light is already on
    gosub check_output                                           'check if output is on, q must contain output nr
    if z.bit0=0 then gosub set_output_on                         'if output is off, switch it on and set timer              
  endif          
return

check_output:
  'output number must be out in q, result in z.bit0
  x=q//8
  y=q/8
  z=out[y]>>x
return

Set_Output_on:
  digitcount=3
  digittotal[1]=dimmer_value[q]                                 'dimmer value
  if queue_type[i]>200 then
    digittotal[2]=(queue_type[i]-200)*(queue_type[i]-199)*75    'timer value
  else
    digittotal[2]=(queue_type[i]-194)*(queue_type[i]-193)*75    'timer value
  endif
  gosub output_on
return


Toggle_lights:
  if ToggleFollowON=1 and ToggleFollowActive=1 then
    if ToggleFollowData=1 then
      gosub output_on
    else
      gosub output_off
    endif
  endif
  if ToggleFollowON=0 or (ToggleFollowON=1 and ToggleFollowActive=0) then
    write_yes=1                             'write to output modules
    write_yes_mod[q/8]=1                    'but only to selected module
    z=%00000001
    z=z<<(q//8)
    out[q/8]=out[q/8]^z                     'Toggle output
    out_update[q]=1
    if ToggleFollowON=1 then
      ToggleFollowActive=1
      ToggleFollowData=out[q/8]>>(q//8)
    endif
    gosub dimmer_follow   
  endif
  OdCode=5
  OdOutputNr=q
  gosub Output_debug
return



' Group action ----------------------------------------------------------------

group_action:
'i is used from check_queue routine
  if queue_action[i]<160 then               'page 67-86 in eeprom
    eep_addr.byte1 = 67 + (queue_action[i]/8)
    x=queue_action[i] - (8*(queue_action[i]/8))  
    for t=0 to 15
      eep_addr.byte0 = (x*32)+(t*2)
      Gosub read_eeprom 
      a=i2cdata                             'read type from eeprom 
      eep_addr.byte0 = (x*32)+(t*2)+1
      Gosub read_eeprom 
      b=i2cdata                             'read action from eeprom
      if a<255 then                         'add intelligent action to the queue
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=a
        queue_action[queue_pointer]=b      
      endif             
    next t    
  endif
return


' Simple decision -------------------------------------------------------------

simple_decision:
'i is used from check_queue routine
  if queue_action[i]<192 then               'page 87-92 in eeprom
    eep_addr.byte1 = 87 + (queue_action[i]/32)
    x=queue_action[i] - (32*(queue_action[i]/32)) 
    for t=0 to 7
      eep_addr.byte0 = x*8+t
      Gosub read_eeprom 
      action[t]=i2cdata                     'read action from eeprom 
    next t
    a=action[0]                             'config byte
    d=action[1]
    x=action[1]/8
    y=action[1]//8
    if a.bit2=0 and a.bit1=0 and a.bit0=0 then      'check output  
      b=out[x]>>y                           'put selected bit on BIT0
      b=b & %00000001                       'all bits on 0 except BIT0
      gosub compare_decision
    elseif a.bit2=0 and a.bit1=0 and a.bit0=1 then  'check input  
      b=inp[x]>>y                           'put selected bit on BIT0
      b=b & %00000001                       'all bits on 0 except BIT0     
      gosub compare_decision
    elseif a.bit2=0 and a.bit1=1 and a.bit0=0 then  'check temperature  
      b=temperature[d]
      gosub compare_decision
    elseif a.bit2=0 and a.bit1=1 and a.bit0=1 then  'check brigtness level  
      b=ldr[d]
      gosub compare_decision
    elseif a.bit2=1 and a.bit1=0 and a.bit0=0 then  'check press cycles in seconds 
      b=inp[x]>>y                           'put selected bit on BIT0
      if b.bit0=1 and timer_queue_pointer<(timer_queue-1) then  'selected input is active -> add action in the timer queue
        action[6]=CurrentInput      
        Gosub add_timer_queue2             
      endif
    'elseif a.bit2=1 and a.bit1=0 and a.bit0=1 then  'check power level  
      'TBC
     
    'elseif a.bit2=1 and a.bit1=1 and a.bit0=0 then  'check time  
      'TBC
      
    elseif a.bit2=1 and a.bit1=1 and a.bit0=1 then  'check validation bit  
      b=val_bit[d]     
      gosub compare_decision
    endif   
  endif
return


compare_decision:
  if a.bit4=0 and a.bit3=0 then             'equal with data field
    if b=action[3] then
      decision_new=1                        'true
      gosub compare
    else
      decision_new=0                        'false
      gosub compare
    endif
  elseif a.bit4=0 and a.bit3=1 then         'higher than data field  
    if b>action[3] then
      decision_new=1                        'true
      gosub compare
    else
      decision_new=0                        'false
      gosub compare
    endif
  elseif a.bit4=1 and a.bit3=0 then         'lower than data field   
    if b<action[3] then
      decision_new=1                        'true
      gosub compare
    else
      decision_new=0                        'false
      gosub compare
    endif
  endif     
return

compare:
  if queue_bit.bit4=1 then                  'perform AND or OR function with pervious decision
    if queue_bit.bit5=1 then                'perform AND  
      decision_new=decision_old&decision_new
    else                                    'perform OR   
      decision_new=decision_old|decision_new 
    endif
  endif
  if decision_new=1 then                    'true
    gosub true_action
    decision_old=decision_new
  else                                      'false
    gosub false_action
    decision_old=decision_new
  endif
return

true_action:                                'add "true" action in the queue
  if queue_bit.bit3=1 then                  'perform true action
    gosub Increase_queue_pointer
    queue_type[queue_pointer]=action[4]
    queue_action[queue_pointer]=action[5]
  endif 
return

false_action:                               'add "false" action in the queus
  if queue_bit.bit3=1 then                  'perform false action
    gosub Increase_queue_pointer
    queue_type[queue_pointer]=action[6]
    queue_action[queue_pointer]=action[7]   
  endif
return

' Simple Action ---------------------------------------------------------------

simple_action:
'i is used from check_queue routine
  if queue_action[i]<204 then               'page 93-108 in eeprom
    eep_addr.byte1 = 93 + (queue_action[i]/51)
    x=queue_action[i] - (51*(queue_action[i]/51))
    for t=0 to 4
      eep_addr.byte0 = x*5+t
      Gosub read_eeprom 
      action[t]=i2cdata                     'read action from eeprom    
    next t 
    b=action[0]                             'config byte
    a=action[1]
    x=a/8
    z=a//8
    y=%00000001<<z               
    if a<240 then                           'action from 0 - 239
      write_yes=1
      write_yes_mod[a/8]=1
      out_update[a]=1
      if b.bit1=0 and b.bit0=0 then         'Put output off 
        y=~y                                'invert
        out[x]=out[x]&y
        OdCode=6                            'Output debug code
        OdOutputNr=a
        gosub Output_debug                  'Display on console when outbug debug is on    
      elseif b.bit1=0 and b.bit0=1 then     'put output on and select timer
        out[x]=out[x]|y                     'put selected output on       
        gosub simple_action_on
        OdCode=7                            'Output debug code
        OdOutputNr=a
        gosub Output_debug                  'Display on console when outbug debug is on        
      elseif b.bit1=1 and b.bit0=0 then     'Toggle output
        out[x]=out[x]^y
        c=out[x]
        c=c>>z
        if c.bit0=0 then                    'output is toggled off
          'TBC
        endif
        if c.bit0=1 then                    'output is toggled on
          gosub simple_action_on
        endif
        OdCode=8                            'Output debug code
        OdOutputNr=a
        gosub Output_debug                  'Display on console when outbug debug is on 
      endif       
    endif
    if b.bit1=1 and b.bit0=1 then           'set or clear validation bit
      gosub validation_bit
    endif
    if a=241 and b.bit1=0 and b.bit0=0 then 'all outputs off   
      gosub all_outputs_off
      OdCode=9                              'Output debug code
      OdOutputNr=255
      gosub Output_debug                    'Display on console when outbug debug is on       
    endif
    if a=242 and b.bit1=0 and b.bit0=0 then 'all lights off   
      level=255
      gosub all_lights_off
      OdCode=10                             'Output debug code
      OdOutputNr=255
      gosub Output_debug                    'Display on console when outbug debug is on 
    endif
    if a>242 and a<249 and b.bit1=0 and b.bit0=0 then 'all lights off of a certain floor (243: floor0, 244: floor1, etc)   
      level=a-243
      gosub all_lights_off
      OdCode=11                             'Output debug code
      OdOutputNr=255
      gosub Output_debug                    'Display on console when outbug debug is on 
    endif            
  endif 
return

validation_bit:
  if b.bit5=0 and b.bit4=0 then             'clear validation bit
    val_bit[a]=0
  elseif b.bit5=0 and b.bit4=1 then         'set validation bit
    val_bit[a]=1
  elseif b.bit5=1 and b.bit4=0 then         'toggle validation bit
    val_bit[a]=~val_bit[a]  
  endif  
return

simple_action_on:
  'i is used from check_queue routine
  if Mod_id0[30+(a/8)]="D" or Mod_id0[30+(a/8)]="d" then             'only when dimmer
    dimmer_value[a]=action[4]
  else
    dimmer_value[a]=63
  endif
  if b.bit3=1 then             
    e_word.byte0=action[2]                  'timer LSB
    e_word.byte1=action[3]                  'timer MSB
    timer_cd[a]=e_word                      'put timer value
  endif
return

'Scheduled action ------------------------------------------------

scheduled_action:
'i is used from check_queue routine
  if queue_action[i]<102 then               'page 113-114 in eeprom
    eep_addr.byte1 = 113 + (queue_action[i]/51)
    x=queue_action[i] - (51*(queue_action[i]/51))    
    for t=0 to 4
      eep_addr.byte0 = x*5+t
      Gosub read_eeprom 
      action[t]=i2cdata                     'read action from eeprom    
    next t 
    'put scheduled action in scheduled action queue
    if action[0]<25 and action[1]<60 then   'hour and minute must be valid,if =24, perform every minute
      gosub add_schedule_queue
    endif          
  endif  
return

add_schedule_queue:
  'i is used from check_queue routine
  if Sched_queue_counter<sched_queue_max then
    t=queue_action[i]
    Sched_hour[t]=action[0]
    Sched_minute[t]=action[1]
    Sched_day[t]=action[2]
    Sched_type[t]=action[3]
    Sched_action[t]=action[4]
    Sched_queue_counter=Sched_queue_counter+1
  else
    'error queue overflow
    error_ID[0]= 0                          'Error code for queue overflow
    error_ID[1]= 0
    error_ID[2]= 0
    error_ID[3]= 0
    error_code = 24
    gosub send_error 
  endif 
return

all_lights_off:                             'if level=255->All lights off, if level<255, only (floor)level will be switched off
  cf=160                                    'Lights off
  gosub Lights_on_off
return

all_lights_on:                              'if level=255->All lights on, if level<255, only (floor)level or group will be switched on
  cf=161                                    'Lights on
  gosub Lights_on_off
return

all_lights_toggle:
  cf=162                                    'Lights toggle
  gosub Lights_on_off                       'first time to test to see if any lights are on (toggle all on or all off)
  if z1=1 then                              'at least one light on
    cf=160                                  'turn off lights
  else
    cf=161                                  'turn on lights
  endif
  gosub Lights_on_off
return

lights_on_off:
  z1=0
  for jf=0 to (controller_out-1)
    for xf=0 to 7
      yf=out[jf]
      zf=yf>>xf       
      eep_addr.byte1=33+jf
      eep_addr.byte0=157+xf                 'address (Floor Level)
      gosub read_eeprom
      af=i2cdata
      eep_addr.byte0=149+xf                 'address (Output type: 0-127->output, 128-255->Light)
      gosub read_eeprom
      bf=i2cdata 
      if (level=af or level=255) and bf>127 then  'switch light
        if cf=160 or cf=161 then
          digittotal[0]=(jf*8)+xf
          digitcount=1
          digittotal[1]=0
          if cf=160 then 
            gosub output_off
          else
            gosub output_on
          endif  
        else                                'for toggle lights, check if light is on
          if zf.bit0=1 then                 'light is on
            z1=1
            xf=7
            jf=controller_out-1
          endif  
        endif    
      endif        
    next xf
  next jf
return

all_outputs_off:
  write_yes=1
  write_yes_rs=1                            'write outputs
  for u=0 to (controller_out*8)
    out_update[u]=1
  next u  
  for u=1 to controller_out
    out[u-1]=0                              'Put all outputs into off state
    write_yes_mod[u-1]=1
  next u
  for u=1 to controller_out_RS
    outRS[u-1]=0                            'Put all outputs into off state
    write_yes_modRS[u-1]=1
  next u   
return

RO_Linux2:
  if write_yes_mod[ic-1]=1 then         'only changes in module will be communicated
    x=(ic-1)*8
    Hserout2 ["RO",cid,ic-1,0,0,0,out[ic-1],dimmer_value[x],dimmer_value[x+1],dimmer_value[x+2],dimmer_value[x+3],dimmer_value[x+4],dimmer_value[x+5],dimmer_value[x+6],dimmer_value[x+7],13,10]
  endif
  cid=0
return

SO_Linux2:
  Hserout2 ["SO",cid,ic-1,0,0,0,outRS[ic-1],13,10]
return

'For the complete error list see http://wiki.openmotics.com/index.php/Error_Codes
send_error:                                 '"ER
'if ErrorBit[ErrorTmp]=0 then                'no error on selected input/output
if ErrorCount[ErrorTmp]<2 then
  low led_red                                       
  if mode_com=1 then                        'only in advanced mode
    gosub empty_e
    e[0]="E"
    e[1]="R"
    e[2]=0
    e[3]=error_code
    e[4]=error_ID[0]
    e[5]=error_ID[1]
    e[6]=error_ID[2]
    e[7]=error_ID[3]
    gosub send_api        
  else
    if ErrorTmp<60 then
      hserout2 ["ERROR ",dec error_code," ID: ",dec3 error_ID[0],".",dec3 error_ID[1],".",dec3 error_ID[2],".",dec3 error_ID[3],13,10]
    else
      hserout2 ["ERROR ",dec error_code,13,10]
    endif
  endif
endif
if ErrorCount[ErrorTmp]>(ErrorMax-1) then          'check if module must be disabled
  ErrorBit[ErrorTmp]=1
endif 
error_code=255
cid=0
ErrorTmp=60                                 'not used module -> this code will be used for non input/output related errors
ErrorBit[ErrorTmp]=0  
return

send_ST:                                    '"ST
  x=version
  y=firmware
  z=built
  a=hardware
  if serstring[3]="W" then
    OledEeprom.Byte1=serstring[4]
    OledEeprom.byte0=0
  endif
  gosub empty_e
  e[0]="S"
  e[1]="T"
  e[2]=cid
  e[3]=seconds
  e[4]=minutes
  e[5]=hours
  e[6]=days
  if serstring[3]="R" or serstring[3]="W" then
    e[7]="S"
    e[8]=OledEeprom.byte1
    e[9]=OledEeprom.Byte0    
  else
    e[7]=0
    e[8]=0
    e[9]=0
  endif
  e[10]=0  
  e[11]=mode
  e[12]=x
  e[13]=y
  e[14]=z
  e[15]=a  
  gosub send_api   
  cid=0
return

send_AE:
  if mode_com=1 then
    gosub empty_e
    e[0]="A"
    e[1]="E"
    e[2]=cid
    e[3]=0
    e[4]="O"
    e[5]="K"
    gosub send_api     
  endif
  cid=0
return

send_AE2:
  if mode_com=1 then
    gosub empty_e
    e[0]="a"
    e[1]="e"
    e[2]=cid
    e[3]=0
    e[4]="O"
    e[5]="K"
    gosub send_api     
  endif
  cid=0
return

send_EV:
  if mode_com=1 then
    gosub empty_e
    e[0]="E"
    e[1]="V"
    e[2]=0
    e[3]=queue_action[i]
    gosub send_api     
  endif
  cid=0
Return

send_AD:
  if mode_com=1 then
    gosub empty_e
    e[0]="A"
    e[1]="D"
    e[2]=cid
    e[3]=serstring[3]
    e[4]=serstring[4]
    e[5]=serstring[5]
    e[6]=serstring[6]
    e[7]="A"
    gosub send_api     
  endif
  cid=0
return

send_crc:
  Hserout2 ["C",CRC.byte1,CRC.byte0]
return

send_OO:
  Hserout2 ["OO"]
  gosub send_lightsOn
return

send_OL:
  gosub calculate_NrofOutputs
  Hserout2 ["OL",cid,NrOutputsOn]
  gosub send_lightsOn
  cid=0
return

send_PL:
  crc=0
  Hserout2 ["PL",cid]
  for ic=0 to (NumberPulseCounters-1)
    t_word=pulsecounter[ic]
    crc=crc+t_word.byte1+t_word.byte0
    hserout2 [t_word.byte1,t_word.byte0]
  next ic
  gosub send_crc    
  gosub display_LF_CR
  cid=0
return

send_IL:
  Hserout2 ["IL",0,v,q]
  gosub display_LF_CR
  cid=0
return

calculate_NrofOutputs:
  NrOutputsOn=0
  for j=1 to controller_out                'check all output devices
    for t=0 to 7                            'check all outputs of a selected device
      x=out(j-1)>>t
      y=((j-1)*8)+t
      if x.bit0=1 then                      'selected output is ON, remember (var TimerSet) to put back the timer value
        NrOutputsOn=NrOutputsOn+1
      endif  
    next t
  next j
return

send_lightsOn:
  for j=0 to (controller_out-1)
    if out[j]>0 then
      y=out[j]
      for x=0 to 7
        z=y>>x
        if z.bit0=1 then
          Hserout2 [(j*8)+x,dimmer_value[(j*8)+x]]
        endif
      next x
    endif
  next j
  gosub display_LF_CR
return

instr_EL:
  eep_addr.byte1=serstring[3]               'Page to read
  hserout2 ["EL",CID,eep_addr.byte1]
  for x=0 to 255
    eep_addr.byte0=x
    gosub read_eeprom
    gosub print_i2cdata
  next x
  gosub display_LF_CR
return

instr_VL:
  CRC=0
  hserout2 ["VL",CID]
  for x=0 to 31
    i2cdata=VirtualSensor[x]
    crc=crc+i2cdata
    gosub print_i2cdata
  next x
  gosub send_crc
  gosub display_LF_CR
  cid=0
return

instr_pL:    '"pL"
  CRC=ThermostatCooling
  hserout2 ["pL",CID,ThermostatCooling]
  for x=0 to (Controllers-1)
    i2cdata=PermanentManual[x+(24*ThermostatCooling)]
    crc=crc+i2cdata
    gosub print_i2cdata
  next x
  gosub send_crc
  gosub display_LF_CR
  cid=0
return

print_i2cdata:
  hserout2 [i2cdata]
return

send_reset:
  gosub empty_e
  e[0]="r"
  e[1]="e"
  e[2]=cid
  gosub send_api 
return

send_ws:
  if mode_com=1 then
    gosub empty_e
    e[0]="w"
    e[1]="s"
    e[2]=cid
    e[3]=serstring[3]
    e[4]=serstring[4]
    e[5]=serstring[5]
    gosub send_api     
  endif
return

send_RS:
  if mode_com=1 then
    CRC=0
    x=thermostatsensor[pid]
    a=thermostat[pid]
    c=thermostat2[pid]
    CRC=pid+temperature[x]+setpt[pid]
    if CIDused=0 then
      Hserout2 ["RS"]
    else
      Hserout2 ["rs",cid]
    endif
    hserout2 [pid,temperature[x],setpt[pid]]
    eep_addr.byte1 = 142+(59*thermostatCooling)       'Page 142 o 201
    for ic=1 to 6
      eep_addr.byte0 = (32*ic)+pid
      gosub read_eeprom
      gosub print_i2cdata
      CRC=CRC+i2cdata
    next ic
    CRC=CRC+x+a+c+dimmer_value[a]+dimmer_value[c]+temperature[outside_sensor]+ThermostatMode
    Hserout2 [x,a,c,dimmer_value[a],dimmer_value[c],temperature[outside_sensor],ThermostatMode]
    for ic=0 to 15
      eep_addr.byte1 = 187 + (pid/16)+(17*thermostatCooling)      'Start page 187 or 204
      eep_addr.byte0 = ((pid//16)*16)+ic
      Gosub read_eeprom     
      b=i2cdata
      if b>126 then
        b=32                                'space
      endif
      CRC=CRC+b
      Hserout2 [b]   
    next ic
    gosub PID_read
    CRC=CRC+Kp+Ki+Kd+IntThresh+Temp_threshold+days+hours+minutes
    Hserout2 [Kp,Ki,Kd,IntThresh,Temp_threshold,days,hours,minutes]
    for ic=0 to 6                           'retrieve timings out of eeprom
      for t=0 to 3
        eep_addr.byte1 = 189 + (ic/2)+(17*thermostatCooling)      'Start page 189 or 206
        eep_addr.byte0 = (128*(ic//2))+(pid*4)+t
        Gosub read_eeprom  
        CRC=CRC+i2cdata   
        gosub print_i2cdata     
      next t
    next ic
    if CIDused=1 then                       '"rs" instruction is used
      hserout2 ["T"]
      CRC=CRC+"T"
      a=pid
      for b=0 to 2                          'Day1/Day2/Night
        for c=1 to 7                        'Retrieve temperature Mon-Sun
          gosub Thermostat_day1_day2 
          CRC=CRC+i2cdata   
          gosub print_i2cdata                
        next c
      next b       
    endif
    gosub send_crc
    gosub display_LF_CR   
  endif
  cid=0
return


'------------------------------------------------------------------------------
' RS232: API and CLI
' For API documentation see http://wiki.openmotics.com/index.php/API_Reference_Guide
' For CLI documentation see http://wiki.openmotics.com/index.php/CLI_Reference_Guide
'------------------------------------------------------------------------------              

Rs232_interprete: 
  if RCSTA2.4=0 then                        'Data Ready to be Interpreted
    low led_red
    cid=serstring[2]                        'cid code
    if Mode_com=1 then                      'API mode      
      if (serstring[1] = "l") then          'Read list (thermostat, temperature, humidity or Brightness,error)
        gosub instr_xl                                              '"tl      
      elseif (serstring[1] = "L") then      'other type of List 
        gosub instr_xL2       
      elseif (serstring[0] = "F") then      'Slave Firmware instruction set 
        if RS485busy=0 then                 'wait untill bus is free
          gosub instr_F
        else                                'RS485 bus is not free yet
          goto end_rs232_interprete
        endif                                                                 
      elseif (serstring[0] = "r") and (serstring[1] = "s") then     'read thermostat data, detailed information of 1 thermostat  
        gosub instr_RS2                                             '"rs        
      elseif (serstring[0] = "r") and (serstring[1] = "o") then     'read output Data, detailed information of 1 output 
        CIDused=1                                                   '"ro
        cid=serstring[2]
        x=serstring[3]
        gosub send_RD      
      elseif (serstring[0] = "V") and (serstring[1] = "S") then     'Write Virtual Sensor data 
        gosub instr_VS                                              '"VS        
      elseif (serstring[0] = "B") and (serstring[1] = "A") then     'Execute Basic Action 
        gosub instr_BA                                              '"BA                                         
      elseif (serstring[0] = "T") and (serstring[1] = "M") then     'Read Thermostat Mode
        gosub instr_TM                                              '"TM
      elseif (serstring[0] = "R") and (serstring[1] = "S") then     'read thermostat data, detailed information of 1 thermostat  
        gosub instr_RS                                              '"RS                                        
      elseif (serstring[0] = "O") and (serstring[1] = "O") then     'read output Data, Give list of outputs that are ON 
        gosub send_OO                                               '"OO    
      elseif (serstring[0] = "R") and (serstring[1] = "D") then     'read output Data, detailed information of 1 output 
        CIDused=0                                                   '"RD
        gosub instr_RD     
      elseif (serstring[0] = "W") and (serstring[1] = "D") then     'Write output data, detailed information of 1 output
        gosub instr_WD                                              '"WD    
      elseif (serstring[0] = "W") and (serstring[1] = "S") then     'Write thermostat data, detailed information of 1 thermostat
        gosub instr_WS                                              '"WS
      elseif (serstring[0] = "w") and (serstring[1] = "s") then     'Write thermostat data, detailed information of 1 thermostat
        gosub instr_wsl                                             '"ws     
      elseif (serstring[0] = "r") and (serstring[1] = "e") then     'reset processor
        gosub instr_reset                                           '"re
      elseif (serstring[0] = "I") and (serstring[1] = "F") then     'perform intelligent function
        gosub instr_IF                                              '"IF  
      elseif (serstring[0] = "S") and (serstring[1] = "T") then     'Status information
        cid=serstring[2]
        Gosub send_ST                                               '"ST    
      elseif (serstring[0] = "s") and (serstring[1] = "t") then     'Set Time
        gosub instr_st                                              '"st  
      elseif (serstring[0] = "D") and (serstring[1] = "I") then     'Dim up or down last dimmer light switched on with "ON" instruction
        gosub instr_DI                                              '"DI   
      elseif (serstring[0] = "R") and (serstring[1] = "O") then     'Read output                                       
        for ic=1 to controller_out                                  '"RO
          write_yes_mod[ic-1]=1
          gosub RO_linux2                                     'All output modules
        next ic 
      elseif (serstring[0] = "S") and (serstring[1] = "O") then     'Read output Roller/Shutter in Large Installation mode                                                                                          '"ro
        cid=serstring[2]
        ic=serstring[3]+1
        gosub SO_linux2                                       'All output modules           
      elseif (serstring[0] = "R") and (serstring[1] = "E") then     'Read Eeprom
        gosub instr_RE                                              '"RE       
      elseif (serstring[0] = "W") and (serstring[1] = "E") then     'Write Eeprom
        gosub instr_WE                                              '"WE
      elseif (serstring[0] = "e") and (serstring[1] = "c") then     'Error Clear (clear all error counters)
        gosub instr_ec                                              '"ec  
      elseif (serstring[0] = "A") and (serstring[1] = "E") then     'Activate data in Eeprom (copy into RAM)                          '"AE
        gosub activate_eeprom 
        gosub send_AE 
      elseif (serstring[0] = "a") and (serstring[1] = "e") then     'Activate data in Eeprom for RTD10 function                       '"ae
        gosub OnOffAirco 
        gosub send_AE2           
      elseif (serstring[0] = "A") and (serstring[1] = "D") then     'Activate Device                                                  '"AD
        gosub activate_device
        gosub send_AD 
      elseif (serstring[0] = "A") and (serstring[1] = "R") then     '"AR Airco read                                                  '"AD
        gosub instr_AR 
      elseif (serstring[0] = "A") and (serstring[1] = "W") then     '"AW Airco write                                                 '"AD
        gosub instr_AW                       
      elseif (serstring[0] = "C") and (serstring[1] = "M") then     'Command mode (switch between advanced mode and simple mode (command line)                                      
        if serstring[2]="1" then                                    '"CM
          mode_com=1                                                'advanced mode - API
        else
          mode_com=0                                                'simple mode CLI and fixed length command mode
          gosub send_mes_ok
          ApiExit=1   
        endif
      elseif (serstring[0] = "c") and (serstring[1] = "m") then     'Change Number of char to be received for Data upload bootloader slave modules
        gosub instr_cm                                              '"cm      
      elseif (serstring[0] = "R") and (serstring[1] = "T") then     'Read Temperature "RT"
        a=0                                                         'read temperature
        CIDused=0
        gosub start_serstring                                                  
      elseif (serstring[0] = "r") and (serstring[1] = "n") then     'Read number of input and output modules
        cid=serstring[2]                                            '"rn
        gosub instr_rn      
      elseif (serstring[0] = "r") and (serstring[1] = "i") then     'read output Data, detailed information of 1 output 
        CIDused=1                                                   '"ri
        cid=serstring[2]
        x=serstring[3]
        gosub send_ri            
      elseif (serstring[0] = "R") and (serstring[1] = "V") then     'Read Validation Bits
        gosub instr_RV                                              '"RV     
      elseif (serstring[0] = "I") and (serstring[1] = "N") then     'Execute Led Indicate Instruction 
        gosub instr_IN                                              '"IN             
      elseif (serstring[0] = "D") and (serstring[1] = "A") then     'Discover stArt "DA"                   
        gosub bus_init
        x="D"
        y="A" 
        gosub return_api_ok        
      elseif (serstring[0] = "D") and (serstring[1] = "O") then     'Discover stOp "DO"                    
        gosub bus_live
        x="D"
        y="O" 
        gosub return_api_ok 
      elseif (serstring[0] = "A") and (serstring[1] = "V") then     'Add Virtual Module "AV"                    
        if serstring[3]="i" or serstring[3]="d" or serstring[3]="o" then
          e=serstring[3]
          gosub add_virtual_m
          gosub add_m
          x="A"
          y="V"
          gosub return_api_ok
        endif           
    endif
  endif 
  if Mode_com=0 and ApiExit=0 then                                  'simple command (CLI) received     
    for j=0 to (Buffer_size-1)  
      recchar[j]=serstring[j]
    next j
    if recchar[0]=13 then
      gosub send_mes_ok
    else
      if echoonbit=1 and Mode_com=0 then
        Hserout2 [10]
      endif   
      gosub interprete_cmd                                          'interprete command
    endif
    gosub Empty_RecInstr
  endif
  PointerSer2=0
  RecSer2=0
  ApiExit=0
  RCSTA2.4=1                                                        'enable receiving serial 2  
ENDIF
end_rs232_interprete:
return

instr_reset:
  gosub send_reset
  pause 1000
  asm
    reset
  endasm
return

instr_ec:
  if ok=1 then
    ok=0
    gosub error_clear
    ok=1
  else
    gosub error_clear
  endif
  x="e"
  y="c" 
  gosub return_api_ok
return

return_api_ok:
  gosub empty_e
  e[0]=x
  e[1]=y
  e[2]=cid
  e[3]="O"
  e[4]="K"
  gosub send_api 
return

instr_AR:     '"AR
  CID=Serstring[2]
  u="A"
  v="R"
  gosub instr_AR_AW_sub
return

instr_AW:     '"AW
  if Serstring[3]<24 then  'Thermostat Nr must be below 24
    u=Serstring[3]
    if Serstring[4]=0 then
      Airco[u]=0           'Switch off airco with RTD-10
    else
      Airco[u]=1           'Switch on airco with RTD-10
    endif
  endif
  CID=Serstring[2]
  u="A"
  v="W"
  gosub instr_AR_AW_sub
return

instr_AR_AW_sub:
  Hserout2 [u,v,cid]
  for a=0 to (Controllers-1)
    hserout2 [Airco[a]]
  next a 
  gosub display_LF_CR
return

instr_RE:
  gosub empty_e
  e[0]="R"
  e[1]="E"
  e[2]=cid
  e[3]=serstring[3]
  e[4]=serstring[4]
  e[5]=serstring[5] 
  if serstring[5]<11 then
    gosub Display_RE_WE   
  endif
return

Display_RE_WE: 
    for ic=1 to serstring[5]
      eep_addr.byte0 = serstring[4]+ic-1
      eep_addr.byte1 = serstring[3]
      Gosub read_eeprom                     'Read data being written and send it back
      e[5+ic]=i2cdata
    next ic
    gosub send_api
    cid=0
return

instr_WE:
  if serstring[5]<11 and serstring[5]>0 then
    gosub empty_e
    e[0]="W"
    e[1]="E"
    e[2]=cid   
    for ic=1 to serstring[5]
      eep_addr.byte0 = serstring[4]+ic-1
      eep_addr.byte1 = serstring[3]
      i2cdata=Serstring[5+ic]
      Gosub write_eeprom                    'Write data to eeprom
    next ic
    gosub Display_RE_WE
  endif  
return

instr_RS:
  for j=2 to 17  
    recchar[j]=serstring[j]
  next j
  charpointer=2
  reccounter=17
  gosub convert_dec        
  if Digittotal[0]<controllers then
    t_word=digittotal[0]
    pid=t_word.byte0
    CIDused=0
    gosub send_RS
  endif  
return

instr_RS2:
  CID=serstring[2]
  pid=serstring[3]        
  if pid<controllers then
    CIDused=1
    gosub send_RS
  endif
return

instr_RD:
  for j=2 to 17  
    recchar[j]=serstring[j]
  next j
  charpointer=2
  reccounter=17
  gosub convert_dec        
  if Digittotal[0]<240 then
    t_word=digittotal[0]
    x=t_word.byte0
    gosub send_RD
  endif
Return

send_ri:
  y=sel_output[x] 
  CRC=x+y 
  Hserout2 ["ri",CID,x,y]  
  CurrentInput=x
  Queue_module_nr=(x/8)+1
  Queue_input_nr=x//8
  AddToQueue=0
  gosub input_action_eeprom                 'Add full action list of the requested input  
  a=x
  length=8
  Spaces=1 
  gosub eeprom_input_address
  gosub display_name
  gosub send_crc
  gosub display_LF_CR
return

send_RD:
  CRC=0
  y=mod_ID0[30+(x/8)]                       'Dimmer or output?
  u=x//8
  v=x/8
  z=out[v]>>u                               'Status output on (1) or off (0)
  z=z&%00000001
  timer=x
  gosub Timer_value_read                    'Retreive Timer Value
  t_word=timer
  t_word2=timer_cd[x] 
  'eep_addr.byte1=33+v
  'eep_addr.byte0=173+u                      'address (Max Power), this eeprom address is now in use for LargeInstallation
  'gosub read_eeprom
  q=255
  eep_addr.byte0=157+u                      'address (Floor Level)
  gosub read_eeprom
  t=i2cdata
  eep_addr.byte0=149+u                      'address (Output type: 0-127 ->output, 128-255 ->Light)
  gosub read_eeprom
  d=i2cdata
  eep_addr.byte0=165+u                      'address (Menu Position)
  gosub read_eeprom
  s=i2cdata  
  if d>1 then d=1  
  CRC=x+y+d+t_word.byte1+t_word.byte0+t_word2.byte1+t_word2.byte0+z
  CRC=CRC+dimmer_value[x]+controller_out+q+t+input_pressed+sel_output[input_pressed]+s  
  if CIDused=1 then
    Hserout2 ["ro",CID]
  else
    Hserout2 ["RD"]
  endif  
  Hserout2 [x,y,d,t_word.byte1,t_word.byte0,t_word2.byte1,t_word2.byte0,z,dimmer_value[x],controller_out,q,t,input_pressed,sel_output[input_pressed],s]
  a=x
  length=16
  Spaces=1 
  gosub eeprom_output_address
  gosub display_name
  gosub send_crc
  gosub display_LF_CR
return

instr_WD:
  for j=2 to 17  
    recchar[j]=serstring[j]
  next j
  charpointer=2
  reccounter=17
  gosub convert_dec
  if Digittotal[0]<240 and digitcount=3 then
    t_word=digittotal[0]
    x=t_word.byte0
    u=x//8
    v=x/8         
    t_word=digittotal[1]
    a=t_word.byte0                          'instruction 0 to ...
    t_word2=digittotal[2]
    i2cdata=t_word2.byte0                   'data to be writen       
    if a=0 then                             'Timer value     
      timer_cd[x]=t_word2 
      eep_addr.byte1=33+v                   'page
      eep_addr.byte0=4+(u*2)
      i2cdata=t_word2.byte0
      gosub write_eeprom
      i2cdata=t_word2.byte1
      eep_addr.byte0=5+(u*2)
      gosub write_eeprom           
    endif
    if a=1 then                             'Output Type     
      eep_addr.byte1=33+v
      eep_addr.byte0=149+u                  'address (Output Type)
      gosub write_eeprom
    endif
    'if a=2 then                             'Max Power, address is now in use by large installations     
    ' eep_addr.byte1=33+v
    ' eep_addr.byte0=173+u                   'address (Max Power)
    ' gosub write_eeprom
    'endif
    if a=3 then                             'Floor Level     
      eep_addr.byte1=33+v
      eep_addr.byte0=157+u                  'address (Floor Level)
      gosub write_eeprom
    endif
    if a=4 then                             'Link an input to the current output
      y=i2cdata/8                           'Output needs to be written at the input page
      z=i2cdata//8
      eep_addr.byte1=2+y                    'page 2 to 31
      eep_addr.byte0=4+z                    'byte 4 to 11
      i2cdata=x                             'Output needs to be written at the input page
      gosub write_eeprom
      gosub activate_eeprom
    endif 
    if a=5 then                             'Menu Position     
      eep_addr.byte1=33+v
      eep_addr.byte0=165+u                  'address (Menu position)
      gosub write_eeprom
    endif                          
    gosub send_OO
  endif        
Return

instr_VS:
  cid=serstring[2]
  x=serstring[3]  'Sensor Number
  if VirtualSensor[x]=1 then
    Temperature[x]=serstring[4]
    Humidity[x]=serstring[5]
    ldr[x]=serstring[6]
  endif
  hserout2["VS",CID,x,Temperature[x],Humidity[x],ldr[x],0,0,0,0,0,0,0,0,0,13,10]  
return

instr_wsl:
  cid=serstring[2]
  digittotal[0]=serstring[3]
  digittotal[1]=serstring[4]
  digittotal[2]=serstring[5]
  digitcount=3
  instrOK=0
  gosub interprete_thermostat_instr
  if instrOK=1 then
    Gosub send_ws
  endif      
return

instr_WS:
  for j=2 to 17  
    recchar[j]=serstring[j]
  next j
  charpointer=2
  reccounter=17
  gosub convert_dec
  instrOK=0
  gosub interprete_thermostat_instr
  if instrOK=1 then
    gosub send_RS
  endif 
return

thermostat_program_data:
  if digitcount=3 and digittotal[0]<controllers then
    gosub interprete_thermostat_instr  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

interprete_thermostat_instr:
  if Digittotal[0]<controllers and digitcount=3 then
    t_word=digittotal[0]
    pid=t_word.byte0
    t_word=digittotal[1]
    a=t_word.byte0                          'instruction 0 to ...
    t_word=digittotal[2]
    i2cdata=t_word.byte0                    'data to be writen       
    if a=0 then                             'current setpoint
      setpt[pid]=i2cdata
      i2caddr=40+pid
      gosub write_i2c_2                     'write setpoint in RAM memory of DS1307
    endif  
    if a>0 and a<7 then                     'programmed setpoint
      eep_addr.byte1 = 142+(59*thermostatCooling)                 'page 142 or 201
      eep_addr.byte0 = (32*a)+pid
      gosub write_eeprom
    endif
    if a>6 and a<18 then
      if a=7 then                           'P parameter
        eep_addr.byte0=pid*4                'address
        eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200
        gosub write_eeprom           
      elseif a=8 then                       'I parameter
        eep_addr.byte0=(pid*4)+1            'address
        eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200
        gosub write_eeprom             
      elseif a=9 then                       'Int parameter
        eep_addr.byte0=(pid*4)+3            'address
        eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200  
        gosub write_eeprom                      
      elseIF a=10 then                      'D parameter
        eep_addr.byte0=(pid*4)+2            'address
        eep_addr.byte1=141+(59*thermostatCooling)                  'page 141 or 200   
        gosub write_eeprom            
      elseif a=11 then                      'Temp threshold
        eep_addr.byte0=17                   'address
        eep_addr.byte1=0                    'page
        gosub write_eeprom 
        temp_threshold=i2cdata
      elseif a=12 then                      'Day
        i2caddr = 3                         'write days
        t_word=i2cdata
        gosub DS1307_write 
        gosub read_day
        gosub thermostat_timing
      elseif a=13 then                      'Time:Hours
        i2caddr = 2                         'write hours
        t_word=i2cdata
        gosub DS1307_write 
        gosub read_hours
        gosub thermostat_timing
      elseif a=14 then                      'Time:Minutes
        i2caddr = 1                         'write minutes
        t_word=i2cdata
        gosub DS1307_write 
        gosub read_minutes   
        gosub thermostat_timing
      elseif a=15 then                      'Room sensor
        ThermostatSensor[pid]=i2cdata
        eep_addr.byte1=144+(59*thermostatCooling)                  'Page 144 or 203
        eep_addr.byte0=pid+8                'address
        gosub write_eeprom            
      elseif a=16 then                      'Output1
        thermostat[pid]=i2cdata
        eep_addr.byte1=142+(59*thermostatCooling)                  'Page 142 or 201
        eep_addr.byte0=pid                  'address
        gosub write_eeprom            
      elseif a=17 then                      'Output2
        thermostat2[pid]=i2cdata 
        eep_addr.byte1=142+(59*thermostatCooling)                  'Page 142 or 201
        eep_addr.byte0=pid+224              'address
        gosub write_eeprom
      endif
    endif    
    if a>17 and a<46  then                  'programmed timings
      gosub programmed_timings
      gosub write_eeprom                                                                                  
    endif
    if a>45 and a<67 then                   'Programmed temperature (day1/day2/Night) for every day of the week
      gosub programmed_temperature
      gosub write_eeprom        
    endif
    if a=67 then                            'Write the Multi-Tenant configuration byte
      eep_addr.byte1 = 199                  'page 199
      eep_addr.byte0 = 32+pid
      gosub write_eeprom
      
    endif                       
    PidCalcCheck=1 
    instrOK=1
  else
    error_code=30
    gosub send_error          
  endif
return

programmed_timings:
  t=(a-18)//4
  u=(a-18)/4 
  eep_addr.byte1 = 189 + (u/2) +(17*thermostatCooling)      'Start page 189 or 206
  eep_addr.byte0 = (128*(u//2))+(pid*4)+t
return

programmed_temperature:
  if a<53 then                              'day1
    eep_addr.byte1=196+(14*thermostatCooling)        'page 196 or 210
    eep_addr.byte0=((a-46)*32)+pid
  elseif a<60 then                          'day2
    eep_addr.byte1=197+(14*thermostatCooling)        'page 197 or 211
    eep_addr.byte0=((a-53)*32)+pid
  else                                      'night
    eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212
    eep_addr.byte0=((a-60)*32)+pid    
  endif 
return

instr_RV:
  error_code=255
  for j=2 to 15  
    recchar[j]=serstring[j]
  next j
  charpointer=2
  reccounter=15  
  gosub convert_dec      
  if digittotal[0]<32 then 
    t_word=digittotal[0]
    x=t_word.byte0
    serstring[2]=" "
    for ic=0 to 7
      serstring[3+ic]=val_bit[(x*8)+ic]
    next ic
    for ic=11 to 15
      serstring[ic]="-"
    next ic
    gosub send_serstring
  endif
return

print_ds1307:
  for ic=0 to 6 
    i2caddr = ic                            'read seconds(0), minutes(1), etc
    i2cdata = 0    
    gosub read_i2c_2
    x=i2cdata
    gosub Calc_time
    serstring[ic]=y
  next ic 
return

instr_st:
  cid=serstring[2]
  for ic=0 to 6
    i2caddr = ic                            'write seconds (0), Minutes (1), Hours (2), ... 
    t_word=serstring[ic+3]
    gosub DS1307_write
  next ic                           
  gosub read_minutes
  gosub read_hours
  gosub read_day
  gosub print_ds1307
  gosub empty_e
  e[0]="s"
  e[1]="t"
  e[2]=cid
  e[3]=serstring[0]
  e[4]=serstring[1]
  e[5]=serstring[2]
  e[6]=serstring[3]
  e[7]=serstring[4]
  e[8]=serstring[5]
  e[9]=serstring[6]
  gosub send_api    
return

instr_cm:
  If serstring[3]=77 then                   'Number of characters for communication
    BootLoaderMode=1
    MaxChar=77 
  else 
    MaxChar=18
  endif
  if serstring[4]=0 then                    'BootLoaderMode
    'BootLoaderMode=0                        'Normal operation
    u=0
    gosub Set_errorbit
  else
    RS485Busy=0
    u=1
    gosub Set_errorbit    
  endif  
  gosub empty_e
  e[0]="c"
  e[1]="m"
  e[2]=cid
  e[3]=MaxChar
  e[4]=BootLoaderMode
  gosub send_API
return


Set_errorbit:
  for s=1 to controller_out
    errorbit[29+s]=u
  next s
  for s=1 to controller_in
    errorbit[s-1]=u
  next s  
return

instr_F:
  RS485Message="F"
  if serstring[1]="D" then                  '"FD" Data Upload firmware
    gosub send_FD_Data
  else                                      'All other "F instructions
    gosub send_Fx_Data
  endif  
  gosub prepare_rs485_receive   
return

send_F_String:
  hserout ["ST",serstring[3],serstring[4],serstring[5],serstring[6],serstring[0],serstring[1]]
return

send_FD_Data:
  high RS485_mode                           'Send mode
  gosub send_F_String
  for t=7 to 75
    hserout [serstring[t]]
  next t
  hserout [13,10,13,10,13,10]
  'pauseus 100
  low RS485_mode                            'Receive mode
return

send_Fx_Data:
  if serstring[1]="R" then                  '"FR
    BootLoaderMode=1                        'Slave BootloaderMode, stop normal communication with input and output modules,silent mode
  endif
  if serstring[1]="G" then                  '"FG
    BootLoaderMode=0                        'Normal mode again so modules will be scant again
  endif  
  high RS485_mode                           'Send mode
  gosub send_F_String
  for t=7 to 15
    hserout [serstring[t]]
  next t
  hserout [13,10,13,10,13,10]
  'pauseus 100
  low RS485_mode                            'Receive mode
return

send_API:
  hserout2 [e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15],13,10]
return

send_rs485_short:
  high RS485_mode                           'Send mode
  hserout ["AAAST",e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],13,10,13,10]
  'pauseus 100
  low RS485_mode                            'Receive mode
return

send_rs485_long:
  high RS485_mode                           'Send mode
  hserout ["AAAST",e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15],e[16],e[17],13,10,13,10]
  'pauseus 100
  low RS485_mode                            'Receive mode   
return

instr_xL2:
  if (serstring[0] = "P") then              'Pulse Counter List 
    gosub send_PL                           '"PL             
  elseif (serstring[0] = "O") then          'Sent Output List 
    gosub send_OL                           '"OL      
  elseif (serstring[0] = "T") then          'Read Thermostat sensor Temperature list "TL"
    a=5                                     'read temperature
    CIDused=1                               'CID is used
    gosub start_serstring
  elseif (serstring[0] = "S") then          'Read Thermostat Setpoint Temperature list '"SL
    a=6                                     'read setpoint
    CIDused=1
    gosub start_serstring  
  elseif (serstring[0] = "E") then          'Read Eeprom List (256 bytes)
    cid=serstring[2]                        '"EL
    gosub instr_EL 
  elseif (serstring[0] = "V") then          'Read Virtual Sensor List (32 bytes)
    cid=serstring[2]                        '"VL
    gosub instr_VL 
  elseif (serstring[0] = "p") then          'Read Permanent thermostat List (32 bytes)
    cid=serstring[2]                        '"pL
    gosub instr_pL       
  endif
return

instr_xl:
  if (serstring[0] = "t") then              'Read thermostat list
    gosub instr_tl                          '"tl"                                                    
  elseif (serstring[0] = "h") then          'Read humidity list
    gosub instr_hl                          '"hl"      
  elseif (serstring[0] = "c") then          'Read temperature list
    gosub instr_cl                          '"cl"      
  elseif (serstring[0] = "b") then          'Read brightness list
    gosub instr_bl                          '"bl"                                           
  elseif (serstring[0] = "e") then          'Read error list
    gosub instr_el2                         '"el" 
  elseif (serstring[0] = "m") then          'Read Multi-Tenant configuration byte
    gosub instr_ml                          '"ml"         
  endif  
return

instr_tl:
  CID=Serstring[2]
  CRC=0
  CRC=ThermostatMode+temperature[outside_sensor]
  Hserout2 ["tl",cid,ThermostatMode,temperature[outside_sensor]]
  for a=0 to (controllers-1)
    b=thermostatsensor[a]
    hserout2 [temperature[b]]
    CRC=CRC+temperature[b]
  next a 
  for a=0 to (controllers-1)
    hserout2 [setpt[a]]
    CRC=CRC+setpt[a]
  next a
  gosub send_crc
  gosub display_LF_CR
  gosub display_LF_CR 
return

instr_ml:
  CID=Serstring[2]
  CRC=0
  Hserout2 ["ml",cid]
  for a=0 to (controllers-1)
    eep_addr.byte1=199                                'page 199
    eep_addr.byte0=a+32                               'byte
    gosub read_eeprom
    CRC=CRC+i2cdata
    gosub print_i2cdata
  next a
  gosub send_crc
  gosub display_LF_CR
  gosub display_LF_CR   
return

instr_el2:
  CID=Serstring[2]
  CRC=0
  CRC=Controller_in + Controller_out
  Hserout2 ["el",cid,Controller_in+controller_out]
  if controller_in>0 then
    for a=0 to (controller_in-1)
      b=a
      gosub print_el
    next a
  endif   
  if controller_out>0 then
    for a=0 to (controller_out-1)
      b=a+30
      gosub print_el
    next a
  endif
  gosub send_crc
  gosub display_LF_CR    
return

print_el:
  t_word=ErrorCount[b]
  hserout2 [Mod_id0[b],a,t_word.byte1,t_word.byte0]
  CRC=CRC+Mod_id0[b]+a+ErrorCount[b]
return

instr_hl:
  CID=Serstring[2]
  CRC=0
  Hserout2 ["hl",cid]
  for a=0 to 31
    hserout2 [humidity[a]]
    CRC=CRC+humidity[a]
  next a 
  gosub send_crc
  gosub display_LF_CR 
return

instr_cl:
  CID=Serstring[2]
  CRC=0
  Hserout2 ["cl",cid]
  for a=0 to 31
    hserout2 [temperature[a]]
    CRC=CRC+temperature[a]
  next a 
  gosub send_crc
  gosub display_LF_CR 
return

instr_bl:
  CID=Serstring[2]
  CRC=0
  Hserout2 ["bl",cid]
  for a=0 to 31
    hserout2 [ldr[a]]
    CRC=CRC+ldr[a]
  next a 
  gosub send_crc
  gosub display_LF_CR 
return

instr_TM:
  CID=Serstring[2]
  gosub empty_e
  e[0]="T"
  e[1]="M"
  e[2]=cid
  e[3]=ThermostatMode
  gosub send_api   
return

instr_BA:
  CID=Serstring[2]
  gosub Increase_queue_pointer
  queue_type[queue_pointer]=Serstring[3]
  queue_action[queue_pointer]=Serstring[4]
  x="B"
  y="A" 
  gosub return_api_ok  
return

instr_IN:
  CID=Serstring[2]
  a=Serstring[3]
  b=Serstring[4]
  gosub normal_Powerstate                   'Put leds of all modules in normal powerstate
  if a<3 then
    IndicateInput=a.bit0
    IndicateTemperature=a.BIT1
    Indicate=b
    if a=0 then
      write_yes=1
      write_yes_mod[indicate/8]=1     
    endif  
    x="I"
    y="N" 
    gosub return_api_ok
  endif    
return

instr_rn:
  CID=Serstring[2]
  gosub empty_e
  e[0]="r"
  e[1]="n"
  e[2]=cid
  e[3]=controller_in
  e[4]=controller_out
  e[5]=controller_out_rs
  gosub send_api    
return

instr_IF:
  error_code=255
  for j=3 to 17  
    recchar[j]=serstring[j]
  next j
  charpointer=3
  reccounter=17
  if serstring[2]="D" then                  'Output ON with Dimmer value
    gosub convert_dec
    t_word=digittotal[0]
    a=t_word.byte0
    t_word=digittotal[1]
    b=t_word.byte0
    digitcount=2
    gosub output_on  
  endif
  if serstring[2]="Q" then                  'Add instruction to the queue
    gosub convert_dec
    t_word=digittotal[0]
    a=t_word.byte0
    t_word=digittotal[1]
    b=t_word.byte0       
    gosub Increase_queue_pointer
    queue_type[queue_pointer]=a
    queue_action[queue_pointer]=b        
  endif  
return

instr_DI:
  if serstring[2]="+" then  
    digitcount=2
    digittotal[0]=LastDimmer
    digittotal[1]=3                         'step 3
    gosub dim_plus
  endif
  if serstring[2]="-" then
    digitcount=2
    digittotal[0]=LastDimmer
    digittotal[1]=3                         'step 3
    gosub dim_min    
  endif
  if serstring[2]="*" then                  'max dimmer
    dimmer_value[LastDimmer]=63
    write_yes = 1
    out_update[LastDimmer]=1                           'write outputs 
    for ic=1 to controller_out
      write_yes_mod[ic-1]=1
    next ic   
  endif
return

start_serstring:
  z=serstring[2+CIDused]
  x=12*z
  y=11+(z*12)
  if a<4 and z=2 then
    x=24
    y=29
    gosub fill_serstring
    gosub send_serstring       
  endif
  if a<4 and z<2 then
    gosub fill_serstring
    gosub send_serstring      
  endif
  if (a=5 or a=6) and (z<2) then            'Read thermostat Temperature or setpoint
    gosub fill_serstring
    gosub send_serstring        
  endif
  if (a=5 or a=6) and (z=2) then
    x=24
    y=31  
    gosub fill_serstring
    gosub send_serstring  
  endif             
return
                          
fill_serstring:
  for ic=0 to 12
    serstring[ic+3+CIDused]=255             'sensor not connected
  next ic
  for ic=x to y
    gosub fill_value
  next ic
return

fill_value:
  if a=0 then                               'read temperature
    serstring[ic-(z*12)+3]=temperature[ic]
  elseif a=1 then                           'read brightness
    serstring[ic-(z*12)+3]=ldr[ic]
  elseif a=2 then                           'read humidity
    serstring[ic-(z*12)+3]=humidity[ic]
  elseif a=5 then                           'read thermostat sensor temperature
    b=thermostatsensor[ic]
    serstring[ic-(z*12)+4]=temperature[b]
  elseif a=6 then                           'read thermostat setpoint temperature
    serstring[ic-(z*12)+4]=setpt[ic]      
  endif       
return

send_serstring:
  hserout2 [serstring[0],Serstring[1],Serstring[2],Serstring[3],serstring[4],Serstring[5],Serstring[6],Serstring[7],Serstring[8],Serstring[9],Serstring[10],Serstring[11],Serstring[12],Serstring[13],Serstring[14],Serstring[15],13,10]
return

activate_device:
  high RS485_mode                      
  e[0]="A"
  e[1]="D"
  e[2]=serstring[3]
  e[3]=serstring[4]
  e[4]=serstring[5]
  e[5]=serstring[6]
  e[6]=0
  e[7]=0
  e[8]=0
  gosub send_rs485_long 
return

' ---- List CLI instructions ------------------------------------------------
' For more details see http://wiki.openmotics.com/index.php/CLI_Reference_Guide

interprete_cmd: 
    low led_red 
    instruction=255                         'no instruction match found yet
    error_code=255                          'No error
    for j=0 to (nr_of_cmd-1)                'max of 160 instructions defined (if more needed, change constant "nr_of_cmd")
      TestChar[j]=1
    next j
    for j=0 to Buffer_size
      lookup j,["exit%"],test
      cmd=0
      gosub test_command   
      lookup j,["output off %"],test
      cmd=1
      gosub test_command
      lookup j,["output on %"],test
      cmd=2
      gosub test_command
      lookup j,["basic action activate %"],test
      cmd=3
      gosub test_command
      lookup j,["module discover start%"],test
      cmd=4
      gosub test_command
      lookup j,["module discover stop%"],test
      cmd=5
      gosub test_command      
      lookup j,["input action read %"],test
      cmd=6
      gosub test_command
      lookup j,["input action write %"],test
      cmd=7
      gosub test_command
      lookup j,["output status read %"],test
      cmd=8
      gosub test_command       
      lookup j,["output timer read %"],test
      cmd=9
      gosub test_command
      lookup j,["output timer write %"],test
      cmd=10
      gosub test_command 
      lookup j,["eeprom read %"],test
      cmd=11
      gosub test_command 
      lookup j,["eeprom write %"],test
      cmd=12
      gosub test_command 
      lookup j,["eeprom activate%"],test
      cmd=13
      gosub test_command 
      lookup j,["debug on%"],test
      cmd=14
      gosub test_command
      lookup j,["debug off%"],test
      cmd=15
      gosub test_command           
      lookup j,["action read %"],test
      cmd=16
      gosub test_command             
      'lookup j,["action write %"],test
      'cmd=17
      'gosub test_command
      'lookup j,["action activate %"],test
      'cmd=18
      'gosub test_command
      lookup j,["decision read %"],test
      cmd=19
      gosub test_command
      'lookup j,["decision write %"],test
      'cmd=20
      'gosub test_command
      'lookup j,["decision activate %"],test
      'cmd=21
      'gosub test_command 
      lookup j,["group read %"],test
      cmd=22
      gosub test_command
      lookup j,["group write %"],test
      cmd=23
      gosub test_command
      lookup j,["group activate %"],test
      cmd=24
      gosub test_command 
      lookup j,["input link read %"],test
      cmd=25
      gosub test_command
      lookup j,["input link write %"],test
      cmd=26
      gosub test_command
      lookup j,["discover can control %"],test
      cmd=27
      gosub test_command
      'lookup j,["output dim- %"],test
      'cmd=28
      'gosub test_command
      lookup j,["output all off%"],test
      cmd=29
      gosub test_command 
      lookup j,["fixl%"],test
      cmd=30
      gosub test_command 
      lookup j,["varl%"],test
      cmd=31
      gosub test_command
      lookup j,["output status on%"],test
      cmd=32
      gosub test_command
      lookup j,["input link list%"],test
      cmd=33
      gosub test_command
      lookup j,["validation bit read %"],test
      cmd=34
      gosub test_command
      lookup j,["validation bit write %"],test
      cmd=35
      gosub test_command 
      'lookup j,["input address read %"],test
      'cmd=38
      'gosub test_command 
      lookup j,["input address write %"],test
      cmd=39
      gosub test_command 
      'lookup j,["output address read %"],test
      'cmd=40
      'gosub test_command 
      lookup j,["output address write %"],test
      cmd=41
      gosub test_command
      'lookup j,["input address list%"],test
      'cmd=42
      'gosub test_command
      'lookup j,["output address list%"],test
      'cmd=43
      'gosub test_command
      lookup j,["input number modules read%"],test
      cmd=44
      gosub test_command
      lookup j,["input number modules write %"],test
      cmd=45
      gosub test_command 
      lookup j,["output number modules read%"],test
      cmd=46
      gosub test_command
      lookup j,["output number modules write %"],test
      cmd=47
      gosub test_command
      lookup j,["time read%"],test
      cmd=48
      gosub test_command
      lookup j,["time write %"],test
      cmd=49
      gosub test_command
      lookup j,["schedule read %"],test
      cmd=50
      gosub test_command
      lookup j,["schedule write %"],test
      cmd=51
      gosub test_command       
      lookup j,["schedule activate %"],test
      cmd=52
      gosub test_command
      lookup j,["schedule queue list%"],test
      cmd=53
      gosub test_command
      lookup j,["schedule queue delete %"],test
      cmd=54
      gosub test_command
      lookup j,["startup read %"],test
      cmd=55
      gosub test_command
      lookup j,["startup write %"],test
      cmd=56
      gosub test_command 
      lookup j,["startup list%"],test
      cmd=57
      gosub test_command
      lookup j,["startup activate%"],test
      cmd=58
      gosub test_command 
      'lookup j,["brightness read%"],test
      'cmd=59
      'gosub test_command
      lookup j,["brightness list%"],test
      cmd=60
      gosub test_command
      'lookup j,["temperature read%"],test
      'cmd=61
      'gosub test_command
      lookup j,["temperature list%"],test
      cmd=62
      gosub test_command
      lookup j,["error list%"],test
      cmd=63
      gosub test_command
      lookup j,["error clear%"],test
      cmd=64
      gosub test_command
      lookup j,["input debug on%"],test
      cmd=65
      gosub test_command
      lookup j,["input debug off%"],test
      cmd=66
      gosub test_command
      'lookup j,["humidity read%"],test
      'cmd=67
      'gosub test_command
      lookup j,["humidity list%"],test
      cmd=68
      gosub test_command
      lookup j,["firmware version%"],test
      cmd=69
      gosub test_command 
      lookup j,["thermostat mode read%"],test
      cmd=70
      gosub test_command
      lookup j,["thermostat details read%"],test
      cmd=71
      gosub test_command
      lookup j,["input list%"],test
      cmd=72
      gosub test_command
      lookup j,["output list%"],test
      cmd=73
      gosub test_command 
      lookup j,["input name write%"],test
      cmd=74
      gosub test_command
      lookup j,["output name write%"],test
      cmd=75
      gosub test_command
      lookup j,["echo on%"],test
      cmd=76
      gosub test_command
      lookup j,["echo off%"],test
      cmd=77
      gosub test_command 
      'lookup j,["dimmer step write%"],test
      'cmd=78
      'gosub test_command 
      'lookup j,["dimmer minimum write%"],test
      'cmd=79
      'gosub test_command 
      'lookup j,["dimmer cycle write%"],test
      'cmd=80
      'gosub test_command 
      'lookup j,["dimmer memory write%"],test
      'cmd=81
      'gosub test_command 
      lookup j,["sensor name write%"],test
      cmd=82
      gosub test_command    
      'lookup j,["dimmer step read%"],test
      'cmd=84
      'gosub test_command 
      'lookup j,["dimmer minimum read%"],test
      'cmd=85
      'gosub test_command 
      'lookup j,["dimmer cycle read%"],test
      'cmd=86
      'gosub test_command 
      'lookup j,["dimmer memory read%"],test
      'cmd=87
      'gosub test_command 
      lookup j,["add virtual module%"],test
      cmd=88
      gosub test_command
'      lookup j,["test stop%"],test
'      cmd=89      
'      gosub test_command 
      'lookup j,["cli mode read%"],test
      'cmd=90      
      'gosub test_command
      'lookup j,["cli mode write%"],test
      'cmd=91      
      'gosub test_command 
      'lookup j,["automatic response read%"],test
      'cmd=92      
      'gosub test_command
      'lookup j,["automatic response write%"],test
      'cmd=93      
      'gosub test_command 
      lookup j,["STRCM0%"],test
      cmd=94      
      gosub test_command
      lookup j,["STRCM1%"],test
      cmd=95      
      gosub test_command
      'delete
      lookup j,["timer queue list%"],test
      cmd=97      
      gosub test_command       
      lookup j,["pulse counter list%"],test
      cmd=98      
      gosub test_command      
      lookup j,["pulse counter link read%"],test
      cmd=99      
      gosub test_command        
      lookup j,["pulse counter link write%"],test
      cmd=100      
      gosub test_command
      lookup j,["pulse counter name write%"],test
      cmd=101      
      gosub test_command
      lookup j,["reset%"],test
      cmd=102      
      gosub test_command
      lookup j,["input enable list%"],test
      cmd=103      
      gosub test_command
      lookup j,["input invert read%"],test
      cmd=104      
      gosub test_command
      lookup j,["input invert write%"],test
      cmd=105      
      gosub test_command 
      lookup j,["sync page%"],test
      cmd=106      
      gosub test_command 
      lookup j,["sync stop%"],test
      cmd=107      
      gosub test_command 
      lookup j,["sync debug on%"],test
      cmd=108      
      gosub test_command 
      lookup j,["sync debug off%"],test
      cmd=109      
      gosub test_command                                 
      lookup j,["current setpoint read%"],test
      cmd=113      
      gosub test_command
      lookup j,["current setpoint write%"],test
      cmd=114      
      gosub test_command
      lookup j,["programmed setpoint read%"],test
      cmd=115      
      gosub test_command
      lookup j,["programmed setpoint write%"],test
      cmd=116      
      gosub test_command 
      lookup j,["pid config list%"],test
      cmd=117      
      gosub test_command
      lookup j,["pid config write%"],test
      cmd=118      
      gosub test_command 
      lookup j,["thermostat link read%"],test
      cmd=119      
      gosub test_command 
      lookup j,["thermostat link write%"],test
      cmd=120      
      gosub test_command 
      lookup j,["pid debug on%"],test
      cmd=121      
      gosub test_command 
      lookup j,["pid debug off%"],test
      cmd=122      
      gosub test_command 
      lookup j,["thermostat list%"],test
      cmd=123      
      gosub test_command  
      lookup j,["rst%"],test
      cmd=124      
      gosub test_command  
      lookup j,["pump group read%"],test
      cmd=125      
      gosub test_command
      lookup j,["pump group write%"],test
      cmd=126      
      gosub test_command 
      lookup j,["pump output read%"],test
      cmd=127      
      gosub test_command 
      lookup j,["pump output write%"],test
      cmd=128      
      gosub test_command  
      'lookup j,["action name write%"],test
      'cmd=129      
      'gosub test_command 
      'lookup j,["action list%"],test
      'cmd=130      
      'gosub test_command 
      lookup j,["group name write%"],test
      cmd=131      
      gosub test_command 
      lookup j,["group list%"],test
      cmd=132      
      gosub test_command 
      'lookup j,["decision name write%"],test
      'cmd=133      
      'gosub test_command
      'lookup j,["decision list%"],test
      'cmd=134      
      'gosub test_command 
      lookup j,["schedule name write%"],test
      cmd=135      
      gosub test_command 
       lookup j,["schedule list%"],test
      cmd=136      
      gosub test_command 
      lookup j,["thermostat name write%"],test
      cmd=137      
      gosub test_command 
      lookup j,["thermostat sensor read%"],test
      cmd=138      
      gosub test_command 
      lookup j,["thermostat sensor write%"],test
      cmd=139      
      gosub test_command                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
      lookup j,["thermostat threshold read%"],test
      cmd=140      
      gosub test_command 
      lookup j,["thermostat threshold write%"],test
      cmd=141      
      gosub test_command
      lookup j,["thermostat outside link read%"],test
      cmd=142      
      gosub test_command 
      lookup j,["thermostat outside link write%"],test
      cmd=143      
      gosub test_command 
      lookup j,["temperature module enable%"],test
      cmd=144      
      gosub test_command 
      lookup j,["temperature module disable%"],test
      cmd=145      
      gosub test_command 
      lookup j,["floor level read%"],test
      cmd=146      
      gosub test_command 
      lookup j,["floor level write%"],test
      cmd=147      
      gosub test_command 
      lookup j,["output type read%"],test
      cmd=148      
      gosub test_command 
      lookup j,["output type write%"],test
      cmd=149      
      gosub test_command 
      lookup j,["thermostat program data%"],test
      cmd=152      
      gosub test_command  
      lookup j,["output indicate%"],test
      cmd=153      
      gosub test_command 
      lookup j,["input indicate%"],test
      cmd=154      
      gosub test_command
      lookup j,["sensor indicate%"],test
      cmd=155      
      gosub test_command 
      lookup j,["pump delay read%"],test
      cmd=156      
      gosub test_command 
      lookup j,["pump delay write%"],test
      cmd=157      
      gosub test_command                                                                                                           
    next j
    gosub Run_instruction
return

Run_instruction:
  if instruction<255  then                  'instruction match
    gosub convert_dec                       'check received values and convert them to decimal
    mode_com=0
    if error_code=255 then                  'No error received 
      if instruction=0 then                 'exit
        gosub exit1             
      elseif instruction=1 then             'output off
        gosub output_off        
      elseif instruction=2 then             'output on
        gosub output_on                  
      elseif instruction=3 then             'action type activate
        gosub basic_action_activate                         
      elseif instruction=4 then             'Module discover start
        gosub module_discover_start
      elseif instruction=5 then             'Module discover stop
        gosub module_discover_stop  
      elseif instruction=6 then             'input action read
        gosub input_action_read   
      elseif instruction=7 then             'input action write
        gosub input_action_write          
      elseif instruction=8 then             'output status read
        gosub output_status_read     
      elseif instruction=9 then             'output timer read
        gosub output_timer_read
      elseif instruction=10 then            'output timer write
        gosub output_timer_write              
      elseif instruction=11 then            'Eeprom read
        gosub eeprom_read           
      elseif instruction=12 then            'Eeprom write
        gosub eeprom_write
      elseif instruction=13 and digitcount=0 then       'eeprom activate
        gosub activate_eeprom
        gosub send_mes_ok    
      elseif instruction=14 and digitcount=0 then       'debug on
        debugmode=1
        gosub send_mes_ok   
      elseif instruction=15 and digitcount=0 then       'debug off
        debugmode=0
        gosub send_mes_ok           
      elseif instruction=16 then            'Action read
        gosub action_read
      'elseif instruction=17 then            'Action write
      '  gosub action_write
      'elseif instruction=18 then            'Action activate
      '  gosub action_activate
      elseif instruction=19 then            'decision read
        gosub decision_read
      'elseif instruction=20 then            'decision write
      '  gosub decision_write
      'elseif instruction=21 then            'decision activate
      '  gosub decision_activate              
      elseif instruction=22 then            'group read
        gosub group_read
      elseif instruction=23 then            'group write
        gosub group_write
      elseif instruction=24 then            'group activate
        gosub group_activate         
      elseif instruction=25 then            'input link read
        gosub input_link_read   
      elseif instruction=26 then            'input link write
        gosub input_link_write   
      elseif instruction=27 then            'dim+
        gosub discover_can_control
      'elseif instruction=28 then            'dim-
      '  gosub dim_min   
      elseif instruction=29 and digitcount=0 then       'all off
        gosub all_outputs_off
        gosub send_mes_ok    
      elseif instruction=30 or instruction=31 then      'fixed length or variable length
        recchar[0]=0
        reccounter=0 
      elseif instruction=32 then            'output status on
        gosub output_status_on  
      elseif instruction=33 then            'input link all read
        gosub input_link_all_read  
      elseif instruction=34 then            'validation bit read
        gosub validation_bit_read  
      elseif instruction=35 then            'validation bit write
        gosub validation_bit_write  
      'elseif instruction=38 then            'input address read
      '  gosub input_address_read  
      elseif instruction=39 then            'input address write
        gosub input_address_write          
      'elseif instruction=40 then            'output address read
      '  gosub output_address_read 
      elseif instruction=41 then            'output address write
        gosub output_address_write  
      'elseif instruction=42 then            'input address list
      '  gosub input_address_list  
      'elseif instruction=43 then            'output address list
      '  gosub output_address_list  
      elseif instruction=44 then            'input number modules read
        gosub input_number_modules_read  
      elseif instruction=45 then            'input number modules write
        gosub input_number_modules_write 
      elseif instruction=46 then            'output number modules read
        gosub output_number_modules_read  
      elseif instruction=47 then            'output number modules write
        gosub output_number_modules_write
      elseif instruction=48 then            'Time read
        gosub time_read
      elseif instruction=49 then            'Time write
        gosub time_write
      elseif instruction=50 then            'schedule read
        gosub schedule_read
      elseif instruction=51 then            'schedule write
        gosub schedule_write
      elseif instruction=52 then            'schedule activate
        gosub schedule_activate        
      elseif instruction=53 then            'schedule queue list
        gosub schedule_queue_list
      elseif instruction=54 then            'schedule queue delete
        gosub schedule_queue_delete 
      elseif instruction=55 then            'startup read
        gosub startup_read
      elseif instruction=56 then            'startup write
        gosub startup_write
      elseif instruction=57 then            'startup list
        gosub startup_list
      elseif instruction=58 then            'startup activate
        gosub startup_activate
      'elseif instruction=59 then            'brightness read
      '  gosub brightness_read
      elseif instruction=60 then            'brightness list
        gosub brightness_list 
      'elseif instruction=61 then            'temperature read
      '  gosub temperature_read
      elseif instruction=62 then            'temperature list
        gosub temperature_list
      elseif instruction=63 then            'error list
        gosub error_list
      elseif instruction=64 then            'error clear
        gosub error_clear
      elseif instruction=65 then            'input debug on
        InputDebug=1
        gosub send_mes_ok
      elseif instruction=66 then            'input debug off
        InputDebug=0
        gosub send_mes_ok
      'elseif instruction=67 then            'humidity read
      '  gosub humidity_read
      elseif instruction=68 then            'humidity list
        gosub humidity_list
      elseif instruction=69 then            'Firmware Version
        gosub firmware_version
      elseif instruction=70 then            'thermostat mode read
        gosub thermostat_mode_read
      elseif instruction=71 then            'thermostat details read
        gosub thermostat_details_read 
      elseif instruction=72 then            'input list
        gosub input_list
      elseif instruction=73 then            'output list
        gosub output_list
      elseif instruction=74 then            'input name write
        gosub input_name_write
      elseif instruction=75 then            'output name write
        gosub output_name_write
      elseif instruction=76 then            'put echo on
        gosub echo_on
      elseif instruction=77 then            'put echo off
        gosub echo_off
      'elseif instruction=78 then            'dimmer step
      '  gosub dimmer_step_write
      'elseif instruction=79 then            'dimmer minimum
      '  gosub dimmer_minimum_write 
      'elseif instruction=80 then            'dimmer cycle
      '  gosub dimmer_cycle_write
      'elseif instruction=81 then            'dimmer memory
      '  gosub dimmer_memory_write 
      elseif instruction=82 then            'sensor name write
        gosub sensor_name_write 
      'elseif instruction=84 then            'dimmer step
      '  gosub dimmer_step_read
      'elseif instruction=85 then            'dimmer minimum
      '  gosub dimmer_minimum_read 
      'elseif instruction=86 then            'dimmer cycle
      '  gosub dimmer_cycle_read 
      'elseif instruction=87 then            'dimmer memory
      '  gosub dimmer_memory_read 
      elseif instruction=88 then            'Add virtual module
        gosub add_virtual_module        
 '     elseif instruction=88 then            'test start
 '       gosub test_start 
 '     elseif instruction=89 then            'test stop
 '       gosub test_stop       
      'elseif instruction=90 then            'cli mode read
      '  gosub cli_mode_read           
      'elseif instruction=91 then            'cli mode write
      '  gosub cli_mode_write 
      'elseif instruction=92 then            'automatic response read
      '  gosub automatic_response_read           
      'elseif instruction=93 then            'automatic response write
      '  gosub automatic_response_write
      elseif instruction=94 then            'STRCM0
        gosub strcm0           
      elseif instruction=95 then            'STRCM1
        gosub exit1
      'delete  
      elseif instruction=97 then            
        gosub timer_queue_list        
      elseif instruction=98 then            
        gosub pulse_counter_list
      elseif instruction=99 then            
        gosub pulse_counter_link_read
      elseif instruction=100 then           
        gosub pulse_counter_link_write
      Elseif instruction=101 then           
        gosub pulse_counter_name_write
      elseif instruction=102 then           'reset         
        gosub send_mes_ok
        asm
          reset
        endasm
      elseif instruction=103 then           'input enable list
        gosub input_enable_list
      elseif instruction=104 then           
        gosub input_invert_read
      elseif instruction=105 then           
        gosub input_invert_write
      elseif instruction=106 then           
        gosub sync_page  
      elseif instruction=107 then           
        gosub sync_stop
      elseif instruction=108 then           
        gosub sync_debug_on
      elseif instruction=109 then           
        gosub sync_debug_off                              
      elseif instruction=113 then           
        gosub setpoint_read
      elseif instruction=114 then           
        gosub setpoint_write
      elseif instruction=115 then           
        gosub programmed_setpoint_read
      elseif instruction=116 then           
        gosub programmed_setpoint_write
      elseif instruction=117 then           
        gosub pid_config_list
      elseif instruction=118 then           
        gosub pid_config_write 
      elseif instruction=119 then           
        gosub thermostat_link_read 
      elseif instruction=120 then           
        gosub thermostat_link_write 
      elseif instruction=121 then           
        gosub pid_debug_on
      elseif instruction=122 then           
        gosub pid_debug_off 
      elseif instruction=123 then           
        gosub thermostat_list
      elseif instruction=124 then           
        ResetI2c=1
        gosub send_mes_ok         
      elseif instruction=125 then           
        gosub pump_group_read
      elseif instruction=126 then           
        gosub pump_group_write 
      elseif instruction=127 then           
        gosub pump_output_read
      elseif instruction=128 then           
        gosub pump_output_write  
      'elseif instruction=129 then           
      '  gosub action_name_write
      'elseif instruction=130 then           
      '  gosub action_list 
      elseif instruction=131 then           
        gosub group_name_write
      elseif instruction=132 then           
        gosub group_list
      'elseif instruction=133 then           
      '  gosub decision_name_write
      'elseif instruction=134 then           
      '  gosub decision_list
      elseif instruction=135 then           
        gosub schedule_name_write
      elseif instruction=136 then           
        gosub schedule_list 
      Elseif instruction=137 then           
        gosub thermostat_name_write
      elseif instruction=138 then           
        gosub thermostat_sensor_read
      elseif instruction=139 then           
        gosub thermostat_sensor_write
      elseif instruction=140 then           
        gosub thermostat_threshold_read                            
      elseif instruction=141 then           
        gosub thermostat_threshold_write                           
      elseif instruction=142 then           
        gosub thermostat_outside_link_read                          
      elseif instruction=143 then           
        gosub thermostat_outside_link_write  
      elseif instruction=144 then           
        gosub temperature_module_enable
      elseif instruction=145 then           
        gosub temperature_module_disable
      elseif instruction=146 then           
        gosub floor_level_read
      elseif instruction=147 then           
        gosub floor_level_write
      elseif instruction=148 then           
        gosub output_type_read
      elseif instruction=149 then           
        gosub output_type_write     
      elseif instruction=152 then           
        gosub Thermostat_program_data   
      elseif instruction=153 then           
        gosub Output_Indicate 
      elseif instruction=154 then           
        gosub Input_Indicate 
      elseif instruction=155 then           
        gosub Temperature_Indicate
      elseif instruction=156 then           
        gosub pump_delay_read
      elseif instruction=157 then           
        gosub pump_delay_write                                                                                                        
      endif                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
    endif
  else
    error_code=17
    gosub send_error  
  endif
return

check_button:
  if button2=0 then                         'button is pressed
    if PowerSafe=1 then                     'PowerSafe on modules is activated
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=64          'Switch on leds on all modules for 2 minutes
      queue_action[queue_pointer]=2       
    endif   
  endif
return

'Test_module:
'  if button2=0 then
'    low led_red
'    if TestPhase>0 then
'      if TestOn=0 then                      'switch ON output
'        gosub Increase_queue_pointer
'        queue_type[queue_pointer]=166
'        queue_action[queue_pointer]=TestPhase-1
'        TestON=1
'        hserout2 ["Output ON ",dec (TestPhase-1)," "]
'        a=TestPhase-1
'        length=16
'        gosub display_name
'        gosub display_LF_CR
'      else                                  'switch OFF output
'        gosub Increase_queue_pointer
'        queue_type[queue_pointer]=160
'        queue_action[queue_pointer]=TestPhase-1
'        TestPhase=TestPhase+1
'        TestOn=0
'        hserout2 ["Output OFF ",dec (TestPhase-1)," "]
'        a=TestPhase-1
'        length=16
'        gosub display_name
'        gosub display_LF_CR
'      endif
'    endif
'    if TestPhase=0 then
'      i2cdata=seconds
'      eep_addr.byte1=255                    'Page
'      eep_addr.byte0=255   
'      gosub write_eeprom
'      eep_addr.byte1=255                    'Page
'      eep_addr.byte0=255
'      gosub read_eeprom  
'      if i2cdata=seconds then
'        hserout2 ["Eeprom OK",13,10]  
'      else 
'        hserout2 ["Eeprom not OK",13,10]
'      endif
'      pause 1200
'      gosub read_clock
'      y=seconds
'      if x=y then
'        hserout2 ["Clock not OK",13,10]
'      else
'        hserout2 ["Clock OK",13,10]  
'      endif  
'      gosub all_outputs_off
'      hserout2 ["All Outputs OFF, testing outputs can start ...",13,10]
'      TestPhase=1
'    endif
'    pause 500  
'  endif    
'return

'test_start:
'  TestMode=1                                'Test Mode is activated
'  TestPhase=0                               'Start from the gebinning
'  TestOn=0                                  'Output is not on
'  hserout2 ["Test Mode started, please use button on Master",13,10]
'  gosub send_mes_ok
'return

'test_stop:
'  TestMode=0
'  gosub send_mes_ok
'return

pid_debug_on:
  PidMode=1
  gosub send_mes_ok
return

pid_debug_off:
  PidMode=0
  gosub send_mes_ok
return

'eeprom_write_sub:
'  if digitcount=1 and digittotal[0]>=x and digittotal[0]<=y then
'    eep_addr.byte1=0                        'page
'    eep_addr.byte0=z
'    t_word=digittotal[0]
'    i2cdata=t_word.byte0
'    gosub write_eeprom
'    gosub activate_eeprom       
'    gosub send_mes_ok
'  else
'   error_code=23
'    gosub send_error 
'  endif
'return

strcm0:
  gosub send_mes_ok
return  

'cli_mode_write:
'  x=0
'  y=255
'  z=13                                      'address
'  gosub eeprom_write_sub
'return

'automatic_response_write:
'  x=0
'  y=255
'  z=11                                      'address
'  gosub eeprom_write_sub
'return

'dimmer_memory_write:
'  x=0
'  y=255
'  z=9
'  gosub eeprom_write_sub
'return

'dimmer_minimum_write:
'  x=0
'  y=62
'  z=5
'  gosub eeprom_write_sub
'return

'dimmer_step_write:
'  x=1
'  y=10
'  z=6
'  gosub eeprom_write_sub
'return

'dimmer_cycle_write:
'  x=2
'  y=63
'  z=7
'  gosub eeprom_write_sub
'return

print_i2cdata_ok:
  hserout2 [dec i2cdata,13,10]       
  gosub send_mes_ok
return

'automatic_response_read:
'  eep_addr.byte1=0                          'page
'  eep_addr.byte0=11
'  gosub read_eeprom
'  gosub print_i2cdata_ok
'return

'cli_mode_read:
'  eep_addr.byte1=0                          'page
'  eep_addr.byte0=13
'  gosub read_eeprom
'  hserout2 [dec i2cdata," ",str mode,13,10]
'return

'dimmer_memory_read:
'  eep_addr.byte1=0                          'page
'  eep_addr.byte0=9
'  gosub read_eeprom
'  gosub print_i2cdata_ok
'return

'dimmer_minimum_read:
'  eep_addr.byte1=0                          'page
'  eep_addr.byte0=5
'  gosub read_eeprom
'  gosub print_i2cdata_ok
'return

'dimmer_step_read:
'  eep_addr.byte1=0                          'page
'  eep_addr.byte0=6
'  gosub read_eeprom
'  gosub print_i2cdata_ok
'return

'dimmer_cycle_read:
'  hserout2 [dec dim_cycle,13,10]       
'  gosub send_mes_ok  
'return

thermostat_threshold_read:
  x=Temp_threshold
  gosub temperature_display_sub
  gosub display_LF_CR
  gosub send_mes_ok
return

thermostat_threshold_write:
  if digitcount=2 and digittotal[0]<95 then
    t_word=digittotal[0]
    x=t_word.byte0*2
    if digittotal[1]<10 then
      y=(digittotal[1]/5)
    else
      y=0
    endif
    i2cdata=x+y+64 
    Temp_threshold=i2cdata
    eep_addr.byte1=0                        'Page
    eep_addr.byte0=17                       'address
    gosub write_eeprom    
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

temperature_module_enable:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=15
  Temp_Mod_Installed=1
  i2cdata=0
  gosub write_eeprom       
  gosub send_mes_ok
return

temperature_module_disable:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=15
  Temp_Mod_Installed=0
  i2cdata=255
  gosub write_eeprom       
  gosub send_mes_ok
return

thermostat_outside_link_read:
  hserout2 [dec Outside_Sensor,13,10]       
  gosub send_mes_ok
return

pump_delay_read:
  hserout2 [dec pump_delay,13,10]       
  gosub send_mes_ok
return

thermostat_outside_link_write:
  if digitcount=1 and digittotal[0]<32 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=16
    t_word=digittotal[0]
    i2cdata=t_word.byte0
    Outside_Sensor=i2cdata
    gosub write_eeprom       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

input_invert_read:
  if digitcount=1 and digittotal[0]<240 then
    x=(digittotal[0]/8)+1
    y=digittotal[0]//8
    gosub calculate_invert 
    i2cdata=z
    gosub print_i2cdata_ok      
  else
    error_code=23
    gosub send_error 
  endif
return

Calculate_invert:
  z=inp_invert[x-1]>>y
  z=z.bit0
return

input_invert_write:
  if digitcount=2 and digittotal[0]<240 and digittotal[1]<2 then
    t_word=digittotal[0]
    t_word2=digittotal[1]
    x=(t_word.byte0)/8
    y=(t_word.byte0)//8
    z=t_word2.byte0
    if z=0 then                             'requested bit needs to be 0
      a=%00000001<<y
      a=~a
      inp_invert[x]=inp_invert[x]&a
      i2cdata=0
    else                                    'requested bit needs to be 1
      a=%00000001<<y
      inp_invert[x]=inp_invert[x]|a
      i2cdata=255
    endif
    eep_addr.byte1=32                       'Page
    eep_addr.byte0=t_word.byte0             'write invert status  
    gosub write_eeprom      
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

pump_delay_write:
  if digitcount=1 and digittotal[0]<249 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=19
    t_word=digittotal[0]
    i2cdata=t_word.byte0
    pump_delay=i2cdata
    gosub write_eeprom       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

schedule_queue_list:
  if sched_queue_counter>0 then
    for x=0 to (Sched_queue_max-1)
      if Sched_Type[x]<255 then
        hserout2 [dec3 x," ",dec Sched_hour[x]," ",dec Sched_minute[x]," ",dec Sched_day[x]," ",dec Sched_type[x]," ",dec Sched_action[x],13,10]  
      endif
    next x
  else  
    gosub empty_list
  endif  
  gosub send_mes_ok  
return

schedule_queue_delete:
  if digitcount=1 and digittotal[0]<102 then
    t_word=digittotal[0]
    y=t_word.byte0
    Sched_hour[y]=255
    Sched_minute[y]=255
    Sched_type[y]=255
    sched_Action[y]=255
    Sched_queue_counter=Sched_queue_counter-1 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

time_write:
  if digitcount=4 and digittotal[0]<24 and digittotal[1]<60 and digittotal[2]<60 and digittotal[3]<8 then
    i2caddr = 0                             'write seconds
    t_word=digittotal[2]
    gosub DS1307_write
    i2caddr = 1                             'write minutes
    t_word=digittotal[1]
    gosub DS1307_write  
    i2caddr = 2                             'write hours
    t_word=digittotal[0]
    gosub DS1307_write
    i2caddr = 3                             'write days
    t_word=digittotal[3]
    gosub DS1307_write
    gosub read_seconds
    gosub read_minutes
    gosub read_hours
    gosub read_day
    gosub thermostat_timing
    gosub send_mes_ok  
  else
    error_code=23
    gosub send_error
  endif
return

DS1307_write:
  x=t_word.byte0
  a=x//10
  b=x/10
  c=b<<4
  i2cdata = a|c    
  gosub write_i2c_2
return

time_read:
  hserout2 [dec hours,":",dec2 minutes,":",dec2 seconds," ",dec days,13,10]
  gosub send_mes_ok
return

firmware_version:
  hserout2 ["F",dec version,".",dec firmware,".",dec built," H",dec hardware,13,10]
  gosub send_mes_ok
return

thermostat_mode_read:
  gosub read_CH
  hserout2 [c,": Thermostat ON=",dec ThermostatOn,13,10,"Automatic Mode=",dec ThermostatMode.bit3,13,10,BIN8 ThermostatMode,13,10]
  if thermostatmode.bit6=1 then   'Multi-tenancy is enabled
    Gosub MT1
    for y=0 to (controllers-1)
      Gosub MT2
    next y
  endif
  gosub send_mes_ok
return

MT1:
  hserout2 ["Multi Tenancy enabled",13,10]
return

MT2:
  eep_addr.byte1=199   'page
  eep_addr.byte0=32+y
  gosub read_eeprom 
  hserout2 [dec2 y," ",bin8 i2cdata,13,10]
return

input_link_all_read:                        'instruction "input link list"
  for x=1 to controller_in
    for y=0 to 7
      t_word=(x-1)*8+y
      hserout2 [dec3 t_word," "]
      gosub input_link_read_sub
    next y
  next x
  gosub send_mes_ok
return

'action_activate:
'  if digitcount=2 and digittotal[0]<204 and digittotal[1]<4 then      'attention: banks not yet implemented here !!!
'    gosub Increase_queue_pointer
'    queue_type[queue_pointer]=0               'simple action
'    t_word=digittotal[0]
'    queue_action[queue_pointer]=t_word.byte0
'    if mode_com=0 then
'      gosub send_mes_ok
'    endif
'  else
'    error_code=23
'    gosub send_error
'  endif   
'return
          
basic_action_activate:
  if digitcount=2 and digittotal[0]<256 and digittotal[1]<256 then 
    t_word=digittotal[0]
    t_word2=digittotal[1]
    gosub Increase_queue_pointer
    queue_type[queue_pointer]=t_word.byte0
    queue_action[queue_pointer]=t_word2.byte0
    if mode_com=0 then
      gosub send_mes_ok
    endif
  else
    error_code=23
    gosub send_error
  endif   
return          

group_activate:
  if digitcount=1 and digittotal[0]<160 then 
    gosub Increase_queue_pointer
    queue_type[queue_pointer]=2             'group action
    t_word=digittotal[0]
    queue_action[queue_pointer]=t_word.byte0
    if mode_com=0 then
      gosub send_mes_ok
    endif
  else
    error_code=23
    gosub send_error
  endif
return

'decision_activate:
'  if digitcount=1 and digittotal[0]<192 then 
'    gosub Increase_queue_pointer
'    queue_type[queue_pointer]=9             'simple decision
'    t_word=digittotal[0]
'    queue_action[queue_pointer]=t_word.byte0
'    if mode_com=0 then
'      gosub send_mes_ok
'    endif
'  else
'    error_code=23
'    gosub send_error
'  endif
'return

schedule_activate:
  if digitcount=1 and digittotal[0]<102 then
    t_word=digittotal[0]
    gosub Increase_queue_pointer
    queue_type[queue_pointer]=3             'scheduled action
    queue_action[queue_pointer]=t_word.byte0
    if mode_com=0 then
      gosub send_mes_ok
    endif
  else
    error_code=23
    gosub send_error
  endif
return

action_read:                                'digittal[0]->action nr, [1]->bank nr
  if digitcount=2 and digittotal[0]<204 and digittotal[1]<4 then
    t_word=digittotal[0]
    a=t_word.byte0/51
    b=t_word.byte0//51
    t_word2=digittotal[1]
    eep_addr.byte1=93+a+(4*t_word2.byte0)   'page
    eep_addr.byte0=(5*b)
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=(5*b)+1
    gosub read_eeprom
    y=i2cdata    
    eep_addr.byte0=(5*b)+2
    gosub read_eeprom
    t_word2.byte0=i2cdata
    eep_addr.byte0=(5*b)+3
    gosub read_eeprom
    t_word2.byte1=i2cdata    
    eep_addr.byte0=(5*b)+4
    gosub read_eeprom
    z=i2cdata   
    hserout2 [dec x," ",dec y," ",dec t_word2," ",dec Z,13,10]       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif  
return

schedule_read:
  if digitcount=1 and digittotal[0]<102 then
    t_word=digittotal[0]
    a=t_word.byte0/51
    b=t_word.byte0//51
    eep_addr.byte1=113+a                    'page
    eep_addr.byte0=(5*b)
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=(5*b)+1
    gosub read_eeprom
    y=i2cdata    
    eep_addr.byte0=(5*b)+2
    gosub read_eeprom
    q=i2cdata
    eep_addr.byte0=(5*b)+3
    gosub read_eeprom
    v=i2cdata    
    eep_addr.byte0=(5*b)+4
    gosub read_eeprom
    z=i2cdata  
    hserout2 [dec x," ",dec y," ",dec q," ",dec v," ",dec Z,13,10]       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

decision_read:
  if digitcount=1 and digittotal[0]<192 then
    t_word=digittotal[0]
    a=t_word.byte0/32
    t_word2=digittotal[1]
    eep_addr.byte1=87+a                     'page
    for j=0 to 7
      eep_addr.byte0=(t_word.byte0-(32*a))*8+j
      gosub read_eeprom
      hserout2 [dec i2cdata," "]     
    next j
    gosub display_LF_CR 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return


display_LF_CR:
  hserout2 [13,10]
return

'input_address_list:
'  if digitcount=0 then
'    if controller_in=0 then
'      gosub empty_list
'      gosub send_mes_ok
'    else
'      for ic=1 to controller_in
'        eep_addr.byte1=1+ic                 'page
'        hserout2 [dec2 ic-1," "]
'        gosub address_read
'      next ic 
'      gosub send_mes_ok
'    endif
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

'output_address_list:
'  if digitcount=0 then
'    if controller_out=0 then
'      gosub empty_list
'      gosub send_mes_ok
'    else
'      for ic=1 to controller_out
'        eep_addr.byte1=32+ic                'page
'        hserout2 [dec2 ic-1," "]
'        gosub address_read
'      next ic 
'      gosub send_mes_ok
'    endif
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

input_number_modules_read:
  if digitcount=0 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=1
    gosub read_eeprom
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error 
  endif  
return

output_number_modules_read:
  if digitcount=0 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=2
    gosub read_eeprom
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error 
  endif  
return

input_number_modules_write:
  if digitcount=1 and digittotal[0]<31 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=1
    t_word=digittotal[0]
    i2cdata=t_word.byte0
    gosub write_eeprom
    gosub activate_eeprom       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

echo_on:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=12
  i2cdata=255
  gosub write_eeprom
  EchoOnBit=1    
  gosub send_mes_ok
return

echo_off:
  eep_addr.byte1=0                          'page
  eep_addr.byte0=12
  i2cdata=0
  gosub write_eeprom
  EchoOnBit=0    
  gosub send_mes_ok
return

output_number_modules_write:
  if digitcount=1 and digittotal[0]<31 then
    eep_addr.byte1=0                        'page
    eep_addr.byte0=2
    t_word=digittotal[0]
    i2cdata=t_word.byte0
    gosub write_eeprom
    gosub activate_eeprom       
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

'input_address_read:
'  if digitcount=1 and digittotal[0]<30 then
'    t_word=digittotal[0]
'    eep_addr.byte1=2+t_word.byte0           'page
'    gosub address_read 
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

address_read:
  for j=0 to 3
    eep_addr.byte0=j
    gosub read_eeprom
    hserout2 [dec i2cdata]
    if j<>3 then
      hserout2 ["."]     
    endif
  next j
  Gosub display_LF_CR 
return

input_address_write:
  if digitcount=5 and digittotal[0]<30 then
    t_word=digittotal[0]
    eep_addr.byte1=2+t_word.byte0           'page
    gosub address_write
    gosub activate_eeprom 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

address_write:
  for j=0 to 3
    eep_addr.byte0=j
    t_word2=digittotal[j+1]
    i2cdata=t_word2.byte0
    gosub write_eeprom      
  next j
return

'output_address_read:
'  if digitcount=1 and digittotal[0]<30 then
'    t_word=digittotal[0]
'    eep_addr.byte1=33+t_word.byte0          'page
'    gosub address_read
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

output_address_write:
  if digitcount=5 and digittotal[0]<30 then
    t_word=digittotal[0]
    eep_addr.byte1=33+t_word.byte0          'page
    gosub address_write
    gosub activate_eeprom 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

startup_read:
  if digittotal[0]<100 and digitcount=1 then'startup read
    eep_addr.byte1=1                        'page
    t_word=digittotal[0]
    eep_addr.byte0=T_word.byte0*2
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=T_word.byte0*2+1
    gosub read_eeprom
    y=i2cdata  
    hserout2 [dec3 x," ",dec3 y,13,10]   
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

startup_write:
  if digittotal[0]<100 and digitcount=3 then'startup write
    eep_addr.byte1=1                        'page
    t_word=digittotal[0]
    eep_addr.byte0=T_word.byte0*2
    t_word2=digittotal[1]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    eep_addr.byte0=T_word.byte0*2+1
    t_word2=digittotal[2]
    i2cdata=t_word2.byte0  
    gosub write_eeprom    
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

startup_list:
  eep_addr.byte1=1                          'page
  for j=0 to 99
    eep_addr.byte0=j*2
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=j*2+1
    gosub read_eeprom
    y=i2cdata
    if x<>255 then    
      hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]
    else
      if j=0 then
        gosub empty_list
      endif
      j=99  
    endif      
  next j
  gosub send_mes_ok
return

startup_activate:
  eep_addr.byte1=1                          'page
  for j=0 to 99
    eep_addr.byte0=j*2
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=j*2+1
    gosub read_eeprom
    y=i2cdata
    if x<>255 then                          'add to queue   
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=x
      queue_action[queue_pointer]=y
    else
      j=99  
    endif      
  next j
  gosub send_mes_ok
return

pump_group_read:
  if digittotal[0]<8 and digitcount=1 then  'pump group read
    t_word=digittotal[0]
    x=t_word.byte0
    for j=0 to 31
      eep_addr.byte1=143+(59*thermostatCooling)                    'page 143 or 201
      eep_addr.byte0=(x*32)+j
      gosub read_eeprom
      a=i2cdata
      if a<>255 then    
        length=16                           'Max number of characters      
        hserout2 [dec2 j," ",dec3 a," "]    
        gosub eeprom_output_address         'Calculate eeprom output address
        Spaces=0 
        gosub display_name
        gosub display_LF_CR             
      else
        if j=0 then
          gosub empty_list
        endif  
        j=31                                'exit
      endif
    next j
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return 

pump_group_write:
  if digittotal[0]<8 and digittotal[1]<32 and digitcount=3 then            'pump group write
    t_word=digittotal[0]
    a=t_word.byte0
    t_word=digittotal[1]
    b=t_word.byte0  
    eep_addr.byte1=143+(59*thermostatCooling)                      'page 143 or 201
    eep_addr.byte0=(a*32)+b
    t_word2=digittotal[2]
    i2cdata=t_word2.byte0  
    gosub write_eeprom
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

pump_output_write:
  if digittotal[0]<8 and digitcount=2 then  'pump output write
    t_word=digittotal[0]
    a=t_word.byte0
    t_word=digittotal[1]
    b=t_word.byte0  
    eep_addr.byte1=144+(59*thermostatCooling)                      'page 144 or 203
    eep_addr.byte0=a
    i2cdata=b  
    gosub write_eeprom
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

pump_output_read:
  if digittotal[0]<8 then                   'pump output read
    t_word=digittotal[0]
    a=t_word.byte0 
    eep_addr.byte1=144+(59*thermostatCooling)                      'page 144 or 203
    eep_addr.byte0=a  
    gosub read_eeprom
    a=i2cdata                               'output number
    length=16                               'Max number of characters       
    hserout2 [dec3 a," "]    
    gosub eeprom_output_address             'Calculate eeprom output address
    Spaces=0
    gosub display_name
    gosub display_LF_CR     
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

group_read:
  if digittotal[0]<160 and digitcount=1 then                                    'group read
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=67+a                     'page
    for j=0 to 15
      eep_addr.byte0=((T_word.byte0-(8*a))*32)+(j*2)
      gosub read_eeprom
      x=i2cdata
      eep_addr.byte0=((T_word.byte0-(8*a))*32)+(j*2)+1
      gosub read_eeprom
      y=i2cdata    
      hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]      
    next j
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

group_write:                                '[0]->group nr, [1]->position, [2]->action byte, [3]->action number
  if digittotal[0]<160 and digittotal[1]<16 and digitcount=4 then          'group write
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=67+a                     'page
    t_word2=digittotal[1]
    eep_addr.byte0=((T_word.byte0-(8*a))*32)+(t_word2.byte0*2)
    t_word2=digittotal[2]
    i2cdata=t_word2.byte0  
    gosub write_eeprom
    t_word2=digittotal[1]
    eep_addr.byte0=((T_word.byte0-(8*a))*32)+(t_word2.byte0*2)+1
    t_word2=digittotal[3]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

'action_write:                               'digittal[0]->action nr, [1]->bank nr, [2]->Config Byte, [3]-> outputnr, [4]->timer, [5]->dimmer 
'  if digitcount=6 and digittotal[0]<204 and digittotal[1]<4 then
'    digittotal[6]=digittotal[5]                                                                  
'    t_word=digittotal[4]
'    digittotal[4]=t_word.byte0
'    digittotal[5]=t_word.byte1
'    t_word=digittotal[0]
'    a=t_word.byte0/51
'    b=t_word.byte0//51
'    t_word2=digittotal[1]
'    eep_addr.byte1=93+a+(4*t_word2.byte0)   'page
'    for j=0 to 4
'      t_word2=digittotal[2+j]
'      eep_addr.byte0=(5*b)+j
'      i2cdata=t_word2.byte0
'      gosub write_eeprom    
'    next j 
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

schedule_write:
  if digitcount=6 and digittotal[0]<102 and digittotal[1]<25 and digittotal[2]<60 then
    t_word=digittotal[0]
    a=t_word.byte0/51
    b=t_word.byte0//51
    eep_addr.byte1=113+a                    'page
    for j=0 to 4
      t_word2=digittotal[1+j]
      eep_addr.byte0=(5*b)+j
      i2cdata=t_word2.byte0
      gosub write_eeprom    
    next j 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

'decision_write:
'  if digitcount=9 and digittotal[0]<192 then
'    t_word=digittotal[0]
'    a=t_word.byte0/32
'    t_word2=digittotal[1]
'    eep_addr.byte1=87+a                     'page
'    for j=0 to 7
'      eep_addr.byte0=(t_word.byte0-(32*a))*8+j
'      t_word2=digittotal[1+j]
'      i2cdata=t_word2.byte0
'      gosub write_eeprom      
'    next j 
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

dim_min:
  if digitcount=2 and digittotal[0]<240 and digittotal[1]<63 then               'dim-
    t_word=digittotal[0]
    t_word2=digittotal[1]
    if (dimmer_value[t_word.byte0]-dim_minimum)>t_word2.byte0 then
      dimmer_value[t_word.byte0]=dimmer_value[t_word.byte0]-t_word2.byte0
    else
      dimmer_value[t_word.byte0]=dim_minimum
    endif
    write_yes=1
    write_yes_mod[(t_word.byte0)/8]=1
    out_update[t_word.byte0]=1
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error     
  endif
return

dim_plus:
  if digitcount=2 and digittotal[0]<240 and digittotal[1]<63 then               'dim+
    t_word=digittotal[0]
    t_word2=digittotal[1]
    dimmer_value[t_word.byte0]=dimmer_value[t_word.byte0]+t_word2.byte0
    if dimmer_value[t_word.byte0]>63 then
      dimmer_value[t_word.byte0]=63
    endif
    write_yes=1
    write_yes_mod[(t_word.byte0)/8]=1
    out_update[t_word.byte0]=1
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

module_discover_stop:
  if digitcount=0 then                      'input read stop
    gosub bus_live
    gosub send_mes_ok
    EepPage0=1
    OledEeprom.byte0 = 0
    OledEeprom.byte1 = 0
    RS485busy=0
  else
    error_code=23
    gosub send_error  
  endif          
return

module_discover_start:
  if digitcount=0 then
    pause 50
    gosub bus_init
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error  
  endif  
return

discover_can_control:
  if digitcount=1 and digittotal[0]<5 and digittotal[0]>0 then
    pause 50
    gosub bus_init
    pause 100
    broad1="I"
    broad2="D"
    broaddata=digittotal[0]
    BroadID="C"    'for CAN modules only
    gosub send_broad
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif     
return

exit1:                                      'go back to API mode
  gosub bus_live
  Mode_com=1                                'API mode
  debugmode=0                               'switch off debug mode
  InputDebug=0                              'Input debug off
  SyncDebug=0                               'Sync debug off
return

eeprom_write:
  if digittotal[0]<256 and digittotal[1]<256 and digittotal[2]<256 and digitcount=3 then
    t_word=digittotal[1]
    eep_addr.byte0=t_word.byte0             'address
    t_word=digittotal[0]
    eep_addr.byte1=t_word.byte0             'page
    t_word=digittotal[2]
    i2cdata=t_word.byte0
    gosub write_eeprom  
    gosub send_mes_ok
  else
    error_code=20
    gosub send_error
  endif
return

eeprom_read:
  if digittotal[0]<256 and digittotal[1]<256 and digitcount=2 then
    t_word=digittotal[1]
    eep_addr.byte0=t_word.byte0             'address
    t_word=digittotal[0]
    eep_addr.byte1=t_word.byte0             'page
    gosub read_eeprom  
    gosub print_i2cdata_ok
  else
    error_code=18
    gosub send_error
  endif
return

output_timer_write:
  if digittotal[0]<240 and digitcount=2 then
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page
    eep_addr.byte0=4+(b*2)
    t_word2=digittotal[1]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    i2cdata=t_word2.byte1
    eep_addr.byte0=5+(b*2)
    gosub write_eeprom
    timer_cd[t_word.byte0]=t_word2
    gosub send_mes_ok
  else
    error_code=22
    gosub send_error
  endif
return

output_timer_read:
  if digittotal[0]<240 and digitcount=1 then
    timer=digittotal[0]
    gosub Timer_value_read
    hserout2 [dec timer,13,10]
    gosub send_mes_ok
  else
    error_code=21
    gosub send_error
  endif 
return

Timer_value_read:
  a=timer.byte0/8
  b=timer.byte0//8
  eep_addr.byte1=33+a                       'page
  eep_addr.byte0=4+(b*2)
  gosub read_eeprom
  timer.byte0=i2cdata
  eep_addr.byte0=5+(b*2)
  gosub read_eeprom
  timer.byte1=i2cdata
return

validation_bit_read:
  if digittotal[0]<256 and digitcount=1 then
    t_word=digittotal[0]
    a=t_word.byte0
    hserout2 [dec val_bit[a],13,10]
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

validation_bit_write:
  if digittotal[0]<256 and digittotal[1]<2 and digitcount=2 then
    t_word=digittotal[0]
    a=t_word.byte0
    t_word=digittotal[1]
    b=t_word.byte0
    val_bit[a]=b
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

output_status_read:
  if digittotal[0]<240 and digitcount=1 then
    t_word=digittotal[0]
    gosub display_output_status
    gosub display_LF_CR  
    gosub send_mes_ok   
  else
    error_code=23
    gosub send_error
  endif
return

display_output_status:
  x=(t_word.byte0)//8
  y=(t_word.byte0)/8
  z=out[y]>>x
  if z.bit0=1 then
    hserout2 ["1 "]
  else
    hserout2 ["0 "]
  endif
  hserout2 [dec dimmer_value[t_word.byte0]," "]
  a=t_word
  length=16
  Spaces=0 
  gosub eeprom_output_address
  gosub display_name
return

Dimmer_follow:
  if q<240 then                           'Check follow output only when it's a valid output
    r=q
    eep_addr.byte1=65                     'page
    eep_addr.byte0=q  
    gosub read_eeprom
    if i2cdata<240 then                   'a "follow" output is defined
      gosub check_output                  'check if output is on, q must contain output nr 
      v=z                                 'result of check_output in v
      q=i2cdata
      gosub check_output                  'check if output is on, q must contain output nr                
      if v.bit0=1 and z.bit0=0 then       'Output is on
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=161     'Output On
        queue_action[queue_pointer]=i2cdata
        dimmer_value[i2cdata]=dimmer_value[r]
      elseif v.bit0=0 and z.bit0=1 then
        gosub Increase_queue_pointer
        queue_type[queue_pointer]=160     'Output Off
        queue_action[queue_pointer]=i2cdata        
      endif
    endif
    q=r     
  endif
return

output_on:
  t_word=digittotal[0]
  if digittotal[0]<240 and digittotal[1]<240 then
    out_update[t_word.byte0]=1
    if digitcount=3 then
      timer_cd[t_word.byte0]=digittotal[2]
      t_word2=digittotal[1]
      x=(t_word.byte0)//8
      y=(t_word.byte0)/8
      if Mod_id0[30+y]="D" or Mod_id0[30+y]="d" then             'only when dimmer
        dimmer_value[t_word.byte0]=t_word2.byte0
      else
        dimmer_value[t_word.byte0]=63
      endif
      z=%00000001
      z=z<<x
      out[y]=out[y]|z
      write_yes=1
      write_yes_mod[(t_word.byte0)/8]=1
      tp=q
      q=t_word.byte0
      gosub dimmer_follow
      q=tp      
    endif          
    if digitcount=2 then
      t_word2=digittotal[1]
      x=(t_word.byte0)//8
      y=(t_word.byte0)/8
      if Mod_id0[30+y]="D" or Mod_id0[30+y]="d" then             'only when dimmer
        dimmer_value[t_word.byte0]=t_word2.byte0
      else
        dimmer_value[t_word.byte0]=63
      endif
      z=%00000001
      z=z<<x
      out[y]=out[y]|z
      write_yes=1
      write_yes_mod[(t_word.byte0)/8]=1
      tp=q
      q=t_word.byte0
      gosub dimmer_follow
      q=tp      
    endif
    if digitcount=1 then
      x=(t_word.byte0)//8
      y=(t_word.byte0)/8
      z=%00000001
      z=z<<x
      out[y]=out[y]|z
      write_yes=1
      write_yes_mod[(t_word.byte0)/8]=1
      tp=q
      q=t_word.byte0
      gosub dimmer_follow
      q=tp      
    endif
    if mode_com=0 and queue_pointer=0 then
      gosub send_mes_ok
    endif
    OdCode=12                               'Output debug code
    OdOutputNr=t_word.byte0
    gosub Output_debug                      'Display on console when outbug debug is on   
  else
    error_code=16
    gosub send_error
  endif   
return

output_off:
  if digittotal[0]<240 and digitcount=1 then 
    t_word=digittotal[0]
    x=(t_word.byte0)//8
    y=(t_word.byte0)/8
    z=%00000001
    z=z<<x
    z=~z
    out[y]=out[y]&z
    out_update[t_word.byte0]=1
    write_yes=1
    write_yes_mod[y]=1
    if mode_com=0 and queue_pointer=0 then
      gosub send_mes_ok
    endif
    OdCode=13                               'Output debug code
    OdOutputNr=t_word.byte0
    gosub Output_debug                      'Display on console when outbug debug is on
    tp=q
    q=t_word.byte0
    gosub dimmer_follow
    q=tp      
  else
    error_code=15
    gosub send_error
  endif  
return

input_link_write:
  if digittotal[0]<240 and digittotal[1]<256 and digitcount=2 then
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=2+a                      'page 2 to 31
    eep_addr.byte0=4+b                      'byte 4 to 11
    t_word2=digittotal[1]
    i2cdata=t_word2.byte0
    gosub write_eeprom
    gosub activate_eeprom
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif
return

input_action_read:                          'digittotal[0]-> input number
  if digittotal[0]<240 and digitcount=1 then            'input action read
    ok=0
    gosub input_link_read
    ok=1
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=2+a                      'page
    for j=0 to 14
      eep_addr.byte0=12+(30*b)+(j*2)
      gosub read_eeprom
      x=i2cdata
      eep_addr.byte0=13+(30*b)+(j*2)
      gosub read_eeprom
      y=i2cdata
      hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]      
    next j
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif  
return

output_status_on:
  if digitcount=0 and controller_out>0 then
    AllOff=1
    for j=0 to (controller_out-1)
      if out[j]>0 then
        y=out[j]
        for x=0 to 7
          z=y>>x
          if z.bit0=1 then
            AllOff=0                        'not all lights are off
            if mode_com=0 then              'CLI mode
              hserout2 [dec3 (j*8)+x," ",dec3 dimmer_value[(j*8)+x]," ",dec5 Timer_cd[(j*8)+x]," "]
              a=(j*8)+x
              length=16
              Spaces=0 
              gosub eeprom_output_address
              gosub display_name
              gosub display_LF_CR
            endif
          endif
        next x
      endif
    next j
    if mode_com=0 then                      'CLI mdoe
      gosub send_mes_ok
    else                                    'advanced mode
      if AllOff=1 then
        Hserout2 ["ON",0,0,0,0,0,0,0,0,0,0,0,0,0,13,10]
      endif    
    endif 
  else
    error_code=23
    gosub send_error
  endif  
return

read_CH:
  if ThermostatCooling=0 then           'Heating
    c="H"
  else                                    'Cooling
    c="C"
  endif
return

thermostat_list:
  gosub read_CH
  for j=0 to (controllers-1)
    hserout2 [c,": ",dec2 j," "]
    a=j
    length=16
    Spaces=0
    gosub eeprom_thermostat_address
    gosub display_name      
    hserout2 [" "]
    x=setpt[j]
    gosub temperature_display_sub
    y=thermostatsensor[j]
    x=temperature[y]
    gosub temperature_display_sub
    hserout2 ["(",dec ThermostatSensor[j],") - "]
    t_word=thermostat[j]
    gosub display_output_status
    hserout2 ["(",dec thermostat[j],") - "]
    t_word=thermostat2[j]
    gosub display_output_status
    hserout2 ["(",dec thermostat2[j],") "]      
    gosub display_LF_CR
  next j
  gosub send_mes_ok 
return

input_action_write:                         'digittotal[0]->input number, [1]->input action number, [2]->action type, [3]->action number
  if digittotal[0]<240 and digitcount=4 and digittotal[1]<15 then            'input action write
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=2+a                      'page
    t_word2=digittotal[1]
    eep_addr.byte0=12+(30*b)+(t_word2.byte0*2)
    t_word=digittotal[2]
    i2cdata=t_word.byte0
    gosub write_eeprom
    eep_addr.byte0=13+(30*b)+(t_word2.byte0*2)
    t_word=digittotal[3]
    i2cdata=t_word.byte0
    gosub write_eeprom
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif  
return

simple_action_read:                         'digittotal[0]-> input number, digittotal[1]-> bank nr
  t_word=digittotal[0]
  a=t_word.byte0/8
  b=t_word.byte0//8
  eep_addr.byte1=2+a                        'page
  for j=0 to 14
    eep_addr.byte0=12+(30*b)+(j*2)
    gosub read_eeprom
    x=i2cdata
    eep_addr.byte0=13+(30*b)+(j*2)
    gosub read_eeprom
    y=i2cdata
    hserout2 [dec2 j," ",dec3 x," ",dec3 y,13,10]      
  next j  
return

input_link_read:
  if digittotal[0]<240 and digitcount=1 then
    t_word=digittotal[0]
    gosub input_link_read_sub
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif  
return

pulse_counter_link_read:
  if digittotal[0]<NumberPulseCounters and digitcount=1 then
    t_word=digittotal[0]
    a=t_word.byte0
    i2cdata=PulseInput[a] 
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error
  endif 
return

pulse_counter_link_write:
  if digittotal[0]<NumberPulseCounters and digitcount=2 then
    t_word=digittotal[0]
    a=t_word.byte0
    eep_addr.byte1=0                        'page 0
    eep_addr.byte0=160+a
    t_word=digittotal[1] 
    i2cdata=t_word.byte0   
    gosub write_eeprom  
    PulseInput[a]=t_word.byte0
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

floor_level_read:
  if digittotal[0]<240 and digitcount=1 then
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=157+b    
    gosub read_eeprom  
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error
  endif  
return

floor_level_write:
  if digittotal[0]<240 and digitcount=2 then
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=157+b
    t_word=digittotal[1] 
    i2cdata=t_word.byte0   
    gosub write_eeprom  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

Output_Indicate:
  if digittotal[0]<240 and digitcount=1 then
    gosub normal_Powerstate                 'Put leds of all modules in normal powerstate
    t_word=digittotal[0]
    indicate=t_word.byte0
    IndicateInput=0
    IndicateTemperature=0
    write_yes=1
    write_yes_mod[indicate/8]=1  
    gosub send_mes_ok
    OdCode=14                               'Output debug code
    OdOutputNr=indicate
    gosub Output_debug                      'Display on console when outbug debug is on 
  else
    error_code=23
    gosub send_error
  endif 
return

Queue_output_indicate:
  ok=0
  Digitcount=1
  Digittotal[0]=queue_action[i]
  gosub output_indicate
return

Temperature_Indicate:
  if digittotal[0]<32 and digitcount=1 then
    gosub normal_Powerstate                 'Put leds of all modules in normal powerstate
    t_word=digittotal[0]
    indicate=t_word.byte0
    IndicateInput=0
    IndicateTemperature=1  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

Queue_sensor_indicate:
  ok=0
  Digitcount=1
  Digittotal[0]=queue_action[i]
  gosub temperature_indicate
return

Input_Indicate:
  if digittotal[0]<240 and digitcount=1 then
    gosub normal_Powerstate                 'Put leds of all modules in normal powerstate
    t_word=digittotal[0]
    indicate=t_word.byte0
    IndicateInput=1
    IndicateTemperature=0  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

Queue_input_indicate:
  ok=0
  Digitcount=1
  Digittotal[0]=queue_action[i]
  gosub input_indicate
return

Virtual_input_press:
  x=queue_action[i]
  y=x/8
  z=x//8
  'delete
  'hserout2 [dec x," ",dec y," ",dec z," ",bin8 inp[y],13,10]
  if Mod_ID0[y]="i" then   'Only for virtual inputs
    'inp[i-1]=~Rs485string[4]
    Rs485string[4]=~(inp[y]|(%00000001<<z))
    'delete
    'hserout2 ["i ",bin8 Rs485string[4],13,10]
    vi=i
    i=y+1  
    gosub analyse_input
    i=vi
  endif  
return

Virtual_input_release:
  x=queue_action[i]
  y=x/8
  z=x//8
  'delete
  'hserout2 [dec x," ",dec y," ",dec z," ",bin8 inp[y],13,10]
  if Mod_ID0[y]="i" then   'Only for virtual inputs
    'inp[i-1]=~Rs485string[4]
    vi=~(%00000001<<z)
    Rs485string[4]=~(inp[y]&vi)
    'delete
    'hserout2 ["i ",bin8 Rs485string[4],13,10]
    vi=i
    i=y+1  
    gosub analyse_input
    i=vi
  endif 
  
return

output_type_read:
  if digittotal[0]<240 and digitcount=1 then
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=149+b  
    gosub read_eeprom
    gosub print_i2cdata_ok
  else
    error_code=23
    gosub send_error
  endif  
return

output_type_write:
  if digittotal[0]<240 and digitcount=2 then
    t_word=digittotal[0]
    a=t_word.byte0/8
    b=t_word.byte0//8
    eep_addr.byte1=33+a                     'page 33 and higher
    eep_addr.byte0=149+b
    t_word=digittotal[1] 
    i2cdata=t_word.byte0   
    gosub write_eeprom  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error
  endif 
return

input_link_read_sub:
  a=t_word.byte0/8
  b=t_word.byte0//8
  eep_addr.byte1=2+a                        'page 2 to 31
  eep_addr.byte0=4+b                        'byte 4 to 11
  gosub read_eeprom
  u=i2cdata
  a=t_word
  length=8
  c=i2cdata
  Spaces=0
  gosub eeprom_input_address
  gosub display_name
  hserout2 [" -> ",dec3 u," "]
  a=c
  Spaces=0
  length=16
  gosub eeprom_output_address
  gosub display_name
  gosub display_LF_CR
return

'brightness_read:
'  if digitcount=1 and digittotal[0]<32 then
'    t_word=digittotal[0]
'    a=t_word.byte0
'    if ldr[a]<>255 then
'      hserout2 [dec ldr[a],13,10]
'    else
'      hserout2 ["Sensor not connected",13,10]   
'    endif   
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

brightness_list:
  for j=0 to 31
    if ldr[j]<>255 then    
      hserout2 [dec2 j," ",dec3 ldr[j]]
    else
      gosub sensor_not_connected  
    endif
    gosub display_sensor_name      
  next j 
gosub send_mes_ok
return

empty_list:
  hserout2 ["Empty list",13,10] 
return


'temperature_read:
'  if digitcount=1 and digittotal[0]<32 then
'    t_word=digittotal[0]
'    j=t_word.byte0
'    x=temperature[j]
'    gosub temperature_display
'    gosub display_LF_CR  
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

pid_config_list:
  gosub read_CH
  eep_addr.byte1=141+(59*thermostatCooling)                        'Page 141 or 200
  for pid=0 to (controllers-1)
    for x=0 to 3
      eep_addr.byte0=(pid*4)+x
      gosub read_eeprom
      serstring[x]=i2cdata
    next x
    Hserout2 [c,": PID parameters ",dec2 pid,": Kp=",dec3 serstring[0]," Ki=",dec3 serstring[1]," Kd=",dec3 serstring[2]," It=",Dec3 serstring[3],13,10]
  next pid
  gosub send_mes_ok
return

pid_config_write:
  if digitcount=5 and digittotal[0]<32 then
    t_word=digittotal[0]
    pid=t_word.byte0
    eep_addr.byte1=141+(59*thermostatCooling)                      'Page 141 or 200
    for x=0 to 3
      t_word=digittotal[x+1]
      i2cdata=t_word.byte0
      eep_addr.byte0=(pid*4)+x              'address
      gosub write_eeprom  
    next x
    gosub send_mes_ok         
  else
    error_code=23
    gosub send_error 
  endif
return

setpoint_read:
  if digitcount=1 and digittotal[0]<controllers then
    t_word=digittotal[0]
    j=t_word.byte0
    x=SetPt[j]
    gosub temperature_display 
    gosub display_LF_CR 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

thermostat_details_read:
  if digitcount=1 and digittotal[0]<controllers then
    t_word=digittotal[0]
    j=t_word.byte0
    pid=j
    gosub read_CH
    hserout2 [c,": Current Setpoint: "] 
    x=SetPt[j]
    gosub temperature_display 
    gosub display_LF_CR 
    for a=0 to 5                            'display setpoints
      hserout2 ["Programmed Setpoint ",dec a,": "]
      gosub programmed_setpoint_read_sub
    next a                                  'display timings
    for y=1 to 7                            'display Monday till Sunday
      hserout2 [dec y," "]
      for z=0 to 3                          'Display 2x start-stop time
        a=18+((y-1)*4)+z
        gosub programmed_timings
        gosub read_eeprom
        if i2cdata<145 then
          hserout2 [dec2 (i2cdata/6),":",dec2 (i2cdata//6)*10," "]
        else
          hserout2 ["--:-- "]     
        endif  
      next z
      gosub display_LF_CR  
    next y
    if thermostatmode.bit6=1 then   'Multi-tenancy is enabled
      Gosub MT1
      y=j
      Gosub MT2
    endif  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

thermostat_link_read:
  if digitcount=1 and digittotal[0]<controllers then
    t_word=digittotal[0]
    a=t_word.byte0
    hserout2 [dec thermostat[a]," ",dec thermostat2[a],13,10] 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

thermostat_sensor_read:
  if digitcount=1 and digittotal[0]<controllers then
    t_word=digittotal[0]
    a=t_word.byte0
    hserout2 [dec ThermostatSensor[a],13,10] 
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

programmed_setpoint_read:
  if digitcount=2 and digittotal[1]<6 and digittotal[0]<controllers then
    t_word=digittotal[0]
    j=t_word.byte0
    t_word=digittotal[1]
    a=t_word.byte0
    gosub programmed_setpoint_read_sub
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

programmed_setpoint_read_sub:
  eep_addr.byte1=142+(59*thermostatCooling)                        'page 142 or 201
  eep_addr.byte0=(a*32)+j+32
  gosub read_eeprom  
  x=i2cdata
  gosub temperature_display
  gosub display_LF_CR
return

programmed_setpoint_write:
  if digitcount=4 and digittotal[1]<6 and digittotal[0]<controllers then
    y=0
    t_word=digittotal[0]
    b=t_word.byte0
    t_word=digittotal[1]
    a=t_word.byte0
    t_word=digittotal[2]
    x=t_word.byte0*2
    if digittotal[3]<10 then
      y=(digittotal[3]/5)
    else
      y=0  
    endif
    i2cdata=x+y+64 
    eep_addr.byte1=142+(59*thermostatCooling)                      'Page 142 or 201
    eep_addr.byte0=(a*32)+b+32              'address
    gosub write_eeprom    
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

setpoint_write:
  if digitcount=3 and digittotal[0]<controllers then
    y=0
    t_word=digittotal[0]
    j=t_word.byte0
    t_word=digittotal[1]
    x=t_word.byte0*2
    if digittotal[2]<10 then
      y=(digittotal[2]/5)
    else
      y=0  
    endif
    SetPt[j]=x+y+64
    i2caddr = 40+j
    i2cdata = setpt[j]
    gosub write_i2c_2   
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

sync_page:
  if digitcount=1 and digittotal[0]<256 then
    t_word=digittotal[0]
    OledEeprom.byte1=(t_word.byte0)-1 'page
    OledEeprom.byte0=254              'byte  
    oledDataOk=1
    SyncEnable=1
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

sync_stop:
    SyncEnable=0
    gosub send_mes_ok
return

sync_debug_on:
    SyncDebug=1
    gosub send_mes_ok
return

sync_debug_off:
    SyncDebug=0
    gosub send_mes_ok
return    

thermostat_link_write:
  if digittotal[0]<controllers and digitcount<4 then
    t_word=digittotal[0]
    j=t_word.byte0
    t_word=digittotal[1]
    x=t_word.byte0
    thermostat[j]=x
    i2cdata=x 
    eep_addr.byte1=142+(59*thermostatCooling)                      'Page 142 or 201
    eep_addr.byte0=j                        'address
    gosub write_eeprom 
    if digitcount=3 then
      t_word=digittotal[2]
      x=t_word.byte0
      thermostat2[j]=x
      i2cdata=x 
      eep_addr.byte1=142+(59*thermostatCooling)                    'Page 142 or 201
      eep_addr.byte0=j+224                  'address
      gosub write_eeprom   
    endif  
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

thermostat_sensor_write:
  if digitcount=2 and digittotal[0]<controllers then
    t_word=digittotal[0]
    j=t_word.byte0
    t_word=digittotal[1]
    x=t_word.byte0
    ThermostatSensor[j]=x
    i2cdata=x 
    eep_addr.byte1=144+(59*thermostatCooling)                      'Page 144 or 203
    eep_addr.byte0=j+8                      'address
    gosub write_eeprom   
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error 
  endif
return

'humidity_read:
'  if digitcount=1 and digittotal[0]<32 then
'    t_word=digittotal[0]
'    j=t_word.byte0
'    x=humidity[j]
'    gosub humidity_display
'    gosub display_LF_CR  
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error 
'  endif
'return

display_sensor_name:
  a=j                                       'sensor number number
  length=16                                 'Max number of characters 
  Spaces=0      
  hserout2 [" "]    
  gosub eeprom_sensor_address  '            Calculate eeprom sensor address
  gosub display_name
  gosub display_LF_CR 
return

temperature_list:
  for j=0 to 31
    x=temperature[j]
    gosub temperature_display
    gosub display_sensor_name      
  next j 
  gosub send_mes_ok
return

humidity_list:
  for j=0 to 31
    x=humidity[j]
    gosub humidity_display
    gosub display_sensor_name      
  next j 
  gosub send_mes_ok
return

temperature_display:
  if x<>255 then
    hserout2 [dec2 j," "]
    gosub temperature_display_sub
  else
    gosub sensor_not_connected  
  endif 
return

temperature_display_sub:
  if x>63 then                              'temperature positive
    z=(x/2)-32
    y="+"
  else                                      'temperature negative
    x=64-x
    z=x/2
    y="-"   
  endif    
  if x=255 then                             'sensor not connected
    hserout2 [" --.- "]  
  else
    hserout2 [y,dec2 z,".",dec (x//2)*5," "]
  endif
return

humidity_display:
  if x<>255 then   
    hserout2 [dec2 j," ",dec x/2,".",dec (x//2)*5,"%RH"]
  else
    gosub sensor_not_connected  
  endif 
return

sensor_not_connected:
   hserout2 [dec2 j," Sensor not connected"]
return

error_list:
  hserout2 ["i2c errors: ",dec i2cError,"/",dec i2cError2," ",dec PORTD.5,":",dec PORTD.6," PC",dec pollcheck,13,10] 
  if controller_in =0 then
    hserout2 ["Empty input list",13,10]
  else
    a=1
    for j=0 to (controller_in-1)
      x=j
      gosub Error_display 
    next j
  endif
  if controller_out=0 then
    hserout2 ["Empty output list",13,10]
  else
    a=0
    for j=0 to (controller_out-1)
      x=j+30
      Gosub Error_display 
    next j
  endif
  if controller_out_RS>0 and controller_out_RS<31 then
    hserout2 ["Large Installation enabled",13,10]
    for i=1 to controller_out_RS
      gosub get_ID
      hserout2 [dec2 i-1," R ",dec3 digit[0],".",dec3 digit[1],".",dec3 digit[2],".",dec3 digit[3]," Roller/Shutter",13,10]
    next i
  endif  
  gosub send_mes_ok
return

Error_display:
  hserout2 [dec2 j," ",Mod_Id0[x]," ",dec3 Mod_Id0[x],".",dec3 Mod_Id1[x],".",dec3 Mod_Id2[x],".",dec3 Mod_Id3[x]," ",dec ErrorBit[x]," "] 
  if x<30 then
    eep_addr.byte1=2+x                     'page
  else
    eep_addr.byte1=3+x
  endif  
  eep_addr.byte0=252
  gosub read_eeprom 
  if i2cdata=255 then
    hserout2 ["  "]
  else
    hserout2 [i2cdata," "]
  endif 
  if ErrorCount[x]=0 then    
    hserout2 ["No Errors",13,10]
  else
    hserout2 ["# of Errors: ",dec ErrorCount[x],13,10]  
  endif   
return

Error_clear:
  for j=0 to 59
    ErrorBit[j]=0
    ErrorCount[j]=0
  next j
  ErrorBit[61]=0
  i2cError=0
  i2cError2=0
  i2cTimeScan=0
  Err=0
  gosub send_mes_ok
return

display_io_list:
  hserout2 [dec3 a," "]
return

input_list:
  for x=1 to controller_in
    for y=0 to 7
      a=(x-1)*8+y                           'input number
      length=8                              'Max number of characters
      Spaces=0
      gosub calculate_invert
      hserout2 [dec3 a," ",dec z," "]    
      gosub eeprom_input_address            'calculate eeprom input address
      gosub display_name                    'display input or output name
      hserout2 [" -> ",dec3 sel_output[a]]
      gosub display_LF_CR
    next y
  next x
  gosub send_mes_ok
return

input_enable_list:
  b=0
  for x=1 to controller_in
    for y=0 to 7
      a=(x-1)*8+y                           'input number
      b=b+1
      hserout2 [dec3 a," ",dec InputEnable[a],"   "]    
      if b>7 then 
        gosub display_LF_CR
        b=0
      endif  
    next y
  next x
  gosub send_mes_ok
return

pulse_counter_list:
  for x=0 to (NumberPulseCounters-1)
    hserout2 [dec x," ",dec5 PulseCounter[x]," "]
    a=x                                     'Pulse Counter
    length=16                               'Max number of characters 
    Spaces=0         
    gosub eeprom_pulse_address              'Calculate eeprom pulse address
    gosub display_name
    gosub display_LF_CR 
  next x  
  gosub send_mes_ok
return

output_list:
  for x=1 to controller_out
    for y=0 to 7
      timer=(x-1)*8+y                       'output number
      gosub timer_value_read      
      a=(x-1)*8+y                           'output number
      hserout2 [dec3 a," ",dec5 timer," "]
      length=16                             'Max number of characters 
      Spaces=0     
      gosub eeprom_output_address           'Calculate eeprom output address
      gosub display_name
      gosub display_LF_CR
    next y
  next x
  gosub send_mes_ok
return

display_list:
  if i2cdata<255 then                  
    length=16                               'Max number of characters 
    Spaces=0      
    hserout2 [dec3 a," "]                   'output number is a     
    gosub display_name
    gosub display_LF_CR   
  endif
return    

'action_list:
'  for a=0 to 203
'    x=a/51
'    y=a//51
'    eep_addr.byte1=93+x                     'page
'    eep_addr.byte0=(5*y)
'    gosub read_eeprom
'    gosub eeprom_action_address             'Calculate eeprom output address
'    gosub display_list
'  next a
'  gosub send_mes_ok
'return

group_list:
  for a=0 to 159
    x=a/8
    eep_addr.byte1=67+x                     'page
    eep_addr.byte0=(a-(8*x))*32
    gosub read_eeprom
    gosub eeprom_group_address              'Calculate eeprom output address
    gosub display_list      
  next a
  gosub send_mes_ok
return

'decision_list:
'  for a=0 to 191
'    x=a/32
'    eep_addr.byte1=87+x                     'page
'    eep_addr.byte0=(a-(32*x))*8
'    gosub read_eeprom
'    gosub eeprom_decision_address           'Calculate eeprom output address
'    gosub display_list     
'  next a
'  gosub send_mes_ok
'return

schedule_list:
  for a=0 to 101
    x=a/51
    y=a//51
    eep_addr.byte1=113+x                    'page
    eep_addr.byte0=(5*y)
    gosub read_eeprom 
    gosub eeprom_schedule_address           'Calculate eeprom output address
    gosub display_list    
  next a
  gosub send_mes_ok
return

eeprom_input_address:
  eep_addr.byte1=115+(a/32)                 'page
  eep_addr.byte0=8*(a//32)                  'address
return

eeprom_output_address:
  eep_addr.byte1=33+(a/8)
  eep_addr.byte0=20+((a//8)*16)             'address
return

eeprom_pulse_address:
  eep_addr.byte1=98+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_action_address:
  eep_addr.byte1=145+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_group_address:
  eep_addr.byte1=158+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_decision_address:
  eep_addr.byte1=168+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_schedule_address:
  eep_addr.byte1=180+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_thermostat_address:
  eep_addr.byte1=187+(a/16)+(17*thermostatCooling)      'Start page 187 or 204
  eep_addr.byte0=(a//16)*16                 'address
return

eeprom_message_address:
  eep_addr.byte1=125+(a/2)
  eep_addr.byte0=(a//2)*128                 'address 
return

eeprom_number_address:
  eep_addr.byte1=123
  eep_addr.byte0=16+(c*16)                  'address
return

display_name:
  if a<240 then
    for z1=1 to length
      gosub read_eeprom
      if i2cdata=255 and z1=1 then
        if length>15 then
          hserout2 ["Empty          "]
          CRC=CRC+847                       'sum of "Empty" + spaces is 847
        else
          hserout2 ["Empty  "] 
          CRC=CRC+591                       'sum of "Empty" + spaces is 591
        endif
        z1=length                           'exit
      endif
      if i2cdata>127 then                   'no ascii character
        if Spaces=1 then
          hserout2 [32]                     'space
          CRC=CRC+32
        else
          z1=length                         'exit
        endif  
      else
        gosub print_i2cdata
        CRC=CRC+i2cdata
        eep_addr.byte0=eep_addr.byte0+1     'address next byte 
      endif    
    next z1
  else
    if a=240 then
      hserout2 ["Special function"]
    endif
    if a=241 then
      hserout2 ["All Outputs OFF"]
    endif
    if a>241 and a<249 then
      hserout2 ["All/Floor Lights OFF"]
    endif  
    if a=255 then
      hserout2 ["No Function"]
    endif
  endif 
return

input_name_write:
  if digitcount=1 and digittotal[0]<240 and text=1 and textlength>0 then
    t_word=digittotal[0]
    a=t_word.byte0                          'input number
    b=8                                     'max number of characters
    gosub eeprom_input_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

add_virtual_m:
  if e="o" or e="d" then  'Virtual output
    a=controller_out
    b=33         'Output pages
    c=0          'start byte on output pages
    d=1          'Controller_type -> output
  endif
  if e="i" then  'Virtual input
    a=controller_in
    b=2          'Output pages
    c=0          'start byte on output pages
    d=2          'Controller_type -> input
  endif    
  RS485String[0]=e
  RS485String[1]=0
  RS485String[2]=controller_out
  RS485String[3]=controller_in
return

add_virtual_module:
  'if digitcount=1 and digittotal[0]<240 and text=1 and textlength>0 then
  e=recchar[textstart]
  if digitcount=0 and text=1 and textlength=1 and (e="o" or e="i" or e="d") then
    'hserout2 ["textlength=",dec textlength," ",recchar[textstart],13,10]
    gosub add_virtual_m
    gosub add_m
    gosub send_mes_ok  
  else
    error_code=23
    gosub send_error   
  endif  
return

output_name_write:
  if digitcount=1 and digittotal[0]<240 and text=1 and textlength>0 then
    t_word=digittotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_output_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

pulse_counter_name_write:
  if digitcount=1 and digittotal[0]<8 and text=1 and textlength>0 then
    t_word=digittotal[0]
    a=t_word.byte0                          'Pulse Counter number
    b=16                                    'max number of characters
    gosub eeprom_pulse_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

sensor_name_write:
  if digitcount=1 and digittotal[0]<32 and text=1 and textlength>0 then
    t_word=digittotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_sensor_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

eeprom_sensor_address:
  eep_addr.byte1=193+(a/16)
  eep_addr.byte0=(a//16)*16                 'address
return

'action_name_write:
'  if digitcount=1 and digittotal[0]<204 and text=1 and textlength>0 then
'    t_word=digittotal[0]
'    a=t_word.byte0                          'output number
'    b=16                                    'max number of characters
'    gosub eeprom_action_address
'    gosub write_name
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error   
'  endif
'return

group_name_write:
  if digitcount=1 and digittotal[0]<160 and text=1 and textlength>0 then
    t_word=digittotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_group_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

'decision_name_write:
'  if digitcount=1 and digittotal[0]<192 and text=1 and textlength>0 then
'    t_word=digittotal[0]
'    a=t_word.byte0                          'output number
'    b=16                                    'max number of characters
'    gosub eeprom_decision_address
'    gosub write_name
'    gosub send_mes_ok
'  else
'    error_code=23
'    gosub send_error   
'  endif
'return

schedule_name_write:
  if digitcount=1 and digittotal[0]<102 and text=1 and textlength>0 then
    t_word=digittotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_schedule_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return

thermostat_name_write:
  if digitcount=1 and digittotal[0]<32 and text=1 and textlength>0 then
    t_word=digittotal[0]
    a=t_word.byte0                          'output number
    b=16                                    'max number of characters
    gosub eeprom_thermostat_address
    gosub write_name
    gosub send_mes_ok
  else
    error_code=23
    gosub send_error   
  endif
return


write_name:                                 'write name in eeprom
  for z1=1 to b                             'b=max number of characters to write
    if z1>textlength then
      i2cdata=255
      gosub write_eeprom
    else
      i2cdata=recchar[textstart+z1-1]
      if i2cdata>31 and i2cdata<127 then gosub write_eeprom
    endif
    eep_addr.byte0=eep_addr.byte0+1
  next z1
return

convert_dec:
  error_code=255
  for s=0 to 8
    digittotal[s]=0
  next s
  text=0
  textlength=0
  DigitCount=0                              'convert ascii to decimal
  for s=charpointer to (Buffer_size-1)      'search for space or enter
    if recchar[s]>47 and recchar[s]<58 then
      gosub convert_1value
      if text=0 then DigitCount=DigitCount+1
    endif
    if recchar[s]=13 or error_code<>255 then'enter received or error
      s=(Buffer_size-1)                     'exit routine
    else
      if recchar[s]=" " or recchar[s]="." or recchar[s]=":" then         'space received or . or : received
        CharPointer=CharPointer+1
      else
        if text=0 then
          text=1                            'it is text, not a value
          textstart=charpointer
          gosub convert_text
          s=(Buffer_size-1)                 'exit routine        
        endif   
      endif   
    endif  
  next s
return

convert_1value:
  for j=0 to 4
    digit[j]=0
  next j
  j=0
  for k=charpointer to (Buffer_size-1)
    if recchar[k]>47 and recchar[k]<58 then 'ascii character between 0 and 9                  
      digit[4]=digit[3]                     'start shifting digit
      digit[3]=digit[2]
      digit[2]=digit[1]
      digit[1]=digit[0]
      digit[0]=recchar[k]-48
      j=j+1
      if j>5 then                           'Maximum 5 digits
        k=(Buffer_size-1)                   'exit loop
        error_code=19
        gosub send_error
      endif
    else
      if recchar[k]=13 or recchar[k]=" " or recchar[k]="." or recchar[k]=":" then    
        charpointer=k                       'change pointer
        s=k
        k=(Buffer_size-1)                   'exit loop
        Digittotal[digitcount]=digit[0]+(digit[1]*10)+(digit[2]*100)+(Digit[3]*1000)+(digit[4]*10000)
      else                                  'it's not a value but a text message
        text=1                              'it is text, not a value
        textstart=charpointer
        gosub convert_text
        k=(Buffer_size-1)                   'exit loop convert_1value
        s=(Buffer_size-1)                   'exit loop convert_dec
      endif
    endif
  next k
return

convert_text:
' check number of text messages
' check length of text message and startcharacter
' remove "enter" and "carriage return"
  textlength=0
  for p=textstart to (Buffer_size-1)
    if recchar[p]=13 then                   'carriage return
      p=(Buffer_size-1)                     'exit loop
    else
      textlength=textlength+1
    endif
  next p
return


Bus_init:                                      
  mode="I"                                  'Bus in initialization mode
  broad1="I"
  broad2="I"
  BroadID=0
  low led_red
  gosub send_broad                          'send initialization code (broadcast) on RS485 network
  pause 10
  gosub send_broad
  pause 15
  gosub send_broad
  pause 5         
  InterpreteSer1=0
  RCSTA1.4=1                                'enable receiving serial 1 
return

Bus_live:                                  
  mode="L"                                  'Bus in Live mode
  broad1="L"
  broad2="L"
  BroadID=0
  high led_red
  gosub send_broad                          'send initialization code (broadcast) on RS485 network
  pause 10
  gosub send_broad
  pause 15
  gosub send_broad
  pause 5
  write_yes=1                               'write outputs
  for u=1 to controller_out
    write_yes_mod[u-1]=1
  next u       
return

Normal_PowerState:
  Broad1="N"                                'Put modules in normal state
  Broad2="N"
  BroadID=0
  gosub send_broad
  PowerSafe=0
return

Normal_PowerState_2:
  Gosub Normal_PowerState
  gosub Increase_queue_pointer
  queue_type[queue_pointer]=235             'delay next instructions with 120 seconds
  queue_action[queue_pointer]=120 
  gosub Increase_queue_pointer
  queue_type[queue_pointer]=64              'Switch off leds on all modules
  queue_action[queue_pointer]=0 
  gosub Increase_queue_pointer
  queue_type[queue_pointer]=235             'Stop delaying next actions
  queue_action[queue_pointer]=255      
return

Low_PowerState:
  Broad1="S"                                'Put modules in power Safe state
  Broad2="S"
  BroadID=0
  gosub send_broad
  PowerSafe=1
return

test_command:
  if test="%" then                          'end of command
    if TestChar[cmd]=1 then                 'valid command found
      instruction=cmd
      CharPointer=j                         'pointer where digits must start
      j=Buffer_size-1                       'end of test
    endif
  endif
  if test=recchar[j] then                   'character found on the correct place
    TestChar[cmd]=TestChar[cmd]&1
  else                                      'character not found on the correct place
    TestChar[cmd]=0  
  endif
return


send_mes_ok:
  if ok=1 then    
   hserout2 ["OK",13,10]
  endif
  instruction=255
  recchar[0]=0
return

send_broad:
  pause 4
  high RS485_mode                           'Send mode  
  pause pause_value
  pause 2
  gosub empty_e
  RS485message="B"
  e[0]=broadID
  e[1]=0
  e[2]=0
  e[3]=0
  e[4]=broad1
  e[5]=broad2
  e[6]=broadData
  gosub send_rs485_long
  pause 2
  low RS485_mode                            'Receive mode
return

Check_Thermostat_values:
  for i=0 to 223                            'Check all night temperatures, if values are not yet defined, put them on 16 degree
    eep_addr.byte0=i                        'address
    eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212
    gosub read_eeprom                       'read # of input modules
    if i2cdata=255 then                     'temperature is not yet defined
      eep_addr.byte0=i                      'address
      eep_addr.byte1=198+(14*thermostatCooling)        'page 198 or 212
      i2cdata=96                            'write 16 degree
      gosub write_eeprom
    endif  
  next i    
return

'------------------------------------------------------------------------------
' Activate data from eeprom, for more details see http://wiki.openmotics.com/index.php/Memory_Model
'------------------------------------------------------------------------------

'Copy data from eeprom into RAM

Read_Controller_InOut:
  'Read # of input devices
  eep_addr.byte0=1                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom                         'read # of input modules
  if i2cdata<31 then                        'Max of 30 input devices can be used
    controller_in=i2cdata
  else
    if i2cdata=255 then                     'value of an empty eeprom
      i2cdata=0
      gosub write_eeprom
    else
      error_code=11                         'send Error code
      gosub send_error
    endif
    controller_in=0
    error_ID[0]=0
    error_ID[1]=0
    error_ID[2]=0
    error_ID[3]=0
  endif     
  
  'Read # of output devices
  eep_addr.byte0=2                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom                         'read # of output modules
  if i2cdata<31 then                        'Max of 30 output devices can be used
    controller_out=i2cdata
  else
    if i2cdata=255 then                     'value of an empty eeprom
      i2cdata=0
      gosub write_eeprom
    else
      error_code=12                         'send Error code
      gosub send_error
    endif  
    controller_out=0
    error_ID[0]=0
    error_ID[1]=0
    error_ID[2]=0
    error_ID[3]=0
  endif
 
 'Read # of Roller/Shutter devices when Large Installation is enabled
  eep_addr.byte0=3                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom                         'read # of output modules
  if i2cdata<31 then                        'Max of 30 output devices can be used
    controller_out_RS=i2cdata
  else
    i2cdata=0
    gosub write_eeprom 
    controller_out_RS=0
  endif
  
  'Read ID's, toggling outputs, timer values etc
  for t=1 to controller_in                  'check eeprom for input devices
    eep_addr.byte1=t+1
    eep_addr.byte0=0                        'Read ID0
    gosub read_eeprom
    Mod_ID0[t-1]=i2cdata
    if i2cdata="L" then OledInstalled=1     'Check if an oled display is installed
    eep_addr.byte0=1                        'Read ID1
    gosub read_eeprom    
    Mod_ID1[t-1]=i2cdata
    eep_addr.byte0=2                        'Read ID2
    gosub read_eeprom    
    Mod_ID2[t-1]=i2cdata
    eep_addr.byte0=3                        'Read ID3
    gosub read_eeprom   
    Mod_ID3[t-1]=i2cdata
    FOR q=0 to 7            
      eep_addr.byte0=q+4                    'address
      eep_addr.byte1=t+1                    'page
      gosub read_eeprom                     'read all toggling outputs
      sel_output[((t-1)*8)+q]=i2cdata     
    next q   
  next t
  
  for t=0 to 239
    eep_addr.byte1=32
    eep_addr.byte0=t                        'Read invert status 
    gosub read_eeprom
    a=t/8
    b=t//8
    if i2cdata=255 then                     '1   NO
      x=%00000001<<b
      inp_invert[a]=inp_invert[a]|x      
    else                                    '0   NC
      x=%00000001<<b
      x=~x
      inp_invert[a]=inp_invert[a]&x      
    endif   
  next t
  
  'check eeprom for output devices
  for t=1 to controller_out
    eep_addr.byte1=t+32
    eep_addr.byte0=0                        'Read ID0
    gosub read_eeprom
    Mod_ID0[t+29]=i2cdata
    eep_addr.byte0=1                        'Read ID1
    gosub read_eeprom    
    Mod_ID1[t+29]=i2cdata
    eep_addr.byte0=2                        'Read ID2
    gosub read_eeprom    
    Mod_ID2[t+29]=i2cdata
    eep_addr.byte0=3                        'Read ID3
    gosub read_eeprom   
    Mod_ID3[t+29]=i2cdata 
  next t  
  
return

Check_LIM:   'Check if Large installation can be enabled automatically
  eep_addr.byte0=27                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then                       'Large Installation mode is not yet enabled
    if controller_in=0 and controller_out=0 then  'Enable Large Installation Mode
      LargeInstallation=1
      eep_addr.byte0=27                         'address
      eep_addr.byte1=0                          'page
      i2cdata=0
      gosub write_eeprom      
    else
      LargeInstallation=0
    endif
  else
    LargeInstallation=1
  endif
return

Read_ThermostatMode:
  'Read Thermostat Mode
  eep_addr.byte0=14                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom  
  if i2cdata=255 then 
    Thermostatmode=131                      'Away temp in manual mode
  else
    Thermostatmode=i2cdata
    ThermostatMode=ThermostatMode & %11011111  'Non used bits are put on 0    
  endif
  thermostatCooling=thermostatmode.bit4  
  gosub write_thermostatmode
  gosub Set_CoolingHeating
return

activate_eeprom:
  OledInstalled=0
  broad1="A"     'Activate Eeprom in CAN Control modules
  broad2="E"
  broaddata=0    
  BroadID="C"    'for CAN modules only
  gosub send_broad  
  pause 50
  gosub reset_error

  gosub read_Controller_InOut

  'Read minimum dimmer value
  eep_addr.byte0=5                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<63 then 
    dim_minimum=i2cdata
  else
    dim_minimum=5
  endif  
  
  'Read Dim Step
  eep_addr.byte0=6                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<4 and i2cdata>0 then 
    dim_step=i2cdata
  else
    dim_step=1
  endif 
  
  'Read Dim Cycle
  eep_addr.byte0=7                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom 
  if i2cdata<64 and i2cdata>1 then 
    dim_cycle=i2cdata
  else
    dim_cycle=15
  endif 
  
  'Read Dimmer_memory function (keep dimmed value in memory or full intensity when switched on)
  eep_addr.byte0=9                          'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<255 then 
    dimmer_mem=i2cdata
  else
    dimmer_mem=1                            'dimmer_mem=1:keep dimmer value in memory, dimmer_mem=0: don't keep it in memory
  endif 
  
  'Read Debug bit, if byte10=1-> debug mode, if byte10=255-> normal mode
  eep_addr.byte0=10                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=1 then                         'Debug mode on
    DebugMode=1
  else
    DebugMode=0
  endif 
        
  'Read automatic response bit, if byte11=255-> AutResponse=0, if byte11<>255->AutResponse=0
  eep_addr.byte0=11                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      'Debug mode on
    autresponse=1                           '-> "RO" response in advanced mode
  else
    autresponse=0                           '-> No automatic response
  endif
  
  'Read Echo On byte
  eep_addr.byte0=12                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom  
  if i2cdata=0 then 
    EchoOnBit=0
  else
    EchoOnBit=1
  endif     
  
  'Read API/CLI byte during start up
  if startup=1 then                         'only do this during startup
    eep_addr.byte0=13                       'address
    eep_addr.byte1=0                        'page
    gosub read_eeprom  
    if i2cdata<255 then 
      Mode_com=1
      debugmode=0
    else
      Mode_com=0
    endif
  endif
   
    
  'Read Temperature Module installed Byte
  eep_addr.byte0=15                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom  
  if i2cdata=255 then 
    Temp_Mod_Installed=0                    'Temperature module not installed
  else
    Temp_Mod_Installed=1                    'Temperature module installed
  endif 
  
  'Read Outside Sensor Byte
  eep_addr.byte0=16                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom 
  outside_sensor=i2cdata 
  if i2cdata>31 then 
    Outside_Sensor=0                        'Take Sensor number 0
  endif 
  
  'Read Temperature threshold Byte for thermostat function
  eep_addr.byte0=17                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom 
  temp_threshold=i2cdata 
 
  'Read the automatic Response byte for automatic message "OL"
  eep_addr.byte0=18                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      'Debug mode on
    autresponseOL=1                         '-> OL response in advanced mode
  else
    autresponseOL=0                         '-> No automatic response
  endif       

  'Pump delay parameter
  eep_addr.byte0=19                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom
  if i2cdata<249 then 
    pump_delay=i2cdata
  else
    pump_delay=0
  endif  
    
  eep_addr.byte0=20                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      'Debug mode on
    autresponseIL=1                         '-> LI response in advanced mode
  else
    autresponseIL=0                         '-> No automatic response
  endif   
  
  'Read if Individual temperatures for every thermostat for every day are used
  eep_addr.byte0=21                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then                       'Individual Temperatures for every thermostat are active
    IndividualTempOn=1                      '-> Individual temperatures are used
  else
    IndividualTempOn=0                      '-> General day1/2 temperatures are used per thermostat
  endif

  'Read Wait time (value*20us) between scan every input module
  eep_addr.byte0=22                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    WaitTimeInput=3
  else
    WaitTimeInput=i2cdata
  endif

  'Read Wait time (value*20us) between scan every output module
  eep_addr.byte0=23                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    WaitTimeOutput=3
  else
    WaitTimeOutput=i2cdata
  endif

  'if thermostatupdate=1 then every 10 minutes, thermostat setpoints are updated (in automatic mode only)
  'if thermostatupdate=0 then thermostat setpoints are only updated at start and stop time (in automatic mode only)
  eep_addr.byte0=24                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    ThermostatUpdate=1
  else
    ThermostatUpdate=0
  endif
  
  'Specifies the number of bytes to receive before interpretion of the received message can be done
  eep_addr.byte0=25                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    RecBytesSer1=14
  else
    RecBytesSer1=i2cdata
  endif  
  
  'Specifies the catch all functionality
  eep_addr.byte0=26                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    CatchAll=0
  else
    CatchAll=1
    if i2cdata>80 then
      CatchAllByte=6
    else
      CatchAllByte=i2cdata
    endif
  endif 

  'Enable/Disable LargeInstallation functionality
  eep_addr.byte0=27                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    LargeInstallation=0
  else
    LargeInstallation=1
  endif
  
  'Read automatic response bit, if byte28=255-> AutResponseSO=0, if byte28<>255->AutResponse=0
  eep_addr.byte0=28                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata<>255 then                      
    autresponseSO=1                          '-> "SO" response in advanced mode and Large Installation mode
  else
    autresponseSO=0                          '-> No automatic response
  endif 
  
  'Read Maximum number of errors before a module is taken offline
  eep_addr.byte0=29                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata>0 then                      
    ErrorMax=i2cdata*100                    'Max number of errors before a module is taken offline
  else
    ErrorMax=65534                          'Never take it offline
  endif
 
  'Is temperature correction received from the sensors needed?
  eep_addr.byte0=30                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata>0 then                      
    TempCor=1                   
  else
    TempCor=0
  endif 
  
  'IMaximum number of thermostats used in the system, minimum 24 maximum 32
  eep_addr.byte0=59                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata>32 or i2cdata<24 then                      
    Controllers=24
    i2cdata=24
    gosub write_eeprom                   
  else
    Controllers=i2cdata
  endif     
  
  'Offset Temperature byte 60-91
  FOR q=0 to 31                             'Read Offset Temperature
    eep_addr.byte0=q+60                     'address
    eep_addr.byte1=0                        'page
    gosub read_eeprom                       'read all toggling outputs
    TempOffset[q]=i2cdata    
  next q  
  
  'Input Filter Value
  eep_addr.byte0=92                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    InputFilter=10
  else
    InputFilter=i2cdata
  endif  
  
  'Force CRC for input modules
  eep_addr.byte0=93                         'address
  eep_addr.byte1=0                          'page
  gosub read_eeprom   
  if i2cdata=255 then   
    ForceCRC=0                              'CRC will not be forced and is optional depending on the firmware of the slave input modules
  else
    ForceCRC=1                              'CRC will be forced and messages from input modules without CRC will be dropped
  endif  
 
 
 'Read switch type values
  for t=0 to 239
    eep_addr.byte1=97                       'page
    eep_addr.byte0=t                        'Read switch type 
    gosub read_eeprom
    if i2cdata=255 then                     'Normal switch (like use in all home automation systems)
      switch_type[t]=1     
    else                                    'Toggle switch (like used in a traditional electrical installation without any automation)
      switch_type[t]=0
    endif   
  next t
  
  'Read PID values for PID controller
  gosub read_thermostat_par   

  'Read linked Pulse counter Input Information
  FOR q=0 to (NumberPulseCounters-1)            
    eep_addr.byte0=q+160                    'address
    eep_addr.byte1=0                        'page
    gosub read_eeprom                       'read all toggling outputs
    PulseInput[q]=i2cdata     
  next q
  
  'Read Virtual Sensors byte 0-31
  FOR q=0 to 31                             'Read Virtual Sensor
    eep_addr.byte0=q                        'address
    eep_addr.byte1=195                      'page
    gosub read_eeprom                       'read all Virtual sensor settings
    if i2cdata=255 then
      VirtualSensor[q]=0
    else
      VirtualSensor[q]=1
    endif    
  next q
    
  'Read which thermostats are in permanent manual mode
  a=32                                      'a=32 when in heating mode, a=64 when in cooling mode
  b=0
  gosub read_PermanentManual 
  a=64                                      'a=32 when in heating mode, a=64 when in cooling mode
  b=24                                      
  gosub read_PermanentManual   
         
  PidCalcCheck=1                            'Do the PID calculation
  'gosub input_check_led
  if mode="L" then                          'when the button module receives the live broadcast, it will switch off the leds                                           'when the module receive a scanning, it will switch on the corresponding leds
    gosub bus_live
  endif
return


read_PermanentManual:
  'Read which thermostats are in permanent manual mode  
  FOR q=0 to (controllers-1)                 'Read Virtual Sensor
    eep_addr.byte0=q+a                      'address
    eep_addr.byte1=195                      'page
    gosub read_eeprom                       'read all permanent thermostat settings
    if i2cdata=255 then
      PermanentManual[q+b]=0
    else
      PermanentManual[q+b]=1
    endif    
  next q
return

read_thermostat_par:
  for t=0 to (controllers-1)
    eep_addr.byte1=142+(59*thermostatCooling)
    eep_addr.byte0=t        
    gosub read_eeprom
    thermostat[t]=i2cdata
    eep_addr.byte0=t+224        
    gosub read_eeprom
    thermostat2[t]=i2cdata     
    eep_addr.byte1=144+(59*thermostatCooling)             'Page 144 or 203
    eep_addr.byte0=t+8        
    gosub read_eeprom
    ThermostatSensor[t]=i2cdata    
  next t
return

Thermostat_output_off:
  ok=0
  for t=0 to (controllers-1)
    if thermostat[t]<240 then                               'Switch Off thermostat outputs  
      digittotal[0]=thermostat[t]
      digitcount=1
      gosub output_off    
    endif
    if thermostat2[t]<240 then
      digittotal[0]=thermostat2[t]
      digitcount=1
      gosub output_off    
    endif        
  next t
  for t=0 to 7                                              'Switch Off Pump outputs
    eep_addr.byte1=144+(59*thermostatCooling)               'page 144 or 203
    eep_addr.byte0=t  
    gosub read_eeprom
    if i2cdata<240 then                                     'Pump output
      digittotal[0]=i2cdata
      digitcount=1
      gosub output_off
      action[4]=161
      action[5]=i2cdata
      gosub remove_timer_queue                              'Remove any pump actions still in timer queue
    endif            
  next t
  ok=1
return

'input_check_led:                            'check input for leds on button module
'  for t=1 to controller_in
'    if Mod_ID0[t-1]="B" then
'      x=0     'All leds off
'      for q=0 to 7
'        y=1
'        if sel_output[((t-1)*8)+q]<242 then
'          y=y<<q
'          x=x|y                             'appropriate led on
'        endif
'      next q
'      led_button[t-1]=x 
'    endif
'  next t  
'return

'------------------------------------------------------------------------------
' Clock
'------------------------------------------------------------------------------

find_clock:
  i2caddr = 0
  gosub read_i2c_2
  if (i2cdata.bit7=1) then                  'Clock is not running      
    error_code = 3                          'Clock is not running
    gosub send_error
    i2caddr = 0
    i2cdata = 0                             'Start clock DS1307
    gosub write_i2c_2
    for ic=0 to 29                          'If no data in mem, put all outputs on 0
      out(ic)=0
    next ic
    gosub thermostat_timing                 'set all thermostats in the right mode conform to the programmed timings
    gosub correct_setpt   
  else      
    for ic=1 to controller_out              'read from ram mem ds1307 out(x)
      i2caddr = 8+ic   
      i2cdata = 0    
      gosub read_i2c_2
      out[ic-1]=i2cdata
    next ic       
    for ic=1 to controllers                 'read from ram mem ds1307 Thermostat Setpoints
      i2caddr = 39+ic    
      i2cdata = 0    
      gosub read_i2c_2
      if i2cdata=0 then
        SetPt[ic-1]=76
      else
        SetPt[ic-1]=i2cdata
      endif    
    next ic        
    gosub thermostat_timing           
    gosub read_seconds
    gosub read_minutes
    gosub read_hours
    gosub read_day
  Endif
return

Calc_time:
  a=x&%00001111
  b=x&%01110000
  c=b>>4
  y=a+(c*10)
return

read_seconds:
  i2caddr = 0                               'read seconds
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_time
  seconds = y
return

read_minutes:
  i2caddr = 1                               'read minutes
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_time
  minutes = y
return

read_hours:
  i2caddr = 2                               'read hours
  i2cdata = 0    
  gosub read_i2c_2
  x=i2cdata
  gosub Calc_time
  if y>23 then 
    y=0
    hours=0
    i2caddr=2                               'hour address in DS1307
    t_word=hours
    gosub ds1307_write                      'Correct hour value in DS1307
  endif  
  hours = y
return

read_day:
  i2caddr = 3                               'read days
  i2cdata = 0    
  gosub read_i2c_2
  days=i2cdata
return

read_clock:
  if ScanTime=1 then
    ScanTime=0
    gosub read_seconds   
    if seconds<>seconds_old then
      if PidCalcCheck=1 then PidCalcNow=1
      TimerQueueEn=1
      seconds_old=seconds                   'do this routine only 1 time per second
      if seconds=15 or seconds=45 then
        gosub Temp_receive                  'request temperatures from temperature modules       
      endif
      if seconds=10 or seconds=40 then
        broad1="M"                          'send broadcast to start measurement sensors
        broad2="M"
        BroadId=0
        gosub send_broad      
      endif      
      if seconds=0 then
        gosub read_minutes
        if minutes=0 then
          gosub read_day
          gosub read_hours
          gosub thermostat_timing12
        elseif minutes=10 or minutes=20 or minutes=30 or minutes=40 or minutes=50 then
          gosub Set_CoolingHeating
          gosub thermostat_timing12
        endif
        gosub check_schedule_queue
      endif  
      if seconds=3 then
        PidCalcCheck=1
        PidCalcNow=1
        gosub ThermostatMode_ON
        'PumpCheckNow=1    
      endif
      if seconds=33 then
        PumpCheckNow=1
      endif   
      gosub timer_function                  'Decrease timer values for lights that are switched on
      CheckTimerQueue=1                     'gosub check_timer_queue       
    else
      gosub i2c_error
    endif
  endif  
return

i2c_error:
  if hours=0 then
    if seconds=0 and minutes=0 then
      if i2cTimeScan<255 then 
        i2cTimeScan=i2cTimeScan+1
      else
        i2cError=i2cError+1
        ResetI2c=1
        i2cTimeScan=0
      endif
    else
      i2cTimeScan=0
      ResetI2c=0
    endif
    if (err<>0) then 
      error_code = 2                      'Error Time reading
      ErrorTmp=61
      gosub send_error
    endif
  endif  
return

ThermostatMode_ON:
  if ThermostatCooling=0 then             'Heating is enabled
    if (Temp_threshold>temperature[outside_sensor]) or temperature[outside_sensor]>240 then  ' outside temperature is lower than thermostat threshold temperature 
      if ThermostatOn=0 then         'Thermostat function is off
        ThermostatOn=1               'Enable Thermostat function
        ThermostatMode.bit7=1
        gosub Write_ThermostatMode
      endif
    else
      if ThermostatOn=1 then         'Thermostat function is ON
        ThermostatOn=0               'Disable Thermostat function
        ThermostatMode.bit7=0
        gosub Write_ThermostatMode
      endif      
    endif
  endif
  if SetAuto=1 then      'If wrong temperature is read, re-read all temperatures in auto mode 
    SetAuto=0
    if ThermostatMode.bit3=1 then    'Thermostat is in automatic mode
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=141
      queue_action[queue_pointer]=1
    endif  
  endif
return

Set_TBS_Output:
  if ThermostatSensor[q]=240 and Thermostat[q]<240 then  'Time based switching (TBS)
    if setpt[q]>104 then
      gosub T_output_on
    else
      gosub T_output_off
    endif  
  endif 
return

Thermostat_timing12:
  if ThermostatUpdate=1 then
    gosub thermostat_timing
  else
    gosub thermostat_timing2
  endif 
return          

Thermostat_timing:
  Tt=(hours*6)+(minutes/10)    
  for q=0 to (controllers-1)
    gosub Thermostat_timing_sub
  next q   
return

Thermostat_timing_sub:
  if ThermostatAuto[q]=1 then             'thermostat is in automatic mode
    if PermanentManual[q+(24*thermostatCooling)]=0 then
      if Thermostat[q]<240 and ThermostatSensor[q]<241 then     'Thermostat is linked to output and Temperature sensor
        eep_addr.byte1=189+((days-1)/2)+(17*thermostatCooling)      'Start page 189 or 206
        for r=0 to 3
          eep_addr.byte0=(128*((days-1)//2))+(q*4)+r
          gosub read_eeprom
          T_timing[r]=i2cdata 
        next r    
        if T_timing[0]<145 or T_timing[2]<145 then              'valid start timing
          if T_timing[0]<=Tt and T_timing[1]>Tt then
            'action turn on thermostat Day1
            gosub Turn_on_Day1           
          elseif T_timing[2]<=Tt and T_timing[3]>Tt then
            'action turn on thermostat Day2           
            gosub Turn_on_Day2 
          else
            'action turn off thermostat Night           
            if ThermostatSensor[q]<241 then 'Temperature based switching 
              gosub Turn_on_night             
            endif           
          endif      
        else
          'action turn off thermostat Night           
          if ThermostatSensor[q]<241  then  'Temperature based switching 
            gosub Turn_on_night                  
          endif      
        endif 
      endif
    endif
  endif
return

Thermostat_timing2:                         'Will set the right setpoint only when the exact begin or end time is reached
  Tt=(hours*6)+(minutes/10)    
  for q=0 to (controllers-1)
    if ThermostatAuto[q]=1 then             'thermostat is in automatic mode
      if PermanentManual[q+(24*thermostatCooling)]=0 then
        if Thermostat[q]<240 and ThermostatSensor[q]<241 then  'Thermostat is linked to output and Temperature sensor
          eep_addr.byte1=189+((days-1)/2)+(17*thermostatCooling)      'Start page 189 or 206
          for r=0 to 3
            eep_addr.byte0=(128*((days-1)//2))+(q*4)+r
            gosub read_eeprom
            T_timing[r]=i2cdata 
          next r     
          if T_timing[0]=Tt then
            'action turn on thermostat Day1
            gosub Turn_on_Day1           
          elseif T_timing[2]=Tt then
            'action turn on thermostat Day2
            gosub Turn_on_Day2 
          elseif T_timing[1]=Tt or T_timing[3]=Tt then
            'action turn off thermostat Night
            gosub Turn_on_night
          endif      
        endif
      endif
    endif  
  next q  
return

Turn_on_Day1:
  'action turn on thermostat Day1
  if ThermostatSensor[q]<241 then       'Temperature based switching
    if IndividualTempOn=1 then          'Individual Temperatures are ON
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=145     'Day1
      queue_action[queue_pointer]=q              
    else
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=128     'setpoint 0 (day1)
      queue_action[queue_pointer]=q               
    endif
  endif                 
return

Turn_on_day2:
  'action turn on thermostat Day2
  if ThermostatSensor[q]<241 then       'Temperature based switching
    if IndividualTempOn=1 then          'Individual Temperatures are ON
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=146     'Day2
      queue_action[queue_pointer]=q              
    else
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=130     'setpoint 2 (day2)
      queue_action[queue_pointer]=q               
    endif
  endif                            
Return

Turn_on_night:
  'action turn on thermostat Night
  if ThermostatSensor[q]<241 then       'Temperature based switching
    if IndividualTempOn=1 then          'Individual Temperatures are ON
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=147     'Night
      queue_action[queue_pointer]=q              
    else
      gosub Increase_queue_pointer
      queue_type[queue_pointer]=129     'setpoint 1 (Night)
      queue_action[queue_pointer]=q               
    endif
  endif                            
Return

T_output_on:
  gosub Increase_queue_pointer
  queue_type[queue_pointer]=166         'Output on at Maximum
  queue_action[queue_pointer]=Thermostat[q]   
return

T_output_off:
  gosub Increase_queue_pointer
  queue_type[queue_pointer]=160         'Output off
  queue_action[queue_pointer]=Thermostat[q]
  z=Thermostat[q]
  dimmer_value[z]=0 
return

Empty_RecInstr:
  for j=0 to (Buffer_Size-1)
    SerString[j]=0
  next j
return

Cleanup_Serstring:
  a=0
  for j=0 to (Buffer_Size-1)
    if serstring[j]>31 and serstring<127 then a=1  'assci found
    if SerString[j]=0 and a=0 then serstring[j]=" "
    if serstring[j]=0 and a=1 then
      serstring[j]=13
      j=Buffer_Size-1
    endif
  next j
return


check_schedule_queue:                       'check if no scheduled actions must be activated
  if Sched_queue_counter>0 then             'something is in the scheduled action queue
    for t=0 to (sched_queue_max-1)
      if sched_type[t]<255 then             'valid action type
        if (Sched_hour[t]=hours and Sched_minute[t]=minutes) or (Sched_hour[t]=24 and Sched_minute[t]=0) then
          x=sched_day[t]
          x=x>>days
          if x.bit0=1 then
            gosub Increase_queue_pointer
            queue_type[queue_pointer]=Sched_type[t]
            queue_action[queue_pointer]=Sched_action[t]
            x=Sched_day[t]
            if x.bit0=0 then                'remove from queue
              digittotal[0]=t
              digitcount=1
              ok=0
              gosub schedule_queue_delete
              ok=1
            endif
          endif  
        endif
      endif
    next t
  endif
return

Increase_queue_pointer:
  if queue_pointer<(queue_max-1) then queue_pointer=queue_pointer+1
return

'------------------------------------------------------------------------------
' Timer Function
'------------------------------------------------------------------------------

check_timer_queue:                          'check timer queue for intelligent actions (pressed input for x seconds)  
  if CheckTimerQueue=1 then
    CheckTimerQueue=0  
    if timer_queue_pointer>0 then   
      for i=1 to timer_queue_pointer
        a=timer_input[i-1]/8
        b=timer_input[i-1]//8
        c=0
        d=timer_input[i-1]
        if timer_input[i-1]<240 and timer_seconds[i-1]<250 then    'Timer queue related to an input
          c=inp[a]>>b                       'This cannot be put at the start of this routine because timer input can be 240
          if c.bit0=1 then                  'button is still pressed
            gosub check_timer_count         'decrease timer and execute action when timer is at 0
          else                              'button is not pressed anymore
            timer_seconds[i-1]=0
          endif
        endif    
        if timer_input[i-1]=240 then        'Delayed execution of an action
          gosub check_timer_count           'decrease timer and execute action when timer is at 0
        endif
        if timer_seconds[i-1]=250 then
          c=inp[a]>>b                       'This cannot be put at the start of this routine because timer input can be 240
          if c.bit0=0 then
            if InputDelayAction[d]=0 then   'execute action in the queue     
              gosub Add_timer_action
            else                            'delete action from the queue
              timer_seconds[i-1]=0
            endif
          endif  
        endif
      next i    
      TimerQueueEn=0
    endif
    gosub clean_timer_queue
  endif    
return

check_timer_count:
  if timer_seconds[i-1]>0 and timer_seconds[i-1]<250 and TimerQueueEn=1 then
    d=timer_input[i-1] 
    timer_seconds[i-1]=timer_seconds[i-1]-1 
    InputDelayAction[d]=0                   'delayed action is not executed so the other actions in the queue can be executed when input is off  
    if timer_seconds[i-1]=0 then            'if timer_seconds=0 then execute action for both "input pressed" and "delayed action"
      InputDelayAction[d]=1                 'delayed action is executed so don't execute the other actions in the queue
      gosub add_timer_action                'only for delayed execution of an action
    endif    
  endif  
return  

add_timer_action:
  GOSUB Increase_queue_pointer              'add to activity queue
  queue_type[queue_pointer]=timer_type[i-1]
  queue_action[queue_pointer]=timer_action[i-1]
  timer_seconds[i-1]=0 
return

clean_timer_queue:                          'clean the queue of the non used actions anymore
  if timer_queue_pointer>0 then 
    timer_queue_last=1
    for i=timer_queue_pointer to 1 step -1
      a=timer_input[i-1]/8
      b=timer_input[i-1]//8
      c=inp[a]>>b
      if timer_seconds[i-1]=0 or timer_type[i-1]=255 then
        if timer_queue_last=1 and timer_queue_pointer>0 then
          timer_queue_pointer=timer_queue_pointer-1  'Clean up
        endif
      else
        timer_queue_last=0                  'no further clean up for the moment
      endif
    next i   
  endif
return

Fill_timer_queue:
  timer_action[t-1]=action[5]                                               
  timer_type[t-1]=action[4]
  timer_input[t-1]=action[6]
  timer_seconds[t-1]=action[3]
return  


timer_queue_list:
  for x=1 to timer_queue_pointer
    hserout2 [dec3 x-1," ",dec3 timer_type[x-1]," ",dec3 timer_action[x-1]," ",dec3 timer_input[x-1]," ",dec3 timer_seconds[x-1],13,10]
  next x  
  gosub send_mes_ok
return

Add_timer_queue2:
  i_bit=0
  if timer_queue_pointer>0 then
    for t=1 to timer_queue_pointer
      if timer_type[t-1]=255 and timer_action[t-1]=255 then             'Empty entry found
        gosub fill_timer_queue
        t=timer_queue_pointer
        i_bit=1                                                         'Info to queue added, only add once
      endif
    next t
  endif
  if i_bit=0 then                                                       'No empty spaces found, add this at the end
    t=timer_queue_pointer+1   
    gosub fill_timer_queue
    if timer_queue_pointer<(timer_queue-1) then timer_queue_pointer=timer_queue_pointer+1
  endif
return


add_timer_queue:
    'add action to the timer queue     
    action[5]=Queue_action[i]
    action[4]=Queue_type[i]
    if DelayedTime>0 and DelayedTime<250 and ActionButtonRelease=0 then   'Action after x seconds
      action[6]=240
      action[3]=DelayedTime
    else                                                                  'Action at button release
      action[6]=CurrentInput
      action[3]=250
    endif
    if CleanTimerQueue=1 then                                             'Check for double BA's and remove them, see also BA 79
      gosub remove_timer_queue
    endif  
    Gosub add_timer_queue2   
return

timer_function:
  for i=1 to controller_out
    for t=0 to 7
      x=out[i-1]>>t
      y=((i-1)*8)+t
      if timer_cd[y]>0 and x.bit0=1 then
        timer_cd[y]=timer_cd[y]-1
        if timer_cd[y]=0 then
          z=%00000001
          z=z<<t
          z=~z
          out[i-1]=out[i-1]&z
          out_update[y]=1
          timer=y
          gosub Timer_value_read            'Retreive timer value from eeprom
          timer_cd[y]=timer
          write_yes=1
          write_yes_mod[i-1]=1
          OdCode=15                         'Output debug code
          OdOutputNr=y
          gosub Output_debug                'Display on console when outbug debug is on
          tp=q
          q=y
          gosub dimmer_follow
          q=tp                 
        endif
      endif
    next t  
  next i
return


Timer_value:
  for t=0 to 7                              'check all outputs of a selected device
    x=out(i-1)>>t
    y=((i-1)*8)+t
    if x.bit0=1 then                        'selected output is ON, remember (var TimerSet) to put back the timer value
      TimerSet[y]=0
    endif  
    if x.bit0=0 and TimerSet[y]=0 then      'selected output is off
      TimerSet[y]=1
      timer=y
      Gosub Timer_value_read                'retreive timer value
      timer_cd[y]=timer                     'Put timer value in timer_cd
    endif
  next t
return     

Temp_receive:                               'routine used to check temperature in normal mode (mode="L")
  if Temp_Mod_installed=1 then              'Temperature module 16 temperature sensors
    high RS485_mode                         'Send mode
    hserout ["tmT000T",0,13,10,13,10]
    RS485Message="t"
    gosub prepare_rs485_receive
  endif 
return

Temperature_Offset:
  b=TempOffset[a]
  if b<>255 then
    c=b&%00001111
    if Temperature[a]>1 and Temperature[a]<185 then
      if b.bit7=0 then '+
        Temperature[a]=Temperature[a]+c
      else             '-
        Temperature[a]=Temperature[a]-c
      endif
    endif  
  endif
return

Read_sensor_values:
  if rs485string[4]="T" then                'Temperature  
    for ic=0 to 7
      a=(TemperatureCount*8)+ic
      gosub Set_Temperature
      gosub Temperature_Offset
    next ic     
  elseif rs485string[4]="H" then            'Humidity       
    for ic=0 to 7
      if VirtualSensor[(TemperatureCount*8)+ic]=0 then              'Virtual sensor not active so Sensor data can be update by OM sensors
        humidity[(TemperatureCount*8)+ic] = RS485string[5+ic]
      endif  
    next ic
  elseif rs485string[4]="A" then            'ADC value      
    for ic=0 to 7
      if VirtualSensor[(TemperatureCount*8)+ic]=0 then              'Virtual sensor not active so Sensor data can be update by OM sensors
        ldr[(TemperatureCount*8)+ic] = RS485string[5+ic]
      endif  
    next ic                
  endif
return

Set_Temperature:  
  if VirtualSensor[a]=0 then              'Virtual sensor not active so Sensor data can be update by OM sensors
    if outside_sensor=a then              'No lower correction for the outside sensor
      if RS485string[5+ic]<189 then
        temperature[a] = RS485string[5+ic]
      else
        temperature[a]=255  
      endif        
    else                                  'Limit inside temperature between 5 and 45 degree Celsius
      if (RS485string[5+ic]>74 and RS485string[5+ic]<154) or TempCor=0 then    
        temperature[a] = RS485string[5+ic]
      else
        temperature[a]=255      
      endif
    endif
  endif  
return


Check_response_temp_module:
  if rs485string[0]=Mod_ID0[i-1] and rs485string[1]=Mod_ID1[i-1] and rs485string[2]=Mod_ID2[i-1] and rs485string[3]=Mod_ID3[i-1] then     
    if rs485string[0]="T" and TemperatureCount<4 then                           'Temperature Module (max 4)
      if rs485string[13]="C" or ForceCRC=1 then                                 'CRC check is active at input slave module
        CRC2=rs485string[4]+rs485string[5]+rs485string[6]+rs485string[7]+rs485string[8]
        CRC2=CRC2+rs485string[9]+rs485string[10]+rs485string[11]+rs485string[12]
        if CRC2.byte1=rs485string[14] and CRC2.byte0=rs485string[15] then       'CRC is correct
          gosub Read_sensor_values
        else                                                                    'CRC is wrong
          error_ID[0]= Mod_ID0[i-1]         'Input device is not responding
          error_ID[1]= Mod_ID1[i-1]
          error_ID[2]= Mod_ID2[i-1]
          error_ID[3]= Mod_ID3[i-1]
          ErrorTmp=i-1
          error_code = 27                   'Wrong CRC or CRC information is missing
          cid = 0
          Gosub Add_ErrorCount
          gosub send_error  
        endif  
      else
        gosub Read_sensor_values
      endif      
      if TemperatureCount<3 then TemperatureCount=TemperatureCount+1       
    endif        
  else                                      'wrong device responded      
    error_ID[0]= Mod_ID0[i-1]               'device is not responding
    error_ID[1]= Mod_ID1[i-1]
    error_ID[2]= Mod_ID2[i-1]
    error_ID[3]= Mod_ID3[i-1]
    ErrorTmp=i-1
    error_code = 10
    cid = 0
    Gosub Add_ErrorCount
    gosub send_error   
  endif 
return      

'------------------------------------------------------------------------------
' Eeprom
'------------------------------------------------------------------------------

write_eeprom:  
  i2ccont = %10100000
  i2cClock=0
  if EepPage0=0 then
    OledEeprom.byte1=eep_addr.byte1
    OledEeprom.Byte0=0
  endif  
  oledDataOk=0
  OledEepromBit=0
  if OledEeprom.byte1=0 then EepPage0=1
  gosub i2c_write
return

read_eeprom:
  i2ccont = %10100001
  i2cClock=0
  gosub i2c_read  
return

write_i2c_2:
  i2ccont=%11010000
  i2cClock=1
  if i2caddr<64 then                        'Clock has 56 bytes of SRAM
    eep_addr.byte1=i2caddr
    gosub i2c_write
  endif  
return

read_i2c_2:
  i2ccont=%11010001
  i2cClock=1
  eep_addr.byte1=i2caddr
  gosub i2c_read 
return

check_i2c_acknowledge:
  if SSP2CON2.6=0 then                      'Acknowledge received from slave
    i2cAck=1                                'Acknowledge received
    SSP2CON2.6=1
  else
    i2cAck=0
  endif 
return

i2c_read:
  if i2ccont.bit0=0 then                    'r/w bit is wrong, correct
    i2ccont.bit0=1
  endif
  i2creadbit=1
  i2cint=1
  i2cmode=1
  TMR3L=0
  TMR3H=0
  T3CON.0=1                                 'start timer3
  gosub i2c_routine_read
return

i2c_write:
  if i2ccont.bit0=1 then                    'r/w bit is wrong, correct
    i2ccont.bit0=0
  endif
  i2creadbit=0
  i2cint=1
  i2cmode=1
  TMR3L=0
  TMR3H=0  
  T3CON.0=1                                 'start timer3                    
  gosub i2c_routine_write  
return

i2c_routine_write:
  while (i2cMode>0) 
    if i2cInt=1 then                        'i2c chip is ready for next instruction
      i2cInt=0  
      gosub i2cPhase1    
      if i2cMode=5 then                     'check acknowledge and send data   
        gosub check_i2c_acknowledge
        if i2cAck=1 then
          SSP2BUF=i2cData
        endif  
      endif
      if i2cMode=6 then                     'check acknowledge and sent stop   
        gosub check_i2c_acknowledge
        if i2cAck=1 then
          SSP2CON2.2=1
        endif     
      endif
      if i2cMode=7 then                     'end transmission 
        i2cMode=0
        T3CON.0=0                           'stop timer3
        err=0
        if i2cClock=0 then pause 5 
      endif    
    endif
  wend      
return

i2c_routine_read:
  while (i2cMode>0) 
    if i2cInt=1 then                        'i2c chip is ready for next instruction
      i2cInt=0  
      gosub i2cPhase1
      if i2cMode=5 then                     'generate start condition
        gosub check_i2c_acknowledge
        if i2cAck=1 then      
          SSP2CON2.0=1                      'start
        endif  
      endif
      if i2cMode=6 then                     'shift out i2c control byte
        SSP2BUF=i2ccont
      endif 
      if i2cMode=7 then
        SSP2CON2.3=1                        'enable receiving
      endif         
      if i2cMode=8 then                     'check acknowledge and receive data 
        i2cdata=SSP2BUF
        i2cMode=9 
      endif
      if i2cMode=9 then                     'sent stop   
        SSP2CON2.2=1     
      endif
      if i2cMode=10 then                    'end transmission 
        i2cMode=0
        T3CON.0=0                           'stop timer3
        err=0
      endif    
    endif
  wend      
return

i2cPhase1:
  if i2cMode=1 then                         'generate start condition
    SSP2CON2.0=1
  endif
  if i2cMode=2  then                        'shift out i2c control byte
    SSP2BUF=i2ccont-i2creadbit              'when reading i2c, you first need to write
  endif
  if i2cMode=3 then                         'check acknowledge and shift out i2c high address   
    gosub check_i2c_acknowledge
    if i2cAck=1 then
      SSP2BUF=eep_addr.byte1                'high address
    endif  
  endif
  if i2cMode=4 then                         'check acknowledge and shift out i2c low address  
    if i2cClock=1 then                      'Clock IC has only 8bits address
      i2cmode=5
    else
      SSP2BUF=eep_addr.byte0                'low address
    endif  
  endif
return

end
